<!DOCTYPE html>

<!-- 
******** License details ******************

 Copyright Klaus Hoffmeister
 2025 https://hofk.de/
 
 I am the copyright holder of this software.
 You may not physically or digitally host, display, distribute, or share this software (or any modified form thereof).
 You may not use this software in commercial or non-commercial products, websites, or projects.
 You may not sell this software, and you may not create NFTs from it.
 The software may be used for the private or non-commercial generation of geometries.
 The software and the generated geometries may be used for educational purposes
 and you may link to the software via a URL or source reference as part of your educational material.
 
**************************
-->

<head>
	<title>SingleBranchedGeometryEditor</title>
	<meta charset="utf-8" />
	<style>
		body {
			margin: 0px;
			overflow: hidden;
			text-align: center;
			background-color: #66ccff;
		}
		.container {
            position: absolute;
            top: 0;
            z-index: -1;
            width: 100%;
            height: 100%;
		}
		* {
            box-sizing: border-box;
        }
		.comp {
			position: absolute;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
		.sliderAB {
			position: absolute;
			z-index: 9;
			cursor: nw-resize;
			width: 60px;
			height: 60px;
			background-color: #2196F3;
			opacity: 0.75;
			border-radius: 50%;	
		}
  		.partsAleft {
			position: absolute;
			z-index: 9;
            left: 0%;
            top: calc( 100% - 22px );
			width: 55%;
			height: 22px;
			background-color:  #eeeeee;
            opacity: 0.80;	
		}
        .partsAright {
			position: absolute;
			z-index: 9;
            left: 45%;
            top: calc( 100% - 22px );
            width: 55%;
			height: 22px;
			background-color:  #eeeeee;
            opacity: 0.80;	
		}
        .help {
            position: absolute;
            z-index: 8; 
			left: calc( 100% - 100px );    
        }
        .hilfe {
            position: absolute;
            z-index: 8; 
			left: calc( 100% - 50px );    
        }
        .partsB {
			position: absolute;
			z-index: 9;
			width:1345px;
			height: 25px;
			background-color:  #eeeeee;
            opacity: 0.80;	
		}
 		.partsC {
			position: absolute;
			z-index: 10;
			width:800px;
			height: 25px;
			background-color:  #cccccc;
            opacity: 0.85;
			border-radius: 10%;	
		}
        #txtAngScale {
            width: 30px;
            display: inline-block;
            color:#006600;
            font-weight: bold;
        }
        #txtIdxD {
            width: 15px;
            display: inline-block;
            color:#006600;
            font-weight: bold;
        }
        #output {
            display: none;
            position: absolute;
            z-index: 1;
            top: 45%;
            left: 10%;
			width: 80%;
			height: 49%;
            padding: 5px;
            background-color: #feffe6;
            border: 2px solid #2196F3;
        }
        #keyHelpArea {
            position: absolute;
            z-index: 0;
            top: 96%;
            left: -22%;
            cursor: move;
        }
        .sliderC {
			position: absolute;
			z-index: 11;
			cursor: ew-resize;
			width: 40px;
			height: 40px;
			background-color:  #2196F3;
            opacity: 0.75;
			border-radius: 50%;	
		}
        .show_3D {
			position: absolute;
			z-index: 8;
            top: 2px;
			width: 90px;
			height: 24px;
			left: calc( 100% - 95px );
            cursor: pointer;
		}
        .useWorker {
 			position: absolute;
			z-index: 8;
            top: 27px;
			left: calc( 100% - 95px );           
        }
        .txtUseWorker {
  			position: absolute;
			z-index: 8;
            top: 27px;
			left: calc( 100% - 70px );            
        }
        .useWireframe {
 			position: absolute;
			z-index: 8;
            top: 52px;
			left: calc( 100% - 95px );           
        }        
        .txtUseWireframe {
  			position: absolute;
			z-index: 8;
            top: 52px;
			left: calc( 100% - 70px );            
        }
        .doubleEdges {
 			position: absolute;
			z-index: 8;
            top: 75px;
			left: calc( 100% - 52px );           
        }
        .txtDoubleEdges {
  			position: absolute;
			z-index: 8;
            top: 90px;
			left: calc( 100% - 90px );            
        }
		.comp-cutRadius {
			position: absolute;
			z-index: 8;
            top: 110px;
			width: 90px;
			left: calc( 100% - 85px );
			color:  #006600		
		}
		.cradius {
			width: 40px;
			border-radius: 6px;
			cursor: pointer;
		}
 		.comp-cutCount {
			position: absolute;
			z-index: 8;
            top: 280px;
			width: 90px;
			left: calc( 100% - 85px );
			color:  #006600		
		}       
        .ccount {
			width: 40px;
			border-radius: 6px;
			cursor: pointer;
		}
   		.comp-vertBasis {
			position: absolute;
			z-index: 8;
            top: 450px;
			width: 90px;
			left: calc( 100% - 85px );
			color:  #006600		
		}       
        .vbasis {
			width: 40px;
			border-radius: 6px;
			cursor: pointer;
		}      
 		.comp-vertCount {
			position: absolute;
			z-index: 8;
            top: 620px;
			width: 90px;
			left: calc( 100% - 85px );
			color:  #006600		
		}       
        .vcount {
			width: 40px;
			border-radius: 6px;
			cursor: pointer;
		}
        .triangul {
			position: absolute;
            z-index: 20;
            left: 5%;
            top:  2%;
            width: 90%;
            height: 80%;
            background-color: #dedede;
            border: 2px solid #2196F3;
        }
        .worker {
            position: absolute;
            top:  45%;
            left: 40%;
            font-family: Arial;
            font-size: 140%;
            color:#0000ff;
        }
        .canvas {
            position: relative;
 
            left: 50%;
            animation: move-back 4s linear 0s infinite;
            }
        .triangle {
            box-sizing:border-box;
            position:relative;
        }
        .triangle.left {
            width: 30px;
            height: 60px;
            border-right: solid 30px #0000ff;
            border-bottom: solid 30px transparent;
            border-top: solid 30px transparent;
        }
        .triangle.right {
            width: 30px;
            height: 60px;
            border-left: solid 30px #00ffff;
            border-bottom: solid 30px transparent;
            border-top: solid 30px transparent;
        }
        
        #p2 {
            top:-30px;
            animation: rotate-left-1 4s ease-in-out 0s infinite normal forwards running;
        }
        #p3 {
            top:-60px;
            animation: rotate-right-2 4s ease-in-out 0s infinite normal forwards running;
        }
        #p4 {
            top:-90px;
            animation: rotate-left-2 4s ease-in-out 0s infinite normal forwards running;
        }
        
        #p1 {
            animation: rotate-right-1 4s ease-in-out 0s infinite normal forwards running;
        }
        
        @keyframes rotate-right-1 {
            0% {
                transform:rotate(0);
            }
          11%,13% {
                transform-origin:30px 60px;
                transform:rotate(180deg);
            }
            25%,100% {
                transform-origin:90px top;
                transform:rotate(360deg) translatey(120px);
            }
        }
        
        @keyframes rotate-right-2 {
            0%,50%{
                transform:rotate(0);
            }
            61%,63%{
                transform-origin:30px 60px;
                transform:rotate(180deg);
            }
            75%,100% {
                transform-origin:90px top;
                transform:rotate(360deg) translatey(120px);
            }
        }
            
        @keyframes rotate-left-1 {
            0%,25% {
                transform:rotate(0) translatey(0);
            }
            36%,38% {
                transform-origin:0px 60px;
                transform:rotate(-180deg) translatey(0);
            }
            50%,100% {
                transform-origin:-60px 120px;
                transform:rotate(-360deg) translatey(120px);
            }
        }
        @keyframes rotate-left-2 {
            0%,75% {
                transform:rotate(0) translatey(0);
            }
            86%,88% {
                transform-origin:0px 60px;
                transform:rotate(-180deg) translatey(0);
            }
            100% {
                transform-origin:-60px 120px;
                transform:rotate(-360deg) translatey(120px);
            }
        }
            
        @keyframes move-back {
            0%{
                top:120px;
            }
            100%{
                top:0px;
            }
        }
        
        .fin {
            position: absolute;
            z-index: 20;
            left: 1%;
            top:  1%;
            width: 98%;
            height: 98%;
            color: #ff0033;
            background-color: #ffff00;
            font-weight: bold;
            border: 2px solid #ff0033;
        }
        .btn {
            width: 76px;
            cursor: pointer;
        }
        .btnApd {
            width: 120px;
            cursor: pointer;
        }
        .digits1 {
            width: 34px;
            border-radius: 6px;
            cursor: pointer;
        }
        .digits2 {
            width: 40px;
            border-radius: 6px;
            cursor: pointer;
        }
        .digits3{
             width: 50px;
            border-radius: 6px;
            cursor: pointer;       
        }
        #coords {
            position: absolute;
            float: left;
            color: #666600;
        }       
        #cutradius {
            position: absolute;
            float: left;
            color: #666600;
        }
        input[type="number"] {
             azimuth: width: 50px
        }       
        input[type="range"][orient="vertical"] {
            height: 120px;
            writing-mode: bt-lr;
            appearance: slider-vertical;
        }
        table,
        th,
        td {
            border-collapse: collapse;
            padding: 0.3em 0.5em;
        }
        table {
            margin-left: 1em;
        }
        th,
        caption {
            background-color: #444444;
            color: #ffffff;
            border: thin solid #444444;
        }
        td {
            background-image: linear-gradient(#f9f9f9, #e3e3e3);
            border-left: thin solid #444444;
            border-right: thin solid #444444;
        }
        tfoot {
            border-bottom: thin solid #444444;
        }
        td:nth-of-type(1){
            text-align: left;
        }
        td:nth-of-type(2) {
            text-align: center;
        }
        td:nth-of-type(3) {
            text-align: left;
        }
        
    </style>
</head>

<body>
    <dialog id="startDialog"> 
    </br>
    S T A R T 
    </br> </br>
    --- values for a new design ---   
        <p>
        <label>
           scaling&nbsp;
            <select>
            <option value="200">Choose…</option>
            <option>200</option>
            <option>180</option>
            <option>160</option>
            <option>120</option>
            <option>100</option>
            <option>80</option>
            <option>40</option>
            </select>
        </label>
         &nbsp;cm
        </p>
        <p>
        <div> 
           triangle side&nbsp;
            <input id="triangleside" type="number"  min="1" max="100" value="50" step="1" class="digits3">
            %
        </div>
        </p>
        <p>
        <div> 
            initial radius&nbsp;
            <input id="initialMainRadius" type="number"  min="1" max="100" value="50" step="1" class="digits3">
             %
        </div>
        </p>
        <p>
        <div> 
            initial height&nbsp;
            <input id="initialMainHeight" type="number"  min="1" max="100" value="100" step="1" class="digits3">
             %
        </div>
        </p>
        <div>
            <button id="confirmBtn" value="default"> confirm values for a new design </button>&nbsp;&nbsp;&nbsp; or &nbsp;
            <button id="importBtn"> import design ⇈</button>
        </div>
        <p> 
            <input id="withWorker" type="checkbox" /> use worker .....
            <input id="showWireframe" type="checkbox" checked /> show wireframe
        </p>
        <p>  
            <input id="timeout" type="number"  min="10" max="120" value="30" step="5" class="digits3">
            worker timeout in seconds 
        </p>
        <a href="./help-EN.pdf" title="HELP"  target="_blank"> 
            <img src="./textures/EN.png" style="width: 23px; height: 16px" > help
        </a>
        &nbsp;&nbsp;&nbsp;&nbsp;
        <a href="./Hilfe-DE.pdf" title="Hilfe"  target="_blank">
            <img src="./textures/DE.png" style="width: 23px; height: 16px" > Hilfe 
        </a> 
        </br></br>
        <a href="https://github.com/hofk" title="github hofk"  target="_blank">
        <img src="./textures/avatar.png" style="width: 72px; height: 72px" >
        </a> 
        </br>
        <a href="https://etterstudio.com/" title="etterstudio.com" target="_blank">
        <img src="./textures/E.png" style="width: 22px; height: 22px" >
        </a> tterstudio - programmed by hofk
    </dialog>
    
    <div id="edgeInfo" style="display: none; ">  *** &nbsp;&nbsp; double edges &nbsp;&nbsp; ***  </div>
    
    <div class="container">
    
        <div class="comp containerA"> </div>       
        <div class="comp containerB" id="areaB"></div>
        <div class="comp containerC"></div>
        <div class="comp containerD"></div>
        
        <div class="sliderAB" id="areaAB"> </div>
        <div class="sliderC" id="sliderC"> </div>
        
        <div class="partsAleft" >
         
            <button id="undo" style="display: none; "> undo </button>
            <input  id="detailClick"  type="checkbox"  style="display: none; " />
            <span id="txtDetailClick" style="display: none; " > click: </span>     
            <input id="forth" type="radio" name="direction" checked="checked" style="display: none; ">
            <span id="txtForth" style="display: none; " > forth </span>
            <input id="back" type="radio" name="direction" style="display: none; " >
            <span id="txtBack" style="display: none; " >  back  | </span>
            &nbsp;
            <select id ="detailFct" style="display: none; ">
                <option> * </option>
                <option>sqrt</option>
                <option>sin1</option>
                <option>sin2</option>
                <option>sin3</option>
                <option>sin4</option>
                <option>pow2</option>
                <option>pow4</option>
                <option>pow6</option>
                <option>line2</option>    
            </select>
            <span id="txtDtlRadius" style="display: none; " > radius </span> 
            <input id="dtlRadius" type="number"  min="0" max="100" value="1" step="1" class="digits3" style="display: none; ">
            <span id="txtDtlDepth" style="display: none; " > depth </span> 
            <input id="dtlDepth" type="number"  min="0" max="100" value="1" step="1" class="digits3" style="display: none; ">
            <input id="singly"  type="checkbox"  style="display: none; " />
            <span id="txtSingly" style="display: none; " >singly</span> 
            
        </div>
            
        <div class="partsAright" >
        
            <span id="nTriang" > </span>
            &nbsp;&nbsp;&nbsp;&nbsp;
            <button id="finishing" class="btn">finishing</button>
            &nbsp;&nbsp;&nbsp;
            <button id="exportDesign">design ⇊</button>
            <span id="No">No</span>
            <input id="nnnSave" type="text" value="000" class="digits2">
            &nbsp;&nbsp;&nbsp;
            <button id="exportCode">export GLTF ⇊</button>
            &nbsp;
            ID =
            <input id="ID" type="number"  min="0" max="99" value="0" step="1" class="digits2" >
            deci.
            <input id="nDec" type="number"  min="0" max="6" value="3" step="1" class="digits2" >
            to Clipb.
            <input id="toClpb"  type="checkbox" />
            <a id="help" href="./help-EN.pdf" title="help"  target="_blank"  class="help"> </a>
            <a id="Hilfe" href="./Hilfe-DE.pdf" title="Hilfe"  target="_blank"  class="hilfe"> </a>
            
        </div>
        
        <div class="partsB" id="partsB">
            
            <button id="expand" class="btn">expand</button>
            <input id="expansion" type="number"  min="0.05" max="2" value="1" step="0.05" class="digits3" >
            
            <button id="importFigureB" class="btn">figure ⇈</button>
            <button id="exportFigureB" class="btn">figure ⇊</button>
            &nbsp;&nbsp;
            
            main  ≫ &nbsp;r% = <span id="main_r"> </span> &nbsp; h% = <span id="main_h"> </span> &nbsp;
            
            <button id="newApd" class="btnApd">new appendix 1</button> 
            <span id="apdTxt"> main ≫ </span>
            <input id="nApd" type="number"  min="0" max="99" value="0" step="1" class="digits2" >
            
            <button id="btmCapMain" class="btn">bottom ◡</button>
            <button id="topCapMain" class="btn">top ◠</button>
             
            <span id="apdInp"> <!-- appendix -->
                ≫ up%
                <input id="up" type="number"  min="1" max="99" value="" step="1" class="digits3" >
                φ° 
                <input id="φ" type="number"  min="-360" max="360" value="" step="1" class="digits3" >
                r%  
                <input id="r" type="number"  min="5" max="85" value="" step="1" class="digits3" >
                ⇕%  
                <input id="str" type="number"  min="10" max="300" value="" step="1" class="digits3" >
                h% 
                <input id="h" type="number"  min="0" max="100" value="100" step=1" class="digits3" > <!-- min 0 only hole --> 
                
                <button id="btmCapApd">◡</button> 
                <button id="topCapApd">◠</button>  
                
                <button id="applyApd" class="btn"> apply </button>
                <button id="cancelApd" class="btn"> canel </button>
                <button id="deleteApd" style="color: #ff0000" style="font-weight: bold;" >X</button>
            </span>   
        </div>
        
        <div class="partsC" id="partsC">
            <span id="txtoE">o⋅10‾</span>
            <input id="opngE" type="number"  min="0" max="9" value="0" step="1" class="digits1">
            &nbsp;&nbsp;
            <span id="txtAngScale"> </span>
            &nbsp;&nbsp;
            <input  id="capC"  type="checkbox"  /><span id="txtCapC">with cap</span>
            &nbsp;&nbsp;&nbsp;  
            <button id="importCD" class="btn"><span id="txtImport">import</span></button>            
            &nbsp;&nbsp;
            <button id="exportCD" class="btn"><span id="txtExport">export</span></button>
            &nbsp;&nbsp;&nbsp;
            <input  id="directionC"  type="checkbox" checked /><span id="txtDirectionC">radial</span>
            &nbsp;&nbsp;&nbsp;      
            <button id="removeCD" class="btn"><span id="txtRemove">remove/reset</span></button> <!-- reset: btm, top -->
            &nbsp;&nbsp;&nbsp;        
            <button id="cancelCD" class="btn"><span id="txtCancel">cancel</span></button> 
            &nbsp;&nbsp;&nbsp;
            <button  id="saveCD" class="btn"><span id="txtSave">save</span></button >
            &nbsp;&nbsp;
            <span id="txtIdxD"> </span>
        </div>
        
    </div>
    
    <!-- ....... right ....................................... -->
    
    <button id="show_3D" class="show_3D" > show 3D </button>
    
    <input id="useWorker"  class="useWorker" type="checkbox" />
    <span id="txtUseWorker"  class="txtUseWorker" > worker </span>
    
    <input id="useWireframe"  class="useWireframe" type="checkbox" />
    <span id="txtUseWireframe"  class="txtUseWireframe" > wireframe </span> 
    
    <input  id="doubleEdges"  class="doubleEdges" type="checkbox" />
    <span id="txtDoubleEdges"  class="txtDoubleEdges" > double edges </span>  
    
    <div id="cutRadiusArea" class="comp-cutRadius" > 
        <input id="cr" type="range"  min="0" max="100" value="0" step="1" class="cradius"  orient="vertical" >
        </br>cut r = </br><span id="crShow">.%</span> 
    </div>

    <div id="cutCountArea" class="comp-cutCount" > 
        <input id="cn" type="range"  min="3" max="144" value="12" step="1" class="ccount"  orient="vertical" >
        </br>cut/cap n =</br><span id="cnShow">12 marker</span> 
    </div>
    
    <div id="vertBasisArea" class="comp-vertBasis" >
         <input id="dbas" type="range"  min="1" max="100" value="60" step="1" class="vbasis"  orient="vertical" >
        </br>vert basis</br><span id="dbasShow">60%</span>
    </div>    
        
    <div id="vertCountArea" class="comp-vertCount" >    
        <input id="dn" type="range"  min="2" max="17" value="7" step="1" class="vcount"  orient="vertical" >
        </br>vert n =</br><span id="dnShow">7 marker</span> 
    </div>
    
    <div id="output" >
        <p  style="text-align: center;">
             
            <button id="downloadData">download data below</button>&nbsp;&nbsp;&nbsp;
            <button type="button" id="outX" style="color: #ff0000" > X </button> &nbsp;&nbsp;&nbsp;
            <button id="downloadGltf" style="display: none;" >download GLTF mesh wireframe</button> <br/>
            
        </p>
        
        <textarea id="exportLines"  style="width:98%; height:80%;"  > </textarea>
       
    </div>
    
    <div id="keyHelpArea"  class="draggable"> 

        <table>
            <caption>***** press key on mouse click / on movement / always *****  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key help <b>⇗</b> </caption>
            <tbody>
                <tr>
                    <th>area</th>
                    <th>key</th>
                    <th>--------------------------&nbsp;&nbsp;&nbsp; meaning / effect &nbsp;&nbsp;&nbsp;--------------------------</th>
                </tr>
                <tr>
                    <td> </td>
                    <td>␣</td>
                    <td>(spacebar) download design file: nnn-dsgn.txt</td>
                </tr>
                <tr>
                    <td>MAIN</td>
                    <td>m</td>
                    <td> on blue - move </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>i</td>
                    <td> on blue - insert </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>d</td>
                    <td> on blue - delete </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>c</td>
                    <td> on green - open CUT editing for the clicked elevation point </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>s</td>
                    <td> on green - load file with cross-section shape, file selection </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>r</td>
                    <td> on green - remove cross section</td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>v</td>
                    <td> left system: open VERTical editing on the circumference</td>
                </tr>
                <tr>
                    <td>CUT</td>
                    <td>m</td>
                    <td> on blue - move </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>s</td>
                    <td> on blue - scale cross-section shape</td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>v</td>
                    <td> on green - open VERTical editing </td>
                </tr>               
                
                <tr>
                    <td>VERT</td>
                    <td>n</td>
                    <td> on blue left - change in base height </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>m</td>
                    <td> on blue right - move the individual heights </td>
                </tr>
                <tr>
                    <td>CAP</td>
                    <td>m</td>
                    <td> on blue - move edge height</td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>t</td>
                    <td> on red - translate position of the center, any</td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>o</td>
                    <td> on green - upper opening of the cap, horizontal </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>h</td>
                    <td> on magenta - change of cap height, vertical</td>
                </tr>
                <tr>
                    <td>FIN 3D</td>
                    <td>f</td>
                    <td> forth - take if not click box checked </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>b</td>
                    <td> back - take if not click box checked </td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>p</td>
                    <td> set a point for the curve </td>
                </tr>
                <tr>
                    <td>&nbsp;&nbsp; without click:</td>
                    <td>r</td>
                    <td> remove last curve point </td>
                </tr                
                
                <tr>
                    <td>&nbsp;&nbsp; without click:</td>
                    <td>e</td>
                    <td> end of curve formation </td>
                </tr
            </tbody>
            <tfoot>
                <tr>
                </tr>
            </tfoot>
        </table> 
    </div>
  
    <div id="coords">
    </div>
    <div id="cutradius">
    </div>
    
    <div id="triangulationRunning" class="triangul" style="display: none;" >
        <div class="canvas">
            <div class="triangle left rotate1" id="p1"></div>
            <div class="triangle right" id="p2"></div>
            <div class="triangle left" id="p3"></div>
            <div class="triangle right" id="p4"></div>
        </div> 
        <span class="worker" >
            <p> WAIT - triangulation is still running in the worker </p>
            <p> ............................................................... </p>
            <p> positioning and bending </p>     
        </span>
    </div>
    
    <div id="deleteMarkedAppendix" style="display: none;" >
    
        <p> ? ... delete marked appendix ... ?</p>
        <p>
        <button id="yesDelete"  style="color: #ff0000"> yes - delete now </button>&nbsp;&nbsp;
        <button id="noDelete" style="color: #008822"> no - keep it  </button>
        </p>       
    </div>
    
    <div id="askFinishing" class="fin" style="display: none;" > 
        <br/> <br/> <br/> <br/>
        <p> ? ...  Would you like to start the finishing process ... ?
            <br/> <br/> <br/> <br/>
            WARNING!
            <br/> <br/> <br/> <br/>
            After that, it is only possible to export the finished geometry.
            <br/> <br/> 
            Have you checked the status of the 'double edges' checkbox?
            <br/> <br/> 
            Except for the final edit, no other editing is possible.
            <br/>  
            The finishing steps cannot be saved in the design, but all finishing steps can be undone.
            <br/> <br/>  
        </p> 
        <button id="yesFinishing" style="color: #ff0000">yes - start finishing now </button>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button id="noEditing" style="color: #008822"> no - back to general editing </button>
        
    </div>
    
    <input type="file" id="btmTopShapeHeightFileLoad" style="display: none;">
    
    <input type="file" id="shapeFileLoad" style="display: none;">
    <input type="file" id="heightFileLoad" style="display: none;">
    
    <input type="file" id="figureFileLoad" style="display: none;">
    <input type="file" id="fullDesignFileLoad" style="display: none;">
    
</body>
 
<script type="module">

// @author hofk

import {
    
    Scene,
    PerspectiveCamera,
    OrthographicCamera,
    WebGLRenderer,
    
    GridHelper,
    AxesHelper,
    ArrowHelper,
    
    AmbientLight,
    DirectionalLight,
    
    Raycaster,
    DoubleSide,
    TextureLoader,
    
    BufferGeometry,
    BufferAttribute,
    DynamicDrawUsage,
    
    OctahedronGeometry,
    
    Mesh,
    Line,
    LineSegments,
    LineLoop,
    Sprite,
    
    MeshBasicMaterial,
    LineBasicMaterial,
    SpriteMaterial,
    Color,
    
    Vector2,
    Vector3,
    Matrix4,
    Quaternion,
    CatmullRomCurve3
    
} from '../jsm/three.module.172.js'; // uses  import, export from '../jsm/three.core.172.js'

import { OrbitControls } from '../jsm/OrbitControls.172.js';
import { GLTFExporter } from '../jsm/GLTFExporter.172.js';
import { vertexFaceNumbersHelper } from '../jsm/THREEn.172.js';

// .... Quaternion extension ...............................................
    
Quaternion.prototype.setFromBasis = function( e1, e2, e3 ) {
    
    const   m11 = e1.x, m12 = e1.y, m13 = e1.z,
            m21 = e2.x, m22 = e2.y, m23 = e2.z,
            m31 = e3.x, m32 = e3.y, m33 = e3.z,
            trace = m11 + m22 + m33;

    if ( trace > 0 ) {

        const s = 0.5 / sqrt( trace + 1.0 );

        this._w = 0.25 / s;
        this._x = -( m32 - m23 ) * s;
        this._y = -( m13 - m31 ) * s;
        this._z = -( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

        const s = 2.0 * sqrt( 1.0 + m11 - m22 - m33 );

        this._w = ( m32 - m23 ) / s;
        this._x = -0.25 * s;
        this._y = -( m12 + m21 ) / s;
        this._z = -( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

        const s = 2.0 * sqrt( 1.0 + m22 - m11 - m33 );

        this._w = ( m13 - m31 ) / s;
        this._x = -( m12 + m21 ) / s;
        this._y = -0.25 * s;
        this._z = -( m23 + m32 ) / s;

    } else {

        const s = 2.0 * sqrt( 1.0 + m33 - m11 - m22 );

        this._w = ( m21 - m12 ) / s;
        this._x = -( m13 + m31 ) / s;
        this._y = -( m23 + m32 ) / s;
        this._z = -0.25 * s;

    }
    
    this._onChangeCallback();

    return this;
 
}

const exporter = new GLTFExporter( );
 
// ... global basic constants ...

// nCurvePtsB: number of spaced curve points and sprites scene B left, should be odd (.. -1 divisions) 
const nCurvePtsB = 41; 
// number of spaced curve points scene C, must be divisible by 4 (connected => points and divisions)
const nCurvePtsC = 180;

const cnDefault = 12;   // default number of sprites (markers) scene C, see <input id="cn" value="12"
const cnmax = 144;      // max number of sprites(markers) scene C, see <input id="cn" max="144"

const dnDefault = 7;    // default number of sprites (markers) scene D, see <input id="dn" ...
const dnmax = 31;       // max number of sprites (markers) scene D,

const dbasDefault = 60; // default of relative height of basis line D  see <input id="dbas" ... 
const xD = 0.08;        // x position marker D ( -xD and xD used )

const markerSize = 0.0125;

const maxPointsLines = 40;

let scale = '200'; // default

// ... some simple functions ...

const pi = Math.PI;
const p2i = pi / 2;
const rad = x => x * pi / 180;
const sin = x => Math.sin( x );
const asin = x => Math.asin( x );
const cos = x => Math.cos( x );
const atan2 = ( y, x ) => Math.atan2( y, x );
const atan2Pi = ( x, y ) => atan2( y, x ) < 0 ? atan2( y, x ) + pi * 2 : atan2( y, x );
const sqrt = x => Math.sqrt( x );
const round = x => Math.round( x );
const n4 = ( r, s ) => round( pi * r / s / 2 );

const delay = sec => { return new Promise( resolve => setTimeout ( resolve, sec * 1000 ) ) };

// ... main data, set in modal scale dialog ...

let triangleSide;
const main_r = document.getElementById( 'main_r' );
const main_h = document.getElementById( 'main_h' );
main_r.style.color = '#de0000';
main_h.style.color = '#de0000';    
main_r.style.fontWeight = 'bold';
main_h.style.fontWeight = 'bold';

// ..... UI .....

let wire3D;

const useWirefr = document.getElementById( 'useWireframe' ); 
useWirefr.onchange = ( ) => { wire3D = useWireframe.checked };

const show3DBtn = document.getElementById( 'show_3D' );
const show3D = ( ) => { wire3D = useWireframe.checked ? true : false; show3DSceneA( ); }

show3DBtn.onpointerup = show3D;

const cr = document.getElementById( 'cr' ); 
const crShow = document.getElementById( 'crShow' );
cr.onchange = oncrChange;

const cn = document.getElementById( 'cn' ); 
const cnShow = document.getElementById( 'cnShow' );
cn.onchange = oncnChange;

const dn = document.getElementById( 'dn' ); 
const dnShow = document.getElementById( 'dnShow' );
dn.onchange = ondnChange;

const dbas = document.getElementById( 'dbas' );
const dbasShow = document.getElementById( 'dbasShow' );
dbas.onchange = ondbasChange;

// ---  make key help DIV draggable ---

const drag_class = "draggable";
const pointer_event = ("PointerEvent" in window);

if( pointer_event ) {
    
    document.body.addEventListener( "pointerdown", handle_down, false );
    document.body.addEventListener( "pointermove", handle_move, false );
    document.body.addEventListener( "pointerup", handle_up, false );
    
}

let pointerPosDown; 
let posStart;       
let dragele = null; // drag element, see  // --- drag functions ---

//--- modal start dialog ---- 
{ 
    const startDialog = document.getElementById( 'startDialog' );
    const confirmBtn = startDialog.querySelector( '#confirmBtn' );
    const importBtn = startDialog.querySelector( '#importBtn' );
    const fullDesignFileLoad = document.getElementById( "fullDesignFileLoad" );
    const selectEl = startDialog.querySelector( "select" );
    
    startDialog.showModal( );

    selectEl.addEventListener( "change", ( ) => { 
       
       scale = selectEl.value;
       
    } );
   
    confirmBtn.addEventListener("pointerdown", ( ) => {
    
        startDialog.close( );
        getSize( );
        makeNewDesign( );
        
    } );
    
    importBtn.addEventListener("pointerdown", ( ) => {
        
        fullDesignFileLoad.click( );
        
    });
    
    fullDesignFileLoad.addEventListener("change", ( ) => {
        
        startDialog.close( ); 
        importDesign( );
        
    } );    

}// -----------------------

// ... container A, B, C, D and sliderAB ...

const containerA = document.querySelector( '.containerA' );
const containerB = document.querySelector( '.containerB' );
const sliderAB = document.querySelector( '.sliderAB' );
const containerC = document.querySelector( '.containerC' );
const containerD = document.querySelector( '.containerD' );
                                        
containerA.style.cursor = 'move';
containerB.style.cursor = 'none';
containerC.style.cursor = 'none';
containerD.style.cursor = 'none';

const partsB = document.querySelector( '.partsB' );
const partsC = document.querySelector( '.partsC' );

containerA.addEventListener('pointerdown', onContainerApointerDown );

containerB.addEventListener('pointerleave', onContainerBpointerLeave );
containerB.addEventListener('pointerdown', onContainerBpointerDown );
containerB.addEventListener('pointermove', onContainerBpointerMove );
containerB.addEventListener('pointerup', onContainerBpointerUp );

btmCapMain.addEventListener('pointerup', onBtm );
topCapMain.addEventListener('pointerup', onTop ); 
btmCapApd.addEventListener('pointerup', onBtm );
topCapApd.addEventListener('pointerup', onTop );

document.getElementById( 'expand' ).addEventListener('pointerup', expandForm );

const singly = document.getElementById( 'singly' );
const detailClick = document.getElementById( 'detailClick' );
undo.addEventListener('pointerup', onUndoPointerUp );

const sliderC = document.getElementById( 'sliderC' );
const directionC = document.getElementById( 'directionC' );
const exportCD = document.getElementById( 'exportCD' );
const removeCD = document.getElementById( 'removeCD' );
const cancelCD = document.getElementById( 'cancelCD' );
const saveCD = document.getElementById( 'saveCD' );

exportCD.addEventListener('pointerup', onExportCDpointerUp );
removeCD.addEventListener('pointerup', onRemoveCDpointerUp );
cancelCD.addEventListener('pointerup', onCancelCDpointerUp );
saveCD.addEventListener('pointerup', onSaveCDpointerUp );

containerC.addEventListener('pointerleave', onContainerCpointerLeave );
containerC.addEventListener('pointerdown', onContainerCpointerDown );
containerC.addEventListener('pointermove', onContainerCpointerMove );
containerC.addEventListener('pointerup', onContainerCpointerUp );

containerD.addEventListener('pointerleave', onContainerDpointerLeave );
containerD.addEventListener('pointerdown', onContainerDpointerDown );
containerD.addEventListener('pointermove', onContainerDpointerMove );
containerD.addEventListener('pointerup', onContainerDpointerUp );

// ..... import export .....

document.getElementById( 'exportDesign' ).onpointerup = exportFullDesign;
document.getElementById("exportCode").onpointerup = exportJavaScript;
document.getElementById( "outX" ).onpointerup = hideOutput;

document.getElementById( 'importCD' ).addEventListener('pointerdown', ( ) => {
    document.getElementById( 'btmTopShapeHeightFileLoad' ).click();
});
document.getElementById('btmTopShapeHeightFileLoad').addEventListener('change', ( ) => {
    onImportCDpointerdownChange( );
});

const openShapeFileLoadWindow = async( ) => { await delay( 0.33 ); shapeFileLoad.click( ) }
shapeFileLoad.addEventListener( 'change', key_s_loadShape );
 
document.getElementById( 'importFigureB' ).addEventListener('pointerdown', ( ) => {
    document.getElementById( 'figureFileLoad' ).click();
});
document.getElementById('figureFileLoad').addEventListener('change', ( ) => {     
    importFigureBdata( );
});

document.getElementById( 'exportFigureB' ).onpointerup = exportFigureBdata;

const output = document.getElementById( "output" );
const exportLines = document.getElementById( "exportLines" );

document.getElementById( 'downloadData' ).onpointerup = ( ) => saveString( exportLines.value, 'data.txt' );
document.getElementById( 'downloadGltf' ).onpointerup = downloadMeshGltf;
 
const linkElem = document.createElement( 'a' );
linkElem.style.display = 'none';
document.body.appendChild( linkElem ); // Firefox workaround 
 
// ..... appendices .....

document.getElementById( 'newApd' ).onpointerup = newAppendix;
document.getElementById( 'nApd' ).onchange = useAppendix;
document.getElementById( 'applyApd' ).onpointerup = applyAppendix;
document.getElementById( 'cancelApd' ).onpointerup = cancelAppendix;
document.getElementById( 'deleteApd' ).onpointerup = deleteAppendix;

const deleteMarkedAppendix = document.getElementById( 'deleteMarkedAppendix' );
document.getElementById( 'yesDelete' ).onpointerup = yesDeleteAppendix;
document.getElementById( 'noDelete' ).onpointerup = noKeepAppendix;

const nApd = document.getElementById( 'nApd' );

const up = document.getElementById( 'up' );
const φ = document.getElementById( 'φ' );
const r = document.getElementById( 'r' );
const str = document.getElementById( 'str' );
const h = document.getElementById( 'h' );

const showNone = ( ) => { show_3D.style.display = 'none'; };

document.getElementById( 'up' ).onchange = showNone;
document.getElementById( 'φ' ).onchange = showNone;
document.getElementById( 'str' ).onchange = showNone;

document.getElementById( 'r' ).onchange = useRadius;
document.getElementById( 'h' ).onchange = useHeight;


window.addEventListener('keydown', onWindowKeyDown );
window.addEventListener('keyup', onWindowKeyUp );

// ............... finishing ... detail .....................
const askFinishing = document.getElementById( 'askFinishing' );
document.getElementById( 'finishing' ).onpointerup = ( ) => {
    askFinishing.style.display = 'block'; 
    }; // ready3D = false; 
document.getElementById( 'noEditing' ).onpointerup = ( ) => {
    askFinishing.style.display = 'none'; ready3D = true; }; // general editing 
document.getElementById( 'yesFinishing' ).onpointerup = finishGeometry;

const dtl = {}; // detailFct parameter 
dtl.radius = 1;
dtl.depth = 1;

const dtlStp = []; // detail steps
let finish = false; //  geometry finishing
let fnsPts = []; // finishing points
let tubeReady = false; //  if key e pressed: true 

let centerCurve, centerLen, cPcount, centerPoints, stp, distance2, tubeGeo, tube;

const selectDetailFct = document.querySelector( "#detailFct" );

const dtlRadius = document.getElementById( 'dtlRadius' )
dtlRadius.onchange = ( ) => dtl.radius = dtlRadius.value;
const dtlDepth = document.getElementById( 'dtlDepth' )
dtlDepth.onchange = ( ) => dtl.depth = dtlDepth.value;

// ............... resize ...................

window.addEventListener( "resize", ( ) => {

    cameraA.aspect = innerWidth / innerHeight;
    cameraA.updateProjectionMatrix( );
    rendererA.setSize(innerWidth, innerHeight );  
    
} );

// ............ materials ....................

const material3Dwire = new MeshBasicMaterial( { side: DoubleSide, color: 0x056612, transparent: true, opacity: 0.8, wireframe: true } );

const materialDelete3D = new MeshBasicMaterial( { side: DoubleSide, color: 0xee0000, transparent: true, opacity: 0.6, wireframe: false } );

const materialConDelete3D = new MeshBasicMaterial( { side: DoubleSide, color: 0xaa0000, transparent: true, opacity: 0.6, wireframe: false } );

// two colors material
const tex = new TextureLoader( ).load( "./textures/green.png" );
const texBack = new TextureLoader( ).load( "./textures/yellow.png" );

const material2Colors = new MeshBasicMaterial( { map: tex, side: DoubleSide } );
const planeUniforms = { backTexture: { value: texBack } };

// https://discourse.threejs.org/t/how-to-have-different-colors-textures-on-bottom-and-top-side-of-a-plane/12644/13

material2Colors.onBeforeCompile = shader => {
    shader.uniforms.backTexture = planeUniforms.backTexture;
    shader.vertexShader =
        `
    attribute vec2 backUV;
    varying vec2 vBackUV;
    ` + shader.vertexShader;
    shader.vertexShader = shader.vertexShader.replace(
        `#include <fog_vertex>`,
        `#include <fog_vertex>
    vBackUV = backUV;
    `
    );
    shader.fragmentShader =
        `
    uniform sampler2D backTexture;
    varying vec2 vBackUV;
    ` + shader.fragmentShader;
    shader.fragmentShader = shader.fragmentShader.replace(
        `#include <map_fragment>`,
        `
    #ifdef USE_MAP
        
        vec4 sampledDiffuseColor = gl_FrontFacing ? texture2D( map, vMapUv ) : texture2D( backTexture, vBackUV );
        
        #ifdef DECODE_VIDEO_TEXTURE
        
            // use inline sRGB decode until browsers properly support SRGB8_APLHA8 with video textures
        
            sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
            
            #endif
        
            diffuseColor *= sampledDiffuseColor; 
        
    #endif
    `
    );
};

const matLine = new LineBasicMaterial( { color: 0x0033bb } ); 
const matCurve = new LineBasicMaterial( { color: 0x009900 } );

const matSpriteGreen = new SpriteMaterial( { color: 0x00aa00, transparent: true, opacity: 0.5  } );
const matSpriteBlue = new SpriteMaterial( { color: 0x0000aa, transparent: true, opacity: 0.5 } );
const matSpriteMagenta = new SpriteMaterial( { color: 0xaa00aa, transparent: true, opacity: 0.95 } );
const matSpriteRed = new SpriteMaterial( { color: 0xff0000, transparent: true, opacity: 0.8 } );

const matTube = new MeshBasicMaterial( { side: DoubleSide, color: 0x22ff22, transparent: true, opacity: 0.3  } );

// ... global constants, variables and arrays ...

const reader = new FileReader( ); // for shape, heights, figure

let widthB, heightB, aspectB, leftC, topC, widthC, heightC, aspectC, leftD, topD, widthD, heightD, aspectD;
let reticleX, reticleY, gReticle, reticleBh, reticleBm, reticleCm, reticleDm, gBasisD, sizeFactor, exportFactor;
let pointsC, idxC, αC,cutIdx, vertIdx, idxD, rDown, rUp, dirCheck;
let detail, div, div4, hsCap, capHoleBtm, capHoleTop;
let timeOut;
 
let holeCurvePoint = [];
let curvePoints = [];
let curveA_0, curveA;
let x, y, z;
let main, appendix, mainPosArr, posArr, iHeight;

let designBackupNumber;     // ++ .. after spacebar

let crValue;                // cut radius value,  see <input id="cr" ...
let cnValue = cnDefault;    // cut, cap(btm, top) number of markers, see <input id="cn" ...

// to renew first settings
let ccfb;                   // cut coordinates first bottom,   true => false
let ccft;                   // cut coordinates first top,   true => false
let vcf0;                   // vertical coordinates first vertIdx 0,   true => false
let vcf1;                   // vertical coordinates first vertIdx nCurvePtsC / 2,   true => false

let dnValue = dnDefault;        // number of vertical markers, D  see <input id="dn" ...
let dbasValue = dbasDefault;    // relative height of basis line D  see <input id="dbas" ...
let onlyVert = false;           // vertical processing only

let gLineL, lineL, gCurveL, curveL, gLineR, lineR, gCurveR, curveR, gCurveC, curveLoopC, curveC, gLinesD,linesD;

let dispX, dispY;       // display values

let deleteIdx, meshDelete, meshConDelete;

let apdIdx;             // current appendix index,  0 is main, appendices from 1
let apdApplied = false; // true if the appendix was applied
let r_, h_;             // appendix radius, height to memorize

let pointer = new Vector2( );     // sceneA 2D
let retPos = new Vector2( );      // 2D
let markerPos = new Vector2( );   // 2D

const v  = new Vector3( ); 
const va = new Vector3( ); 
const vb = new Vector3( );
const vd = new Vector3( );

const vMain = new Vector3( );
const vCon  = new Vector3( );

let vCenter  = new Vector3( ); // curve center point
let tangent  = new Vector3( ); 
let normal   = new Vector3( );
let binormal = new Vector3( );

let vCenterBtm   = new Vector3( ); // curve center point bottom
let tangentBtm   = new Vector3( );
let normalBtm    = new Vector3( ); 
let binormalBtm  = new Vector3( );

let vCenterTop  = new Vector3( ); // curve center point top
let tangentTop  = new Vector3( );
let normalTop   = new Vector3( );
let binormalTop = new Vector3( );

const yAxis = new Vector3( 0, 1, 0 );
const quaternion = new Quaternion( );

const hp1 = new Vector3( );  // hole points left right
const hp2 = new Vector3( );  
const hpc = new Vector3( );  // hole center point
const vdir = new Vector3( ); // also as bottom tangent for geo[ i ]

const pc = new Vector3( );  // center of geo[ i ] bottom
const vb1 = new Vector3( ); // for rotation of geo[ i ]
const vb2 = new Vector3( ); // for rotation of geo[ i ]
 
const vbound = new Vector3( );   // boundary points for caps
const vcb = new Vector3( );      // caps calculation
const vradial  = new Vector3( ); // caps calculation
const vpos = new Vector3( );     // caps position

let d2; //distance to squared
let d2Min;
let phiMin;

let vPosC = [];

for ( let j = 0; j < cnmax; j ++ ) {
    
    vPosC.push( new Vector3( ) ); // positions of cut sprites, for curve
    
}

const param = [];           // parameters: array of objects for cylinders ( index 0 with holes )

let gc = [];                // webworker calculated values for geometries,  main and appendices
let geo = [];               // geometries,  main and appendices
let geoCon = [];            // custom  basic geometry to connect main and appendix
let geoTop = [];            // custom  basic geometry for top caps main and appendix
let geoBtm;                 // custom  basic geometry for bottom cap main

let geoType = [];           // sequence of geometry types for functions link and unite 

let capDataBtm = [];        // withBtmCap, capCenterBtm: x, y, z,  capOpeningBtm, openingExpBtm
capDataBtm.push( [ 0, 0, 0, 0, 0, 0 ] );    // only  main ( for appendix as dummy ) 
let capDataTop = [];        // withTopCap, capCenterTop: x, y, z,  capOpeningTop, openingExpTop
capDataTop.push( [ 0, 0, 0, 0, 0, 0 ] );    // for main 

let geoms = [];         // geometries to link, to unite
let geometry;           // linked geometries main and appendices ( + connections,  caps )
let finalMeshWire;      // see show3DSceneA( ), link( geoms ), unite( geoms ), wireframe
let finalMesh;          // see show3DSceneA( ), link( geoms ), unite( geoms ), 2 colors

let apdCount = 0;       // appendix count
let onlyHole = [];      // appendices with height 0 

const gLineA = [];      // for main and appendices 
const lineA = [];       // only lineA[ 0 ] ( main ) is displayed
const nDraw = [];       // number of line markers equals draw range lineA 

let ptsLineA = [];
let curvePointsA;
let romCurve;

let markerCountL;
let markerCountR;

let markerBL = [];       // array of line markers left 
let markerBR = [];       // array of line markers right

let markerC = [];        // array of markers C
let marker0Cx = [];      // markers start .x  - for scaling
let marker0Cy = [];      // markers start .y  - for scaling

let markerD = [];
let markerD0 =  [];     // basis  bottom and top, left side
let ptsLineC = [];

let translateMarker;     // caps
let heightMarker;        // caps
let openingMarker;       // caps

let cutMarkerL = []; 
let cutMarkerLenabled = []; // array of arrays memorize sprite Index ( sceneB  L, to apdIdx for cut )
let isShape = [];           // array of arrays to memorize if the cut is a shape

let vertMarkerC = [];
let vertMarkerCenabled = []; // array of arrays memorize sprite Index ( sceneC to apdIdx for vertical editing )

let cutCoords = [];
let cutCoordsBak;

let vertCoords = [];    // array of arrays of arrays of vertical values ( appendix, curve points, some values )
let vertCoordsBak;
let vertBasis = [];     // array of arrays of basis value ( appendix, curve points, one value )

let btmCoords = [];
let btmCoordsBak;
let btmDiff = [];
let btmIsPlane = [];

let topCoords = [];
let topCoordsBak;
let topDiff = [];
let topIsPlane = [];

let xArr = []; // x coordinate arrays
let yArr = []; // y(height) arrays
let zArr = []; // z coordinate arrays

// move and hit indices left and right
let idxMoveL;
let idxMoveR;
let idxHitL;
let idxHitR;

let idx3HitL; // idxHitL / 3
let idx3HitR; // idxHitR / 3

let key = '';
let pos = [];

let out = '';
let onImportDesign = false;
 
// ... scenes ...

const sceneA = new Scene( );
sceneA.background = new Color( 0xdedede );

const sceneB = new Scene( );
sceneB.background = new Color( 0xeeeeee );

const sceneC = new Scene( );
sceneC.background = new Color( 0xf6f6f6 );

const sceneD = new Scene( );
sceneD.background = new Color( 0xf6f6f6 );

const gridHelper = new GridHelper( 2, 2 );
sceneA.add( gridHelper );

const axesHelper = new AxesHelper( 2.0 );
sceneA.add( axesHelper );

// ... cameras ...
const cameraA = new PerspectiveCamera( 55, containerA.clientWidth / containerA.clientHeight, 0.001, 10000 ); 
cameraA.position.set( 0.5, 2.5, 3.5 );

widthB = 0.95 * containerB.clientWidth;
heightB = 0.95 * containerB.clientHeight;
if ( widthB > 2 * heightB ) { widthB = 2 * heightB; } else { heightB = widthB / 2; }
aspectB = widthB / heightB;
const cameraB = new OrthographicCamera( -aspectB, aspectB, 1, -1, 0.01, 0.2 );
cameraB.position.set( 0, 0, 0.1 );

leftC = widthB / 4 + 10; // +10 to right
topC = 0;
widthC = heightB;
heightC = heightB;
aspectC = widthC / heightC;
const cameraC = new OrthographicCamera( -aspectC, aspectC, 1, -1, 0.01, 0.2 );
cameraC.position.set( 0, 0, 0.1 );

leftD = leftC + widthC + 30;
topD = 0;
widthD = widthC / 10;
heightD = heightC;
aspectD = widthD / heightD;
const cameraD = new OrthographicCamera( -aspectD, aspectD, 1, -1, 0.01, 0.2 );
cameraD.position.set( 0, 0, 0.1 );

// ... controls and lights A ...

const controlsA = new OrbitControls( cameraA, containerA );

const lightA0 = new AmbientLight( 0xffffff, 0.5 );
sceneA.add( lightA0 );
const lightA1 = new DirectionalLight( );
lightA1.position.set(  2, 10, 5 );
sceneA.add( lightA1 );
const lightA2 = new DirectionalLight( );
lightA2.position.set(  -2, 8, -4 );
sceneA.add( lightA2 );

// ... raycaster ...

const raycaster = new Raycaster( );
let intersects = [];

// ... renderers ...

const rendererA = new WebGLRenderer( { antialias: true } );
rendererA.setSize( containerA.clientWidth, containerA.clientHeight );
rendererA.setPixelRatio( window.devicePixelRatio ); 
containerA.appendChild( rendererA.domElement );

const rendererB = new WebGLRenderer( { antialias: true } );
rendererB.setSize( widthB, heightB );
rendererB.setPixelRatio( window.devicePixelRatio );
containerB.appendChild( rendererB.domElement );

const rendererC = new WebGLRenderer( { antialias: true } );
rendererC.setSize( widthC, heightC );
rendererC.setPixelRatio( window.devicePixelRatio ); 
containerC.appendChild( rendererC.domElement );

const rendererD = new WebGLRenderer( { antialias: true } );
rendererD.setSize( widthD, heightD );
rendererD.setPixelRatio( window.devicePixelRatio ); 
containerD.appendChild( rendererD.domElement );

// ... Firefox: reset after F5  ...
withWorker.checked = false;
useWorker.checked = false;
showWireframe.checked = true;
useWireframe.checked = true;
doubleEdges.checked = false;
expansion.value = 1;
cn.value = cnDefault;
dn.value = dnDefault;
dbas.value = dbasDefault;
nnnSave.value = '000';
ID.value = 0;      
nDec.value = 3;

// ... settings ...

apdInp.style.visibility = 'hidden';
let btmEditing = false;
let topEditing = false;
let cutEditing = false;
let vertEditing = false;
let moveTranslate = false;
let moveHeight = false;
let moveOpening = false;

let ready3D = true;
let firstDsgnSave = true;
let shapeScaled = false;

btmTopCapDisplay( 0 ); //  display btm top button main

// ... creations ...
createDesignAreaB( );
createDesignAreaC( );
createDesignAreaD( );
createLinesCurvesLR( );
createCutMarkersL( );
createCurveC( );
createMarkersC( );
createVerticalMarkersC( );
createCapCenterMarkersC( );
createMarkersD( );
createBasisLineD( );
createLinesD( );
createReticles( );
// ..................

visibilityC( "hidden" );
visibilityD( "hidden" ); 

initComparisons( );

param[ 0 ] = {
    
  holes: [ ]  // initial empty, append various cylinders to holes
        // [ up %, φ °, radius %, stretchHoleY %, height   ] // NOTE!  radius < radius main  

};   
           
// finishing point
 const p1Mesh = new Mesh( new OctahedronGeometry( 0.01 , 2 ), materialDelete3D ); 

animate( );

// -------- functions -----------------------------------------------------------
 
function makeNewDesign( ) {
    
    getTriangleSide( );
    displayMainRadiusHeight( );
    
    markerCountL = -1;
    markerCountR = -1;
    
    idxMoveL = -1;
    idxMoveR = -1;       
    idxHitL = -1;       
    idxHitR = -1;
    
    apdIdx = 0;
    
    // ... to global apdIdx  0 main ...
    
    createLineAgeometry( );
    createLineAmain( );
    initializeLinesLRA( );
    updateCurvesLR( );
    
    initializeCutMarkersL( );
    initializeVerticalMarkersC( );
    
    initializeBtmTopDiff( );
    
    btmIsPlane.push( true ); 
    topIsPlane.push( true );
    
    btmCoords.push( [] );
    topCoords.push( [] );
    
    initializeBtmTopCoords( );
    
    initializeCutCoords( );
    initializeVertCoords( );

    initializePositionArrays( );
    renewFirstSettings( );
    
    setCutRadius( initialMainRadius.value );
    
    show3D( );
    
    help.innerHTML = "help";
    Hilfe.innerHTML = "Hilfe";
    
}

function show3DSceneA( ) {
    
    if ( ready3D ) {
        
        ready3D = false;
        
        containerB.style.width = widthB + 'px';
        sliderAB.style.left = ( widthB - 15 ) + "px";
        partsB.style.left = ( widthB - 1360 ) + "px";
        
        containerB.style.height = 40 + "px";
        sliderAB.style.top = 25 + "px";
        partsB.style.top = 43 + "px";
        
        coords.style.left = 0 + "px";
        coords.style.top =  0 + "px";
    
        coords.innerHTML = '';
        reticleBm.visible = false;
        
        if ( finalMeshWire ) {
            
            sceneA.remove( finalMeshWire );
            geometry.dispose( );
            
            if ( geo[ 0 ] ) geo[ 0 ].dispose( ); // main
            if ( geoTop[ 0 ] ) geoTop[ 0 ].dispose( ); // main top
            if ( geoBtm ) geoBtm.dispose( ); // main bottom
            
            for ( let i = 1; i <= apdCount; i ++ ) { // appendices
                
                if( geo[ i ] ) geo[ i ].dispose( );        // main: index 0, appendices: index 1 ...
                if( geoCon[ i ] ) geoCon[ i ].dispose( );  // dummy index 0, appendices: index 1 ...
                if( geoTop[ i ] ) geoTop[ i ].dispose( );  // dummy index 0, appendices: index 1 ...
                
            }
            
        }
        
        if ( finalMesh ) {
        
            sceneA.remove( finalMesh );
            geometry.dispose( );
    
            if ( geo[ 0 ] ) geo[ 0 ].dispose( ); // main
            if ( geoTop[ 0 ] ) geoTop[ 0 ].dispose( ); // main top
            if ( geoBtm ) geoBtm.dispose( ); // main bottom
        
            for ( let i = 1; i <= apdCount; i ++ ) { // appendices
                
                if( geo[ i ] ) geo[ i ].dispose( );        // main: index 0, appendices: index 1 ...
                if( geoCon[ i ] ) geoCon[ i ].dispose( );  // dummy index 0, appendices: index 1 ...
                if( geoTop[ i ] ) geoTop[ i ].dispose( );  // dummy index 0, appendices: index 1 ...
                
            }
            
        }
        
        gc = [];        // reset, main: index 0, appendices: index 1 ...
        geo = [];       // reset, main: index 0, appendices: index 1 ...
        geoCon = [];    // reset, index 0 dummy, appendices: index 1 ... 
        geoBtm = null;  // reset, bottom only main
        geoTop = [];    // reset
        geoType = [];   // reset
        geoms = [];     // reset
    
        holeCurvePoint = []; // reset
        curvePoints = [];    // reset
        
        updatePositionArrays( );
        
        //   ......  main with holes index i: 0, ...  appendices i: 1..   ...................................
        
        if( withWorker.checked || useWorker.checked ) {
            
            if ( withWorker.checked ) {
            
                withWorker.checked = false; // only start dialog
                useWorker.checked = true;
                
            }
            
            triangulationRunning.style.display = 'block';
            
            for ( let i = 0; i <= apdCount; i ++ ) { //  parameter: main 0,  appendices 1 ...    
                
                main = i === 0 ? true : false;
                appendix = i !== 0 ? true : false;
                
                setParam( i );
                
            }
            
            const worker = new Worker('worker.js');
            
            timeOut = timeout.value * 1000;  // worker
            
            console.log( 'worker timeOut =',timeOut, 'ms' );
            
            const timeoutId = setTimeout( ( ) => 
                            { console.error("timeout - worker terminated");
                            triangulationRunning.style.display = 'none';
                            worker.terminate( );
                            }, timeOut );
                                            
            worker.postMessage( param );
            
            worker.onmessage = function( e ) {
                
                gc = e.data;
                
                worker.terminate( );
                
                for ( let i = 0; i <= apdCount; i ++ ) { // buildt cylinder,
                    
                    geo[ i ] = new BufferGeometry( );
                    
                    geo[ i ].type           = gc[ i ].type;
                    geo[ i ].d              = gc[ i ].d;
                    geo[ i ].btmDiff        = gc[ i ].btmDiff;
                    geo[ i ].topDiff        = gc[ i ].topDiff;
                    geo[ i ].div4           = gc[ i ].div4;
                    geo[ i ].height         = gc[ i ].height;
                    geo[ i ].btm            = gc[ i ].btm;
                    geo[ i ].radiusBottom   = gc[ i ].radiusBottom;
                    geo[ i ].div4Btm        = gc[ i ].div4Btm;
                    geo[ i ].phiBtm         = gc[ i ].phiBtm;    // not used
                    geo[ i ].top            = gc[ i ].top;
                    geo[ i ].radiusTop      = gc[ i ].radiusTop;
                    geo[ i ].div4Top        = gc[ i ].div4Top;
                    geo[ i ].phiTop         = gc[ i ].phiTop;    // not used
                    geo[ i ].holes          = gc[ i ].holes;
                    geo[ i ].detail         = gc[ i ].detail;
                    geo[ i ].radius         = gc[ i ].radius;
                    geo[ i ].adjTop         = gc[ i ].adjTop;
                    geo[ i ].cylTop         = gc[ i ].cylTop;
                    geo[ i ].adjBtm         = gc[ i ].adjBtm;
                    geo[ i ].cylBtm         = gc[ i ].cylBtm;
                    geo[ i ].fullHeight     = gc[ i ].fullHeight;
                    geo[ i ].t              = gc[ i ].t;
                    geo[ i ].ang            = gc[ i ].ang;
                    geo[ i ].vi             = gc[ i ].vi;
                    geo[ i ].adapt          = gc[ i ].adapt;
                    geo[ i ].holeIdx        = gc[ i ].holeIdx;
                    geo[ i ].hole_t         = gc[ i ].hole_t;
                    
                    geo[ i ].setIndex( new BufferAttribute( gc[ i ].indices, 1 ) );
                    geo[ i ].setAttribute( 'position', new BufferAttribute( gc[ i ].positions, 3 ) );
                
                    //  positioning, bending: main 0,  appendices 1 ... 
                    
                    main = i === 0 ? true : false;
                    appendix = i !== 0 ? true : false;
                    
                    for ( let j = 0; j < nDraw[ i ] * 3; j += 3 ) {
                        
                        curvePoints.push( new Vector3( gLineA[ i ].positions[ j ], gLineA[ i ].positions[ j + 1 ], gLineA[ i ].positions[ j + 2 ] ) );
                        
                    }
                    
                    curveA = new CatmullRomCurve3( curvePoints, false );
                    
                    if ( main ) { // index 0
                        
                        curveA_0 = curveA.clone( ); //  curveA_0 is main curve
                        
                    }
    
                    calculateMainAppendix( i );
                    
                } // index i:  0, 1 ..
                
                // .....................................................
                
                createMesh( );
                
            }
            
        } else {  
            
            for ( let i = 0; i <= apdCount; i ++ ) { //  main 0,  appendices 1 ...    
                
                main = i === 0 ? true : false;
                appendix = i !== 0 ? true : false;
                
                for ( let j = 0; j < nDraw[ i ] * 3; j += 3 ) {
                    
                    curvePoints.push( new Vector3( gLineA[ i ].positions[ j ], gLineA[ i ].positions[ j + 1 ], gLineA[ i ].positions[ j + 2 ] ) );
                    
                }
                
                curveA = new CatmullRomCurve3( curvePoints, false );
                
                if ( main ) { // index 0
                    
                    curveA_0 = curveA.clone( ); //  curveA_0 is main curve
                    
                }
                
                setParam( i );
                
                geo[ i ] = new DeformableCylinderWithHoles( param[ i ] );
                
                calculateMainAppendix( i ); 
                
            } // index i:  0, 1 ..
            
            // .....................................................
            
            createMesh( );
            
            
        }
        
    }
    
    // detail functions
    
    function setParam( i )  {
    
        if ( main ) { // index 0
            
            param[ 0 ].triangleSide = triangleSide;
            
            param[ 0 ].radius = initialMainRadius.value / 100;          // 100% equals diameter 2, radius 1
            param[ 0 ].height = initialMainHeight.value / 100 * 2;      // 100% equals height 2
            
            param[ 0 ].btmDiff = btmDiff[ 0 ];
            param[ 0 ].topDiff = topDiff[ 0 ];
            
        }
        
        if ( appendix ) {
            
            iHeight = param[ 0 ].holes[ i - 1 ][ 4 ]; // index holes/appeds  from 0 in main 
            
            iHeight = iHeight === 0 ? 0 : ( iHeight < triangleSide ? triangleSide : iHeight );
            
            param[ i ] = {
                
                triangleSide: triangleSide,
                
                radius: param[ 0 ].holes[ i - 1 ][ 2 ], // index holes/appeds  from 0 in main 
                height: iHeight,
                radiusBottom: param[ 0 ].radius, // main radius
                btmDiff: btmDiff[ i ],
                topDiff: topDiff[ i ]
                
            }
            
        }
        
    }
        
    function calculateMainAppendix( i ) {
    
        const i1 = i - 1; // as index for arrays from 0
    
        // sorting the vertices according to height  
        // quicksort of geo[ i ].t  ==>  sorting along: geo[ i ].vi  
        quickCoSort( geo[ i ].t, geo[ i ].vi, 0, geo[ i ].t.length - 1 );
        
    
        // ... bend geometry geo[ i ] ... 
        
        // tangent( direction), normal, binormal ==> shape in space
        // some steps to get the correct first binormal
        binormal.set( 0, 0, 1 ); 
        getTangent( curveA, 0, tangent );  //  or use  getTangent( curveA, 0, tangent );
        
        normal.crossVectors( binormal, tangent );
        binormal.crossVectors( tangent, normal );
        binormal.x = 0; // to prevent torsion
        
        for ( let idx = 0; idx < geo[ i ].t.length; idx ++ ) {  // with quicksort:  idx
        
            if ( geo[ i ].t[ idx ] > 0.99 ) { // 0.99 due to precision problems 
                
                getTangent( curveA, 0.99, tangent );  //  or use  curveA.getTangentAt( 0.99, tangent );  
                makeBasis( tangent, normal, binormal );
                
            }
            
            getTangent( curveA, geo[ i ].t[ idx ], tangent ); //  or use  curveA.getTangentAt( geo[ i ].t[ idx ], tangent );  
            makeBasis( tangent, normal, binormal );
            
            y = interpolateValue( yArr[ i ], geo[ i ].ang[ geo[ i ].vi[ idx ] ], geo[ i ].t[ idx ] );
            
            if ( y < 0.99 && y >= 0 ) { // 0.99 due to precision problems
                
                curveA.getPointAt( interpolateValue( yArr[ i ], geo[ i ].ang[ geo[ i ].vi[ idx ] ], geo[ i ].t[ idx ] ), vCenter );
                
            } else if ( y >= 0.99 ) {
                
                getTangent( curveA, 0.99, tangent );  //  or use  curveA.getTangentAt( 0.99, tangent );  
                makeBasis( tangent, normal, binormal );
                
                curveA.getPointAt( 0.99, vCenter );
                vCenter.add( tangent.clone( ).multiplyScalar( y - 0.99 ) );
                
            } else if ( y < 0  ) {    
                
                getTangent( curveA, 0, tangent );   //  or use  curveA.getTangentAt( 0, tangent );
                makeBasis( tangent, normal, binormal );
                
                curveA.getPointAt( 0, vCenter );
                vCenter.add( tangent.clone( ).multiplyScalar( y ) ); 
                
            }
            
            if( main ) {
            
                if( idx === 0 && capDataBtm[ 0 ][ 0 ] ) {
                    
                    vCenterBtm  = vCenter.clone( );
                    tangentBtm  = tangent.clone( );
                    normalBtm   = normal.clone( );
                    binormalBtm = binormal.clone( );
                    
                }
                
            }
            
            if( idx === geo[ i ].t.length - 1 && capDataTop[ i ][ 0 ] ) {
                
                vCenterTop  = vCenter.clone( );
                tangentTop  = tangent.clone( );
                normalTop   = normal.clone( );
                binormalTop = binormal.clone( );
                
            }
            
            // ***************** circle in space ***********************************************
            
            x = interpolateValue( xArr[ i ], geo[ i ].ang[ geo[ i ].vi[ idx ] ], geo[ i ].t[ idx ] );
            z = interpolateValue( zArr[ i ], geo[ i ].ang[ geo[ i ].vi[ idx ] ], geo[ i ].t[ idx ] );
            
            va.addVectors( binormal.clone( ).multiplyScalar( z ), normal.clone( ).multiplyScalar( x ) );
    
            vb.addVectors( vCenter, va );
            
            geo[ i ].attributes.position.setXYZ( geo[ i ].vi[ idx ], vb.x, vb.y, vb.z );
            
        }
    
        if ( main ) mainPosArr = geo[ 0 ].attributes.position.array; // later used to connect appendices 
        posArr = geo[ i ].attributes.position.array; // main and appendices
        
        //   main bottom cap
        if( main ) {
            geoCon[ 0 ] = null;  // only dummy for main
            
            geoms.push( geo[ 0 ] );
        
            geoType.push(  'main' + geo[ 0 ].type );
            
            if( capDataBtm[ 0 ][ 0 ] ) { //  bottom cap only main
                
                let arg = Math.abs( capDataBtm[ 0 ][ 4 ] * Math.pow( 10, -capDataBtm[ 0 ][ 5 ] ) ) / geo[ 0 ].radius;
                
                const α = p2i - asin( arg < 1 ? arg : 1 ); // opening angle
                
                capHoleBtm = α < p2i ? true : false;
                
                const det0 = geo[ 0 ].detail;
                
                hsCap = capHoleBtm ? Math.ceil( α / p2i * det0 / 2 ) + 1 : det0 / 2;
                
                geoBtm = new CapGeometry( det0, hsCap, capHoleBtm ); //   radial, height segments, capHoleBtm
                
                x = capDataBtm[ 0 ][ 1 ]; 
                y = capDataBtm[ 0 ][ 2 ];
                z = capDataBtm[ 0 ][ 3 ];
                
                const vRad  = new Vector3( ).addVectors( binormalBtm.clone( ).multiplyScalar( z ), normalBtm.clone( ).multiplyScalar( x ) );
                const vPfoo = new Vector3( ).addVectors( vCenterBtm, vRad );       
                
                let divIdx = 0;
        
                for ( let j = 0; j < det0; j ++ ) {
                    
                    vbound.set( mainPosArr[ j * 3 ], mainPosArr[ j * 3 + 1 ], mainPosArr[ j * 3 + 2 ] ); 
                    
                    vcb.subVectors( vbound, vPfoo );
                    
                    let phi = 0;
                    
                    for ( let k = 0; k < hsCap; k ++ ) { // without pole
                    
                        vradial.addVectors( vPfoo, vcb.clone( ).multiplyScalar( cos( phi ) ) );
                        vpos.addVectors( vradial, tangentBtm.clone( ).multiplyScalar( y * sin( phi ) ) );
                        
                        geoBtm.attributes.position.setXYZ( divIdx, vpos.x, vpos.y, vpos.z );
                        
                        phi = α * sin( p2i * ( k + 1 ) / hsCap );
                        
                        divIdx ++;
                        
                    }
                    
                }
                
                if( !capHoleBtm ) {
                    
                    vpos.addVectors( vPfoo, tangentBtm.clone( ).multiplyScalar( y ) ); 
                    geoBtm.attributes.position.setXYZ( divIdx, vpos.x, vpos.y, vpos.z ); // pole
                    
                }
                
                geoms.push( geoBtm );
                
                geoType.push( 'mainBtm' + geoBtm.type );   
                
    
            } else {
                
                geoType.push( '' );
                
            }
            
        }
        
        // main and appendices top cap
        
        if( capDataTop[ i ][ 0 ] ) {
            
            let arg = Math.abs( capDataTop[ i ][ 4 ] * Math.pow( 10, -capDataTop[ i ][ 5 ] ) ) / geo[ i ].radius;
            
            const α = p2i - asin( arg < 1 ? arg : 1 ); // opening angle
            
            capHoleTop = α < p2i ? true : false;
            
            const deti = geo[ i ].detail;
            
            hsCap = capHoleTop ? Math.ceil( α / p2i * deti / 2 ) + 1 : deti/ 2;
            
            geoTop[ i  ] = new CapGeometry( deti, hsCap, capHoleTop ); //   radial, height segments, capHoleTop 
            
            x = capDataTop[ i ][ 1 ]; 
            y = capDataTop[ i ][ 2 ];
            z = capDataTop[ i ][ 3 ];
            
            const vRad  = new Vector3( ).addVectors( binormalTop.clone( ).multiplyScalar( z ), normalTop.clone( ).multiplyScalar( x ) );
            const vPfoo = new Vector3( ).addVectors( vCenterTop, vRad );       
            
            let divIdx = 0; 
    
            for ( let j = 0; j < deti; j ++ ) {
                
                vbound.set( posArr[ ( deti + j ) * 3 ], posArr[ ( deti + j ) * 3 + 1 ], posArr[ ( deti + j ) * 3 + 2 ] );
                vcb.subVectors( vbound, vPfoo );
                
                let phi = 0;
                
                for ( let k = 0; k < hsCap; k ++ ) { // without pole             
                    
                    vradial.addVectors( vPfoo, vcb.clone( ).multiplyScalar( cos( phi ) ) );
                    vpos.addVectors( vradial, tangentTop.clone( ).multiplyScalar( y * sin( phi ) ) );
                    
                    geoTop[ i  ].attributes.position.setXYZ( divIdx, vpos.x, vpos.y, vpos.z );
                    
                    phi = α * sin( p2i * ( k + 1 ) / hsCap );
                    
                    divIdx ++;
                    
                }
                
            }
            
            if( !capHoleTop ) {
                
                vpos.addVectors( vPfoo, tangentTop.clone( ).multiplyScalar( y ) ); 
                geoTop[ i ].attributes.position.setXYZ( divIdx, vpos.x, vpos.y, vpos.z ); // pole
                
            }
            
            if( main ) {
                
                geoms.push( geoTop[ i ] ); //  i: 0
                
                geoType.push( 'mainTop' + geoTop[ i ].type );
    
            }
            
        } else if ( !capDataTop[ i ][ 0 ] && i === 0 ) {
            
            geoType.push( '' );
            
        }
        
        if( appendix ) {
        
            div = geo[ 0 ].adapt[ i1 ][ 4 ] * 4; // div ..  to connect, from main ( index 0 ) 
            
            geoCon[ i ] = new ConnectGeometry( div, div / 4 ); // ( connect geometry: radial, height segments  )
            
            // ....  positioning of geo[ i ], geoCon[ i ], geoTop[ i ] to the main geometry hole ....
            
            va.set( holeCurvePoint[ i1 * 3 ], holeCurvePoint[ i1 * 3 + 1 ], holeCurvePoint[ i1 * 3 + 2 ] );
            va.add( vdir.clone( ).multiplyScalar( 1.2 * geo[ 0 ].radius + param[ i ].height / 2 ) ); // vdir from main, see below
            
            quaternion.setFromUnitVectors( yAxis, vdir );    
            
            geo[ i ].applyQuaternion( quaternion );
            geo[ i ].translate( va.x, va.y, va.z );
            
            if( capDataTop[ i ][ 0 ] ) {
                
                geoTop[ i ].applyQuaternion ( quaternion ); 
                geoTop[ i ].translate( va.x, va.y, va.z );
                
            }
            
            // rotate geo[ i ], geoTop[ i ] around vdir
            
            const posi = geo[ i ].attributes.position.array;
            
            // vdir is tangent and rotation axis
        
            const posi0 = new Vector3( posi[ 0 ], posi[ 1 ], posi[ 2 ] ); // rotate first bottom point for test 
            const posim = new Vector3( posi[ div * 3 / 2 ], posi[ div * 3 / 2 + 1 ],posi[ div * 3 / 2 + 2 ] ); // mirror point
            
            pc.addVectors( posi0, posim ).divideScalar( 2 ); // bottom center point
            vb1.subVectors( posi0, pc );
            vb2.crossVectors( vb1, vdir );
            
            d2Min = Infinity;
            
            for ( let phi = 0; phi < pi * 2; phi += pi * 2 / ( div * 5  ) ) {  // accuracy 5
                
                const sinphi = sin( phi );
                const cosphi = cos( phi );
                
                v.x = pc.x + vb1.x * cosphi + vb2.x * sinphi;
                v.y = pc.y + vb1.y * cosphi + vb2.y * sinphi;
                v.z = pc.z + vb1.z * cosphi + vb2.z * sinphi;
                
                d2 = v.distanceToSquared( hp1 );
                
                if ( d2 < d2Min ) {
                    
                    d2Min = d2;
                    phiMin = phi;
                    
                }
                
            }
            
            const rotation = new Matrix4( ).makeRotationAxis( vdir, -phiMin );
            
            geo[ i ].translate( -pc.x, -pc.y, -pc.z );
            geo[ i ].applyMatrix4( rotation );
            geo[ i ].translate( pc.x, pc.y, pc.z );
    
    
            if( capDataTop[ i ][ 0 ] ) {
                
            geoTop[ i ].translate( -pc.x, -pc.y, -pc.z );
            geoTop[ i ].applyMatrix4( rotation );
            geoTop[ i ].translate( pc.x, pc.y, pc.z );
                
            }
            
            //  ..... connect edges of cylinders .............
            
            const posArrCon = geoCon[ i ].attributes.position.array;
        
            const startIdx = geo[ 0 ].adapt[ i1 ][ 5 ];
            const upperIdxCon = div * div / 4;
            
            let mainX, mainY, mainZ, X, Y, Z, idx;
            
            for (  let j = 0; j < div ; j ++ ) { 
                    
                // connect  geo[ 0 ] (main)   to geo[ i ]
                
                const mainIdx = ( startIdx + j ) * 3;
            
                mainX = mainPosArr[ mainIdx     ];
                mainY = mainPosArr[ mainIdx + 1 ];
                mainZ = mainPosArr[ mainIdx + 2 ];
        
                idx = j === 0 ? 0 : ( div - j ) * 3;
                
                X  = posArr[ idx     ];
                Y  = posArr[ idx + 1 ]; 
                Z  = posArr[ idx + 2 ];
    
                curveA_0.getPointAt( param[ 0 ].holes[ i1 ][ 0 ] , vCenter );
                
                vMain.set( mainX, mainY, mainZ );
                vCon.set( X, Y, Z );
                va.subVectors( vCon, vCenter );
                
                /////  HELPER //////////////////////////////////////////////////////////////////////////////
                // const conHelper = new ArrowHelper( vd.clone( ).normalize( ), vCon, vd.length( ) / 2, 0x0ee0000, 0.005, 0.003 );///
                // sceneA.add( conHelper ); 
                /////////////////////////////////////////////////////////////////////////////////////////////
                
                for( let k = 0; k <= geo[ 0 ].adapt[ i1 ][ 4 ]; k ++ ) {
                
                    vb.subVectors( vMain, vCenter ).multiplyScalar( 0.8 + 0.2 * k / geo[ 0 ].adapt[ i1 ][ 4 ] );
                    
                    vd.subVectors( vb, va )
                
                    v.addVectors( vCon, vd.clone( ).multiplyScalar( k / geo[ 0 ].adapt[ i1 ][ 4 ] ) );
                    
                    idx = ( j + k * div ) * 3;
                    
                    posArrCon[ idx     ] = v.x;
                    posArrCon[ idx + 1 ] = v.y;
                    posArrCon[ idx + 2 ] = v.z;
                    
                }
                
            }
    
            if( onlyHole[ i1 ] ) {
                
                geoType.push( 'Hole','','' );
                
            } else {
            
                geoms.push( geoCon[ i ], geo[ i ] );
                geoType.push( geoCon[ i ].type,  geo[ i ].type );
                
                if( capDataTop[ i ][ 0 ] ) {
                    
                    geoms.push( geoTop[ i ] );
                    geoType.push( 'apdTop' + geoTop[ i ].type );
                    
                } else {
                    
                geoType.push( '' );  
                    
                }
                
            }  
            
        }
        
        if ( i < apdCount ) { // after main and appendices, not after last appendix
        
            // ... calculate hole curve point and direction ... for next appendix 
            
            curveA_0.getPointAt( geo[ 0 ].hole_t[ i ], vCenter ); // hole in main
            holeCurvePoint.push( vCenter.x, vCenter.y, vCenter.z );
            
            hp1.fromBufferAttribute( geo[ 0 ].attributes.position, geo[ 0 ].holeIdx[ i * 2 ] );
            hp2.fromBufferAttribute( geo[ 0 ].attributes.position, geo[ 0 ].holeIdx[ i * 2 + 1 ] );
            hpc.addVectors( hp1, hp2 ).divideScalar( 2 );
            vdir.subVectors( hpc, vCenter ).normalize( );
            
            // /////  HELPER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // const holeHelper = new ArrowHelper( vdir, vCenter, geo[ 0 ].radius , 0x000000, 0.04 , 0.02  );
            // sceneA.add( holeHelper );
            ///////////////////////////////////////////////////////////////////////////////////////////////////
        }
        
        curvePoints = []; // reset for appendices 1 ..        
        
    
    }
            
    function createMesh( ) {
        
        if( doubleEdges.checked ) {
            
            geometry = link( geoms );
            
        } else {
            
            geometry = unite( geoms ); 
        
        }
    
        finalMeshWire = new Mesh( geometry, material3Dwire );
        sceneA.add( finalMeshWire );
        
        ////// HELPER //////////////////////////////////////////////////////////////////////////
        // const helperLinkMesh = new vertexFaceNumbersHelper( cameraA, finalMeshWire, 1, 0.01, 0x990000 );  // from THREEn.js
        // sceneA.add( helperLinkMesh);
        ////// HELPER //////////////////////////////////////////////////////////////////////////
        
        if ( !wire3D || !showWireframe.checked || !useWireframe.checked ) {
            
            if ( !showWireframe.checked ) {
    
                showWireframe.checked = true; // only start dialog
                useWireframe.checked = false;
                
            }
            
            finalMesh = new Mesh( geometry, material2Colors );
            sceneA.add( finalMesh );
            
        }   
        
        ////// HELPER //////////////////////////////////////////////////////////////////////////
        //
        // geo[ 0 ], geoBtm, geoTop[ 0 ], geoCon[ 1 ], geo[ 1 ]
        //
        //const meshHlp = new Mesh( geo[ 1 ], material3Dwire ); 
        //sceneA.add( meshHlp );
        //const vertexHelper = new vertexFaceNumbersHelper( cameraA, meshHlp, 1, 0.01, 0x0022ee );  // from THREEn.js
        ////////////////////////////////////////////////////////////////////////////////////////
        
        triangulationRunning.style.display = 'none';
        
        ready3D = true;
        
    }
    
}

// ............. events ..........................................................

// ... container A ...
 
function onContainerApointerDown( e ) {
    
    if( finish ) {
        
        let da, db, dc, insObj, pIdx, x, fx;  // stp;
        
        let va = new Vector3( );
        let vb = new Vector3( );
        let vc = new Vector3( );
        let vp = new Vector3( );
        let dir = new Vector3( );
        let v  = new Vector3( );
        let vd = new Vector3( );
        
        if( finish && ( detailClick.checked || key === 'back' || key === 'forth' || key === 'point'  ) ) {
        
            pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            pointer.y = -( event.clientY / window.innerHeight ) * 2 + 1;
            
            raycaster.setFromCamera( pointer, cameraA );    
            intersects = raycaster.intersectObject( finalMeshWire );
            
        }
        
        if ( intersects.length > 0 ) {      //  cutting object
            
            geometry.computeVertexNormals( ); 
            
            insObj = intersects[ 0 ]; //  intersected Object
            
            distance2 = dtl.radius / 100 * dtl.radius / 100;
            
            va.fromBufferAttribute( geometry.attributes.position, insObj.face.a );
            vb.fromBufferAttribute( geometry.attributes.position, insObj.face.b );
            vc.fromBufferAttribute( geometry.attributes.position, insObj.face.c );
                        
            da = va.distanceToSquared ( insObj.point ); 
            db = vb.distanceToSquared ( insObj.point ); 
            dc = vc.distanceToSquared ( insObj.point );
            
            if( da < db && da < dc  ) {
                
                pIdx = insObj.face.a
                vp = va.clone( );
                
            } else if ( db < da && db < dc  ) {
            
                pIdx = insObj.face.b
                vp = vb.clone( );
                
            } else if ( dc < da && dc < db  ) {
                
                pIdx = insObj.face.c
                vp = vc.clone( );
                
            } else {
            
                pIdx = insObj.face.a
                vp = va.clone( );
                
            } 
            
            if(  key === 'point' ) {
                
                tubeReady = false;    
                singly.style.display = 'none';
                txtSingly.style.display = 'none';
                
                fnsPts.push( vp );
                
                p1Mesh.position.set( vp.x, vp.y, vp.z );
                sceneA.add( p1Mesh );
                
                if( fnsPts.length > 1 ) {
                    
                    centerCurve = new CatmullRomCurve3( fnsPts, false );
                    
                    centerLen = centerCurve.getLength( );
                    cPcount = Math.ceil( 4 * centerLen / ( dtl.radius / 100 ) );
                    centerPoints = centerCurve.getSpacedPoints( cPcount );
                    
                    tubeGeo.morph( centerPoints, ( dtl.radius / 100 ) );
                    
                }
                
            } else if ( detailClick.checked || key === 'forth' || key === 'back' ) {
                
                let dtlDirection = 'forth'; 
                
                if ( key === 'forth' || key === 'back' ) { // keys override the radio buttons 
                    
                    if ( key === 'back' ) dtlDirection = 'back';
                    
                } else if ( detailClick.checked ) {
                    
                    if ( back.checked ) dtlDirection = 'back';
                    
                }
                
                if ( !singly.checked ) { // all points move along normal of vp
                
                    dir.fromBufferAttribute( geometry.attributes.normal, pIdx );
                    
                    if ( dtlDirection === 'back' ) dir.negate( );
                    
                }
                
                stp = dtlStp.length;
                dtlStp.push( [] );
                
                for ( let i = 0; i < geometry.attributes.position.count; i ++ ) {
                    
                    v.fromBufferAttribute( geometry.attributes.position, i );
                    
                    const dist2 = vp.distanceToSquared( v );
                    
                    if ( dist2 <= distance2 ) {
                                    
                        dtlStp[ stp ].push( i, v.x, v.y, v.z ); // memorize => undo
                        
                        x = 1 - dist2 / distance2 // 1 ... 0
                        
                        fx = getDetailFunction( selectDetailFct.value, dtl.depth / 100, x );
                        
                        if ( singly.checked ) {
                            
                            dir.fromBufferAttribute( geometry.attributes.normal, i );
                            
                            if ( dtlDirection === 'back' ) dir.negate( );
                            
                            dir.multiplyScalar( fx );
                            
                            geometry.attributes.position.setXYZ( i, v.x + dir.x, v.y + dir.y, v.z + dir.z );
                            
                        } else {
                            
                            vd = dir.clone( ).multiplyScalar( fx );
                            
                            geometry.attributes.position.setXYZ( i, v.x + vd.x, v.y + vd.y, v.z + vd.z );
                            
                        }
                        
                    }
                    
                }
                
                geometry.attributes.position.needsUpdate = true;
                
                undo.style.display = dtlStp.length > 0 ? 'inline' : 'none ';
                
            }
            
        }
        
    }
    
}

// ... container B ...

function onContainerBpointerDown( e ) {
                   
    if( ready3D && !cutEditing && !btmEditing && !topEditing ) {
    
        curveC.visible = false;
        curveLoopC.visible = true;
        
        onlyVert = false;
        
        let xNew, yNew, x0, y0, x1, y1, x, y;
        
        getReticleB( e.clientX, e.clientY );
        
        if( reticleX < 0 && !onlyHole[ apdIdx - 1 ] ) {  // left
            
            if ( key === 'remove' ) {  //  only left ( L )
                
                cutIdx = getCutIdx( );
                
                if ( cutIdx !== -1 && cutIdx !== 0 && cutIdx !== ( nCurvePtsB - 1 )  ) {
                
                    if ( cutMarkerLenabled[ apdIdx ][ cutIdx ] ) {
                        
                        cutCoords[ apdIdx ][ cutIdx ] = [];
                        cutMarkerLenabled[ apdIdx ][ cutIdx ] = false; 
                        cutMarkerL[ cutIdx ].material.color.set( 0x00aa00 ); // reset color
                        cutMarkerL[ cutIdx ].material.needsUpdate = true;
                        
                        show3DSceneA( );
                         
                    }
                    
                } else {
                
                    setCutToSliderValues( );
                    
                    show3DSceneA( );
                    
                }
                
            }
            
            if ( key === 'shape' ) {  //  only left ( L )
                
                cutIdx = getCutIdx( );
                
                if ( cutIdx !== -1 ) {
                    
                    directionC.checked = false;
                    reticleCm.visible = true;
                    
                    openShapeFileLoadWindow( );
                    
                }
                
            }
            
            if ( key === 'cutline' ||  key === 'vertical' ) {  //  only left ( L )
                
                txtDirectionC.innerHTML = 'radial';
                
                cutIdx = getCutIdx( );
                
                if ( key === 'vertical'  ) onlyVert = true;
                
                if ( cutIdx !== -1 || onlyVert ) { 
                    
                    if ( !cutMarkerLenabled[ apdIdx ][ cutIdx ] || onlyVert ) { // new  or only vertical ...
                        
                        if ( key === 'cutline' ) {
                        
                            // ... or cut coordinates first   bottom, top
                            if ( cutIdx === 0 && ccfb ) cutCoords[ apdIdx ][ 0 ] = []; // reset bottom
                            if ( cutIdx === ( nCurvePtsB - 1 ) && ccft ) cutCoords[ apdIdx ][ nCurvePtsB - 1 ] = []; // reset top
                            
                            cutEditing = true;
                            
                        }
                        
                        let α = pi;
                        
                        crValue = onlyVert ?        95 : parseInt( cr.value );
                        cnValue = onlyVert ? cnDefault : parseInt( cn.value );
                        
                        for ( let k = 0; k < cnValue; k ++ ) {  // set radius default or 95 
                            
                            x = crValue / 100 * cos( α );
                            y = crValue / 100 * sin( α );
                            
                            markerC[ k ].position.set( x, y, 0 );
                            
                            markerC[ k ].visible = onlyVert ? false : true ;
                            
                            α += 2 * pi / cnValue;
                            
                        }
                        
                        for ( let k = cnValue; k < cnmax; k ++ ) {
                            
                            markerC[ k ].visible = false;
                            
                        }
                        
                        α = pi;  // reset
                        
                        for ( let k = 0; k < nCurvePtsC; k ++ ) {
                            
                            x = crValue / 100 * cos( α );
                            y = crValue / 100 * sin( α );
                            
                            vertMarkerC[ k ].position.set( x, y, 0 );
                            
                            vertMarkerC[ k ].visible = true;
                            
                            α += 2 * pi / nCurvePtsC;
                            
                        }
                        
                    } else {    // edit cut
                        
                        cutEditing = true;
                        
                        cnValue = cutCoords[ apdIdx ][ cutIdx ].length / 2;
                        
                        for ( let k = 0; k < cnValue ; k ++ ) { // cutCoords:  [  x1,y1, x2,y2, .. ] 
                            
                            x = cutCoords[ apdIdx ][ cutIdx ][ k * 2 ];
                            y = cutCoords[ apdIdx ][ cutIdx ][ k * 2 + 1 ];
                            
                            markerC[ k ].position.set( x, y, 0 );
                            
                            markerC[ k ].visible = true;
                            
                        }
                        
                        for ( let k = cnValue; k < cnmax; k ++ ) {
                            
                            markerC[ k ].visible = false;
                            
                        }    
                        
                        cutCoordsBak = cutCoords[ apdIdx ][ cutIdx ].slice( ); 
                        
                    }
                    
                    updateCurveC( );
                    
                    for ( let k = 0; k < nCurvePtsC; k ++ ) {
                        
                        vertMarkerC[ k ].visible = true;
                        
                    }
                    
                    updateVerticalMarkersC( );

                    
                    if( cutIdx !== 0 && cutIdx !== ( nCurvePtsB - 1 ) && !onlyVert ) {
                    
                        cutMarkerL[ cutIdx ].material.color.set( 0xdd0000 );
                        cutMarkerL[ cutIdx ].material.needsUpdate = true; 
                        
                    }
                    
                    if ( onlyVert ) {
                        
                        cutIdx = 0; // to prevent errors, no saving, no exporting
                        
                    }
                    
                    visibilityChangesCD( );
                    
                    displaySomeAB( "none" );
                    
                    reticleCm.visible = true;
                    
                }
                
            }
            
            if ( key === 'insert' ) {
            
                idxHitL = hitMarkerL( -1 );
                idx3HitL = idxHitL / 3;
                
                if ( idxHitL !== -1 ) {
                    
                    if ( idxHitL < markerCountL * 3 ) {
                        
                        for ( let i = markerCountL ; i > idx3HitL; i -- ) {
                            
                            markerBL[ i + 1 ] = markerBL[ i ];
                            
                            markerBL[ i + 1 ].position.x = markerBL[ i ].position.x;
                            markerBL[ i + 1 ].position.y = markerBL[ i ].position.y;
                            
                        }
                        
                        markerCountL ++;
                        
                        markerBL[ idx3HitL + 1 ] = new Sprite( matSpriteBlue );
                        
                        xNew = round( 100 * ( markerBL[ idx3HitL ].position.x + markerBL[ idx3HitL + 2 ].position.x ) / 2 ) / 100;
                        yNew = round( 100 * ( markerBL[ idx3HitL ].position.y + markerBL[ idx3HitL + 2 ].position.y ) / 2 ) / 100; 
                        
                        markerBL[ idx3HitL + 1 ].position.x = xNew;
                        markerBL[ idx3HitL + 1 ].position.y = yNew;
                        markerBL[ idx3HitL + 1 ].scale.x = markerSize;
                        markerBL[ idx3HitL + 1 ].scale.y = markerSize;
                        
                        sceneB.add( markerBL[ idx3HitL + 1 ] );
                        gLineL.setDrawRange ( 0, markerCountL + 1 );
                        
                        for ( let i = markerCountL * 3; i > idxHitL; i -= 3 ) {
                            
                            gLineL.positions[ i + 3 ] = gLineL.positions[ i ];
                            gLineL.positions[ i + 3 + 1 ] = gLineL.positions[ i + 1 ];
                            gLineL.positions[ i + 3 + 2 ] = gLineL.positions[ i + 2 ];
                            
                        }
                        
                        gLineL.positions[ idxHitL + 3 ] = xNew;
                        gLineL.positions[ idxHitL + 3 + 1 ] = yNew;
                        gLineL.positions[ idxHitL + 3 + 2 ] = 0;
                        
                        // sync right
                        
                        for ( let i = markerCountR; i > idx3HitL; i -- ) {
                            
                            markerBR[ i + 1 ] = markerBR[ i ];
                            markerBR[ i + 1 ].position.x = markerBR[ i ].position.x;
                            markerBR[ i + 1 ].position.y = markerBR[ i ].position.y;
                            
                        }
                        
                        markerCountR ++;
                        
                        markerBR[ idx3HitL + 1 ] = new Sprite( matSpriteBlue );
                        
                        
                        markerBR[ idx3HitL + 1 ].position.x = xNew + 2;
                        markerBR[ idx3HitL + 1 ].position.y = ( markerBR[ idx3HitL + 2 ].position.y + markerBR[ idx3HitL ].position.y ) / 2;
                        
                        markerBR[ idx3HitL + 1 ].scale.x = markerSize;
                        markerBR[ idx3HitL + 1 ].scale.y = markerSize;
                        
                        sceneB.add( markerBR[ idx3HitL + 1 ] );
                        gLineR.setDrawRange ( 0, markerCountL + 1 );
                        
                        for ( let i = markerCountL * 3; i > idxHitL; i -= 3 ) {
                            
                            gLineR.positions[ i + 3 ] = gLineR.positions[ i ];
                            gLineR.positions[ i + 3 + 1 ] = gLineR.positions[ i + 1 ];
                            gLineR.positions[ i + 3 + 2 ] = gLineR.positions[ i + 2 ];
                        }
                        
                        gLineR.positions[ idxHitL + 3 ] = xNew + 2;
                        gLineR.positions[ idxHitL + 3 + 1 ] = ( markerBR[ idx3HitL + 2 ].position.y + markerBR[ idx3HitL ].position.y ) / 2;
                        gLineR.positions[ idxHitL + 3 + 2 ] = 0;
                        
                        gLineR.positions[ idxHitL + 3 + 2 ] = 0;
                        
                        gLineR.attributes.position.needsUpdate = true;
                        
                        // sync perspective
                        
                        nDraw[ apdIdx ] ++;
                        
                        for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
                            
                            gLineA[ apdIdx ].positions[ i * 3 ] = gLineL.positions[ i * 3 ] + 1;        // x from left
                            gLineA[ apdIdx ].positions[ i * 3 + 1 ] = gLineL.positions[ i * 3 + 1 ];     // y from left
                            gLineA[ apdIdx ].positions[ i * 3 + 2 ] = -gLineR.positions[ i * 3 + 1 ];  // y from right
                            //gLineA[ apdIdx ].positions[ i * 3 + 2 ] = gLineR.positions[ i * 3 ] - 1;     // x from right
                        }
                        
                        gLineA[ apdIdx ].setDrawRange ( 0, nDraw[ apdIdx ] );
                        
                    }
                    
                }
                
            }
            
            if ( key === 'delete' ) {
                
                idxHitL = hitMarkerL( -1 );
                idx3HitL = idxHitL / 3;
                
                if ( idxHitL !== -1 ) {
                    
                    for ( let j = idxHitL; j < markerBL.length * 3 - 3; j += 3 ) {
                        
                        gLineL.positions[ j ] = gLineL.positions[ j + 3 ];
                        gLineL.positions[ j + 1 ] = gLineL.positions[ j + 4 ];
                        
                    }
                    
                    sceneB.remove( markerBL[ idx3HitL ] );
                    markerBL[ idx3HitL ].geometry.dispose();
                    
                    for ( let j = idx3HitL; j < markerBL.length - 1; j ++ ) {
                        
                        markerBL[ j ] = markerBL[ j + 1 ];
                        
                    }
                    
                    markerCountL --;
                    
                    gLineL.setDrawRange ( 0, markerCountL + 1 );
                    
                    // sync right
                    
                    for ( let j = idxHitL; j < markerBR.length * 3 - 3; j += 3 ) {
                        
                        gLineR.positions[ j ] = gLineR.positions[ j + 3 ];
                        gLineR.positions[ j + 1 ] = gLineR.positions[ j + 4 ];
                        
                    }
                    
                    sceneB.remove( markerBR[ idx3HitL ] );
                    markerBR[ idx3HitL ].geometry.dispose();
                    
                    for ( let j = idx3HitL; j < markerBR.length - 1; j ++ ) {
                        
                        markerBR[ j ] = markerBR[ j + 1 ];
                        
                    }
                    
                    markerCountR --;
                    
                    gLineR.setDrawRange ( 0, markerCountR + 1 );
                    
                    // sync perspective
                    
                    nDraw[ apdIdx ] --;
                    
                    for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
                        
                        gLineA[ apdIdx ].positions[ i * 3 ] = gLineL.positions[ i * 3 ] + 1;        // x from left
                        gLineA[ apdIdx ].positions[ i * 3 + 1 ] = gLineL.positions[ i * 3 + 1 ];     // y from left
                        gLineA[ apdIdx ].positions[ i * 3 + 2 ] = -gLineR.positions[ i * 3 + 1 ];  // y from right
                        //gLineA[ apdIdx ].positions[ i * 3 + 2 ] = gLineR.positions[ i * 3 ] - 1;     // x from right
                    }
                    
                    gLineA[ apdIdx ].setDrawRange ( 0, nDraw[ apdIdx ] );
                        
                }
                
            }
              
            if ( key === 'move' ) {
                
                idxMoveL = hitMarkerL( -1 );
                
            }
            
            gLineL.attributes.position.needsUpdate = true;
            gLineR.attributes.position.needsUpdate = true;
            gLineA[ apdIdx ].attributes.position.needsUpdate = true;
            
        }
        
        if( reticleX > 0 && !onlyHole[ apdIdx - 1 ] ) { // right
        
            if ( key === 'insert' ) {
                
                idxHitR = hitMarkerR( -1 );
                idx3HitR = idxHitR / 3;
                
                if ( idxHitR !== -1 ) {
                    
                    if ( idxHitR < markerCountR * 3 ) {
                        
                        for ( let i = markerCountR; i > idx3HitR; i -- ) {
                            
                            markerBR[ i + 1 ] = markerBR[ i ];
                            markerBR[ i + 1 ].position.x = markerBR[ i ].position.x;
                            markerBR[ i + 1 ].position.y = markerBR[ i ].position.y;
                            
                        }
                        
                        markerCountR ++;
                        
                        markerBR[ idx3HitR + 1 ] = new Sprite( matSpriteBlue );
                        
                        xNew = round( 100 * ( markerBR[ idx3HitR ].position.x + markerBR[ idx3HitR + 2 ].position.x ) / 2 ) / 100;
                        yNew = round( 100 * ( markerBR[ idx3HitR ].position.y + markerBR[ idx3HitR + 2 ].position.y ) / 2 ) / 100;
                        
                        markerBR[ idx3HitR + 1 ].position.x = xNew;
                        markerBR[ idx3HitR + 1 ].position.y = yNew;
                        markerBR[ idx3HitR + 1 ].scale.x = markerSize;
                        markerBR[ idx3HitR + 1 ].scale.y = markerSize;
                        
                        sceneB.add( markerBR[ idx3HitR + 1 ] );
                        gLineR.setDrawRange ( 0, markerCountR + 1 );
                        
                        for ( let i = markerCountR * 3; i > idxHitR; i -= 3 ) {
                            
                            gLineR.positions[ i + 3 ] = gLineR.positions[ i ];
                            gLineR.positions[ i + 3 + 1 ] = gLineR.positions[ i + 1 ];
                            gLineR.positions[ i + 3 + 2 ] = gLineR.positions[ i + 2 ];
                            
                        }
                        
                        gLineR.positions[ idxHitR + 3 ] = xNew;
                        gLineR.positions[ idxHitR + 3 + 1 ] = yNew;
                        gLineR.positions[ idxHitR + 3 + 2 ] = 0;
                        
                        // sync left
                    
                        for ( let i = markerCountL; i > idx3HitR; i -- ) {
                            
                            markerBL[ i + 1 ] = markerBL[ i ];
                            markerBL[ i + 1 ].position.x = markerBL[ i ].position.x;
                            markerBL[ i + 1 ].position.y = markerBL[ i ].position.y;
                            
                        }
                        
                        markerCountL ++;
                        
                        markerBL[ idx3HitR + 1 ] = new Sprite( matSpriteBlue );
                        
                        markerBL[ idx3HitR + 1 ].position.x = xNew - 2;
                        markerBL[ idx3HitR + 1 ].position.y = ( markerBL[ idx3HitR + 2 ].position.y + markerBL[ idx3HitR ].position.y ) / 2;
                        
                        markerBL[ idx3HitR + 1 ].scale.x = markerSize;
                        markerBL[ idx3HitR + 1 ].scale.y = markerSize;
                        
                        sceneB.add( markerBL[ idx3HitR + 1 ] );
                        gLineL.setDrawRange ( 0, markerCountR + 1 );
                        
                        for ( let i = markerCountR * 3; i > idxHitR; i -= 3 ) {
                            
                            gLineL.positions[ i + 3 ] = gLineL.positions[ i ];
                            gLineL.positions[ i + 3 + 1 ] = gLineL.positions[ i + 1 ];
                            gLineL.positions[ i + 3 + 2 ] = gLineL.positions[ i + 2 ];
                        }
                        
                        gLineL.positions[ idxHitR + 3 ] = xNew - 2;
                        gLineL.positions[ idxHitR + 3 + 1 ] = ( markerBL[ idx3HitR + 2 ].position.y + markerBL[ idx3HitR ].position.y ) / 2;
                        
                        gLineL.positions[ idxHitR + 3 + 2 ] = 0;
                        
                        // sync perspective
                        
                        nDraw[ apdIdx ] ++;
                        
                        for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
                            
                            gLineA[ apdIdx ].positions[ i * 3 ] = gLineL.positions[ i * 3 ] + 1;        // x from left
                            gLineA[ apdIdx ].positions[ i * 3 + 1 ] = gLineL.positions[ i * 3 + 1 ];    // y from left
                            gLineA[ apdIdx ].positions[ i * 3 + 2 ] = -gLineR.positions[ i * 3 + 1 ];   // y from right
                            //gLineA[ apdIdx ].positions[ i * 3 + 2 ] = gLineR.positions[ i * 3 ] - 1;  // x from right
                        }
                        
                        gLineA[ apdIdx ].setDrawRange ( 0, nDraw[ apdIdx ] );
                        
                    }
                    
                }
                
            }
            
            if (  key === 'delete' ) {
            
                idxHitR = hitMarkerR( -1 );
                idx3HitR = idxHitR / 3;
                
                if ( idxHitR !== -1 ) {
                    
                    for ( let j = idxHitR; j < markerBR.length * 3 - 3; j += 3 ) {
                        
                        gLineR.positions[ j ] = gLineR.positions[ j + 3 ];
                        gLineR.positions[ j + 1 ] = gLineR.positions[ j + 4 ];
                        
                    }
                    
                    sceneB.remove( markerBR[ idx3HitR ] );
                    markerBR[ idx3HitR ].geometry.dispose();
                    
                    for ( let j = idx3HitR; j < markerBR.length - 1; j ++ ) {
                        
                        markerBR[ j ] = markerBR[ j + 1 ];
                        
                    }
                    
                    markerCountR --;
                    
                    gLineR.setDrawRange ( 0, markerCountR + 1 );
                    
                    // sync left
                    
                    for ( let j = idxHitR[ 0 ]; j < markerBL.length * 3 - 3; j += 3 ) {
                        
                        gLineL.positions[ j ] = gLineL.positions[ j + 3 ];
                        gLineL.positions[ j + 1 ] = gLineL.positions[ j + 4 ];
                        
                    }
                    
                    sceneB.remove( markerBL[ idx3HitR ] );
                    markerBL[ idx3HitR ].geometry.dispose();
                    
                    for ( let j = idx3HitR; j < markerBL.length - 1; j ++ ) {
                            
                        markerBL[ j ] = markerBL[ j + 1 ];
                        
                    }
                    
                    markerCountL --;
                    
                    gLineL.setDrawRange ( 0, markerCountL + 1 );
                    
                    // sync perspective
                    
                    nDraw[ apdIdx ] --;
                    
                    for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
                        
                        gLineA[ apdIdx ].positions[ i * 3 ] = gLineL.positions[ i * 3 ] + 1;       // x from left
                        gLineA[ apdIdx ].positions[ i * 3 + 1 ] = gLineL.positions[ i * 3 + 1 ];   // y from left
                        gLineA[ apdIdx ].positions[ i * 3 + 2 ] = -gLineR.positions[ i * 3 + 1 ];  // y from right
                        //gLineA[ apdIdx ].positions[ i * 3 + 2 ] = gLineR.positions[ i * 3 ] - 1; // x from right
                    }
                    
                    gLineA[ apdIdx ].setDrawRange ( 0, nDraw[ apdIdx ] );
                    
                }
                
            }
            
            if (  key === 'move' ) {
                
                idxMoveR = hitMarkerR( -1 );
                
            }
            
            gLineR.attributes.position.needsUpdate = true;
            gLineL.attributes.position.needsUpdate = true;
            gLineA[ apdIdx ].attributes.position.needsUpdate = true;
            
        }
        
        if( !onlyHole[ apdIdx - 1 ] ) {
        
            // ... to global apdIdx  ...
            
            updateCurvesLR( );
            updateCutMarkersL( );
            
            //..........................
            
        }
        
    }

}

function onContainerBpointerMove( e ) {
    
    if( ready3D && !cutEditing ) { 
    
        e.preventDefault( );
        
        getReticleB( e.clientX, e.clientY );
        
        reticleBh.position.set( reticleX, reticleY, 0 );
        
        coords.style.left = e.clientX + 10 + "px";
        coords.style.top = e.clientY - 10 + "px";
        
        if( reticleX === 0 ) {
            
            reticleBm.visible = false;
            
        }
        
        if( reticleX < 0 && !onlyHole[ apdIdx - 1 ] ) { // left
                
            dispX = round( 100 * ( reticleX + 1 ) * sizeFactor );
            dispY = round( 100 * reticleY * sizeFactor );
            
            if( dispY > -100.001 ) {
            
                coords.innerHTML = dispX + " ▪ " + dispY;
                
            } else {
            
                coords.innerHTML = '';
                
            }
            
            if ( hitMarkerL( idxMoveL ) === -1 ) {
                
                reticleBm.visible = true;
                reticleBh.visible = false;
                reticleBm.position.set( reticleX, reticleY, 0 );
                coords.style.color = "#666600";
                
                
            } else {  
                
                reticleBm.visible = false;
                reticleBh.visible = true;
                reticleBh.position.set( reticleX, reticleY, 0 );
                coords.style.color = "#ff0000";
                
            }
            
            if ( key === 'move' && idxMoveL !== -1 ) {
                
                if ( !checkHitL( idxMoveL - 3 ) && !checkHitL( idxMoveL + 3 ) ) {
                    
                    markerBL[ idxMoveL / 3 ].position.x = reticleX;
                    markerBL[ idxMoveL / 3 ].position.y = reticleY;
                    
                    markerBR[ idxMoveL / 3 ].position.x = reticleX + 2;  // sync right
                    //markerBR[ idxMoveL / 3 ].position.y = reticleY;      // sync right
                    
                    gLineL.positions[ idxMoveL ] = reticleX;
                    gLineL.positions[ idxMoveL + 1 ] = reticleY;
                    
                    gLineR .positions[ idxMoveL ] = reticleX + 2;    // sync right
                    
                    gLineA[ apdIdx ].positions[ idxMoveL ] = gLineL.positions[ idxMoveL ] + 1;      // x from left
                    gLineA[ apdIdx ].positions[ idxMoveL + 1 ] = gLineL.positions[ idxMoveL + 1 ];  // y from left
                    gLineA[ apdIdx ].positions[ idxMoveL + 2 ] = -gLineR.positions[ idxMoveL + 1 ]; // y from right               
                    
                    gLineL.attributes.position.needsUpdate = true;
                    gLineR.attributes.position.needsUpdate = true;  // sync right
                    gLineA[ apdIdx ].attributes.position.needsUpdate = true;   // sync perspective
                    
                }
                
            }
            
        }
        
        if( reticleX > 0 && !onlyHole[ apdIdx - 1 ] ) { // right
            
            dispX = round( 100 *( reticleX - 1 ) * sizeFactor );
            dispY = round( 100 * reticleY * sizeFactor );
            
            if( dispY > -100.001 && dispX < 100.001 ) {
                
                coords.innerHTML = dispX + " ▪ " + dispY;
                
            } else {
            
                coords.innerHTML = '';
                
            }
            
            if ( hitMarkerR( idxMoveR ) === -1 ) {
                
                reticleBm.visible = true;
                reticleBh.visible = false;
                reticleBm.position.set( reticleX, reticleY, 0 );
                coords.style.color = "#666600";
                
            } else {
                
                reticleBm.visible = false;
                reticleBh.visible = true;
                reticleBh.position.set( reticleX, reticleY, 0 );
                coords.style.color = "#ff0000";
                
            }
            
            if ( key === 'move' && idxMoveR !== -1 ) {
                
                if ( !checkHitR( idxMoveR - 3 ) &&  !checkHitR( idxMoveR + 3 ) ) {
                    
                    markerBR[ idxMoveR / 3 ].position.x = reticleX;
                    markerBR[ idxMoveR / 3 ].position.y = reticleY;
                    
                    markerBL[ idxMoveR / 3 ].position.x = reticleX - 2;  // sync left
                    //markerBL[[ idxMoveR / 3 ].position.y = reticleY;      // sync right
                    
                    gLineR.positions[ idxMoveR ] = reticleX;
                    gLineR.positions[ idxMoveR + 1 ] = reticleY;
                    
                    gLineL.positions[ idxMoveR ] = reticleX - 2;     // sync left
                    
                    gLineA[ apdIdx ].positions[ idxMoveR ] = gLineL.positions[ idxMoveR ] + 1;     // x from left
                    gLineA[ apdIdx ].positions[ idxMoveR + 1 ] = gLineL.positions[ idxMoveR + 1 ];  // y from left
                    gLineA[ apdIdx ].positions[ idxMoveR + 2 ] = -gLineR.positions[ idxMoveR + 1 ]; // y from right
                    
                    gLineR.attributes.position.needsUpdate = true;
                    gLineL.attributes.position.needsUpdate = true;  // sync left
                    gLineA[ apdIdx ].attributes.position.needsUpdate = true;   // sync perspective
                    
                }
                
            }
            
        }
        
    }
    
}

function onContainerBpointerUp( e ) {
    
    if( ready3D && !cutEditing ) {
    
        e.preventDefault();
        
        idxMoveL = -1;
        idxMoveR = -1;
        key = '';
        
        
        if( !onlyHole[ apdIdx - 1 ] ) {
        
            // ... to global apdIdx  ...
            updateCurvesLR( );
            updateCutMarkersL( );
            //.............................
            
        }
        
    } else if( ready3D && cutEditing ){
        
        cutMarkerL[ cutIdx ].material.color.set( 0xdd0000 );
        cutMarkerL[ cutIdx ].material.needsUpdate = true;        
        
    }
    
}

function onContainerBpointerLeave( e ) {
    
    if ( ready3D ) {
    
        reticleBm.visible = false;
        reticleBh.visible = false;
        coords.innerHTML = '';
        
    }
    
}

// ... container C ...   
                
function onContainerCpointerDown( e ) {
    
     if( ready3D && !vertEditing ) {
        
        reticleCm.visible = true;
        
        e.preventDefault( );
        
        getReticleC( e.clientX, e.clientY );
    
        retPos.set( reticleX, reticleY ); // position vector
        
        idxC = -1;
        
        if ( key === 'translate' ) {
            
            markerPos.set( translateMarker.position.x, translateMarker.position.y );
            
            if ( markerPos.distanceToSquared( retPos ) < 0.000225 ) {  // to squared  -->  dMin < 0.015
            
                moveTranslate = true;  // move translate marker
                
            }
            
        }
        
        if ( key === 'height' ) {
            
            markerPos.set( heightMarker.position.x, heightMarker.position.y );
            
            if ( markerPos.distanceToSquared( retPos ) < 0.000225 ) {  // to squared  -->  dMin < 0.015
                
                moveHeight = true;  // move height marker
                
            }
            
        }
        
        if ( key === 'opening' ) {
            
            markerPos.set( openingMarker.position.x, openingMarker.position.y );
            
            if ( markerPos.distanceToSquared( retPos ) < 0.000225 ) {  // to squared  -->  dMin < 0.015
                
                moveOpening = true;  // move opening marker
                
            }
            
        } 
        
        if ( key === 'move' || key === 'shape' ) {
            
            let dist2, jMin;
            let dMin2 = Infinity;
            
            for ( let j = 0; j < cnValue; j ++ ) {
            
                markerPos.set( markerC[ j ].position.x, markerC[ j ].position.y );
                
                dist2 = markerPos.distanceToSquared( retPos );
                
                if ( dist2 < dMin2 ) {
                    
                    dMin2 = dist2;
                    jMin = j;
                    
                }
                
            }
            
            if ( dMin2 < 0.000225 ) {  // to squared  -->  dMin < 0.015
                
                idxC = jMin;
                
                αC = jMin * pi * 2 / cnValue  + pi ;
                
            }
            
            if ( key === 'shape' ) {
                
                for ( let j = 0; j < cnValue; j ++ ) {
                    
                    marker0Cx[ j ] = markerC[ j ].position.x;
                    marker0Cy[ j ] = markerC[ j ].position.y;
                    
                }
                
                rDown =  sqrt( marker0Cx[ idxC ] * marker0Cx[ idxC ] + marker0Cy[ idxC ] * marker0Cy[ idxC ] );
                
                dirCheck = directionC.checked;
                directionC.checked = true;
                
            }  
            
        }
        
        if ( key === 'vertical' && !btmEditing  && !topEditing ) {
            
            vertIdx = getVertIdx( );
            
            if( vertIdx !== -1 ) {
                
                if ( !vertMarkerCenabled[ apdIdx ][ vertIdx ] ) { // new  ...
                    
                    // ... or vertical coordinates first                
                    if ( vertIdx === 0 && vcf0 ) vertCoords[ apdIdx ][ vertIdx ] = []; // reset at index 0
                    if ( vertIdx === nCurvePtsC / 2 && vcf1 ) vertCoords[ apdIdx ][ vertIdx ] = []; // reset at index 0
                    
                    dnValue = parseInt( dn.value );
                    dbasValue = parseInt( dbas.value );
                    
                    const dn1 = dnValue - 1;
                    const db = dbasValue / 100;  // x% / 100
                    
                    const d = 2 * db / dn1;
                    let y = -db;
                    
                    for ( let k = 0; k < 2; k ++ ) { // bottom, top  left as basis
                        
                        markerD0[ k ].position.set( -xD, y, 0 );
                        markerD0[ k ].visible = true;
                        gBasisD.attributes.position.array[ k * 3 + 1 ] = y;
                        
                        y += 2 * db;
                        
                    }
                    
                    y = -db; // reset
                    
                    for ( let k = 0; k <= dn1; k ++ ) { // right, height values
                        
                        markerD[ k ].position.set( xD, y, 0 );
                        markerD[ k ].visible = true;
                        y += d;
                        
                    }
                    
                    for ( let k = dn1 + 1; k < dnmax; k ++ ) {
                        
                        markerD[ k ].visible = false;
                        
                    }
                    
                    for ( let i = 0; i <= dn1; i ++ ) {
                            
                            const y = -db + 2 * db * i / dn1;
                            const i6 = i  * 6;
                            
                            // pre-assignment with y = 0 :   -xD, y, 0,    xD, y, 0 
                            
                            gLinesD.positions[ i6 + 1 ] = gLinesD.positions[ i6 + 4 ] = y;
                            
                    }
                    
                    gLinesD.setDrawRange( 0, dnValue * 2 );
                                     
                } else { // edit vertical
                    
                    const vertBas = vertBasis[ apdIdx ][ vertIdx ]; 
                    const vertCooLen = vertCoords[ apdIdx ][ vertIdx ].length;
                    
                    let y0 = -vertBas / 2; // bottom (basis is left)
                         
                    for ( let k = 0; k < 2; k ++ ) { // bottom, top  left as basis
                        
                        markerD0[ k ].position.set( -xD, y0, 0 );
                        markerD0[ k ].visible = true;
                        gBasisD.attributes.position.array[ k * 3 + 1 ] = y0;
                        
                        y0 += vertBas; // to top
                        
                    }
                    
                    y0 = -vertBas / 2; // reset to bottom
                    
                    for( let k = 0; k < vertCooLen; k ++ ) {
                        
                        const y = y0 + vertCoords[ apdIdx ][ vertIdx ][ k ] * vertBas;
                        
                        markerD[ k ].position.set( xD, y, 0 );
                        markerD[ k ].visible = true;
                        
                        // pre-assignment with y = 0 :   -xD, y, 0,    xD, y, 0 
                        
                        gLinesD.positions[ k * 6 + 1 ] = y0 + k / ( vertCooLen - 1 ) * vertBas;
                        gLinesD.positions[ k * 6 + 4 ] = y;
                        
                    }
                    
                    for ( let k = vertCooLen; k < dnmax; k ++ ) {
                        
                        markerD[ k ].visible = false;
                        
                    }
                    
                    gLinesD.setDrawRange( 0, vertCooLen * 2 );
                    
                    vertCoordsBak = vertCoords[ apdIdx ][ vertIdx ].slice( );
                    
                }
                
                gBasisD.attributes.position.needsUpdate = true;
                gLinesD.attributes.position.needsUpdate = true;
                
                vertMarkerC[ vertIdx ].material.color.set( 0xdd0000 );
                vertMarkerC[ vertIdx ].material.needsUpdate = true;
                
                cutEditing = false;
                vertEditing = true;
                
                visibilityD( "visible" );
                
            }
            
        }
       
        if ( key === 'remove' && !btmEditing  && !topEditing ) {
            
            vertIdx = getVertIdx( );
                
            if ( vertIdx === 0 || ( vertIdx === nCurvePtsC / 2 ) ) {
            
                setVerticalReference( ); // remove impossible, set to slider values
                
                vertMarkerC[ vertIdx ].material.color.set( 0xdd0000 );
                vertMarkerC[ vertIdx ].material.needsUpdate = true;
                
                cutEditing = false;
                vertEditing = true;
                
                visibilityD( "visible" );                    
                   
            } else {
                
                vertCoords[ apdIdx ][ vertIdx ] = [];
                vertMarkerCenabled[ apdIdx ][ vertIdx ] = false; 
                vertMarkerC[ vertIdx ].material.color.set( 0x00aa00 ); // reset color
                vertMarkerC[ vertIdx ].material.needsUpdate = true;
                
            }
            
        } 
        
    }
    
}

function onContainerCpointerMove( e ) {
    
    if( ready3D && !vertEditing ) {
        
        e.preventDefault( );
        
        let x, y; 
        let r = 0;
        let φ = 0;
        
        reticleCm.visible = true;
        
        getReticleC( e.clientX, e.clientY );
        
        retPos.set( reticleX, reticleY ); // position vector
        
        vertIdx = getVertIdx( );
        
        reticleCm.position.set( reticleX, reticleY, 0 );
        
        coords.style.left = e.clientX + 10 + "px";
        coords.style.top = e.clientY + 10 + "px";
        
        if ( key === 'move'  && ( btmEditing || topEditing ) ) {
            
            dispX =  'φ ' + round( reticleX * 180 ) + '°'; // angle bottom top edge
            
        } else {
            
            dispX = round( 100 * reticleX  * sizeFactor );
            
        }
        
        dispY = round( 100 * reticleY * sizeFactor );
        
        if( key === 'height' && moveHeight ) coords.innerHTML = dispY + " height";
        if( key === 'opening' && moveOpening ) coords.innerHTML = Math.abs( dispX ) + " opening";
        if( !( key === 'height' ) && !( key === 'opening' ) ) coords.innerHTML = dispX + " ▪ " + dispY;
        
        if ( cutEditing || ( key === 'translate' && moveTranslate ) ) {
            
            cutradius.style.left = e.clientX + 10 + "px";
            cutradius.style.top = e.clientY - 20 + "px";
            
            r = sqrt( reticleX * reticleX  + reticleY * reticleY );
            φ = round( atan2( reticleX, -reticleY ) * 180 / pi ); // angle cap center
            
            cutradius.innerHTML = ( !cutEditing ? 'center φ ' + φ + '°' : '' ) + ' r ' + round( 1000 * r  * sizeFactor ) / 10;
            
        } else {
            
            cutradius.innerHTML = '';
            
        }
        
        if ( key === 'translate' && moveTranslate ) {
            
            translateMarker.position.set( reticleX, reticleY, 0 );
            
        }
        
        if ( key === 'height' && moveHeight ) {
            
            heightMarker.position.set( 0, reticleY, 0 );
            openingMarker.position.set( openingMarker.position.x, heightMarker.position.y, 0 );
            
        }
        
        if ( key === 'opening' && moveOpening ) {
             
             let minR ;
             
             if( opngE.value !== '0' && reticleX > 0) {
                
                openingMarker.position.set( reticleX, heightMarker.position.y, 0 );
                
            } else if( opngE.value === '0' && reticleX > 0 ) {
                
                minR = Math.min(geo[ apdIdx ].radius, param[ apdIdx ].radius );
                openingMarker.position.set( Math.min( reticleX, minR ), heightMarker.position.y, 0 );
                
            } else {
                
                openingMarker.position.set( 0, heightMarker.position.y, 0 );
                
            }
            
        }
        
        if ( ( key === 'move'   ) && idxC !== -1 ) {
            
            if ( markerC[ idxC ] ) {
                
                if( cutEditing ) {
                    
                    if(  directionC.checked ) {
                    
                            x = r * cos( αC );
                            y = r * sin( αC );
                            
                            markerC[ idxC ].position.set( x, y, 0 );
                            
                    } else {
                        
                        markerC[ idxC ].position.set( reticleX, reticleY, 0 );
                        
                    }
                    
                    const ang = -( atan2Pi( markerC[ idxC ].position.y, markerC[ idxC ].position.x ) - pi );
                    txtAngScale.innerHTML = round( ang * 180  / pi * 10 ) / 10 + '°';
                        
                } else if ( ( btmEditing || topEditing ) && directionC.checked  ) {
                    
                    markerC[ idxC ].position.set( markerC[ idxC ].position.x, reticleY, 0 );
                    
                }
                
                // only btm, top: first and last marker y identical 
                
                if ( ( btmEditing || topEditing ) && ( idxC === 0 || idxC === cnValue - 1 ) ) {
                    
                    markerC[ 0 ].position.set( -1, reticleY, 0 );
                    markerC[ cnValue - 1 ].position.set( 1, reticleY, 0 );
                    
                }   
                
            }
            
        }
        
        if ( key === 'shape' && idxC !== -1 ) {
            
            if ( markerC[ idxC ] && cutEditing ) {
                
                const scaleSh = r / rDown;
                
                for ( let j = 0; j < cnValue; j ++ ) {
                    
                    markerC[ j ].position.set( scaleSh * marker0Cx[ j ], scaleSh * marker0Cy[ j ], 0 );
                    
                }
                
                txtAngScale.innerHTML = round( scaleSh * 100 ) / 100 + '';
                 
                shapeScaled = true;
                
            }
            
        }
        
    }
    
}

function onContainerCpointerUp( e ) {
    
    e.preventDefault( );
        
    if ( shapeScaled ) {
        
        rUp = sqrt( markerC[ idxC ].position.x * markerC[ idxC ].position.x + markerC[ idxC ].position.y * markerC[ idxC ].position.y );

        txtAngScale.innerHTML = round( rUp / rDown * 100 ) / 100 + '';
        
        directionC.checked = dirCheck;
        
        shapeScaled = false;
        
    }
    
    if ( ready3D && ( key === 'translate' ||  key ===  'height' ) ) {
        
        moveTranslate = false;
        moveHeight = false;
        moveOpening = false; 
        
    } else if( ready3D && !vertEditing ) {
        
        idxC = -1; 
        key = '';
        
        updateCurveC( );
        updateVerticalMarkersC( );
        
    }
    
}

function onContainerCpointerLeave( e ) {
    
    if ( ready3D ) {
    
        reticleCm.visible = false;
        coords.innerHTML = '';
        cutradius.innerHTML = '';
        
    }
    
}

// ... container D ...

function onContainerDpointerDown( e ) {
    
    if ( ready3D ) {
    
        const dn1 = dnValue - 1;
        
        reticleDm.visible = true;
        
        e.preventDefault( );
        
        getReticleD( e.clientY );
        
        let dist2, jMin;
        let dMin2 = Infinity;
        idxD = -1;
        
        if( key === 'nleft' ) { // basis point:  D left n = 0,1
            
            retPos.set( -xD, reticleY ); // position vector
            
            for ( let j = 0; j < 2; j ++ ) {
                
                markerPos.set( markerD0[ j ].position.x, markerD0[ j ].position.y );
                
                dist2 = markerPos.distanceToSquared( retPos );
                
                if ( dist2 < dMin2 ) {
                    
                    dMin2 = dist2;
                    jMin = j;
                    
                }
                
            }
            
            if ( dMin2 < 0.000225 ) {  // to squared  -->  dMin < 0.015
                
                idxD = jMin;
                
            }
            
        } else { // right, deformation of dn1  sections 
            
            retPos.set( xD, reticleY ); // position vector
            
            for ( let j = 0; j <= dn1 ; j ++ ) {
                
                markerPos.set( markerD[ j ].position.x, markerD[ j ].position.y );
                
                dist2 = markerPos.distanceToSquared( retPos );
                
                if ( dist2 < dMin2 ) {
                    
                    dMin2 = dist2;
                    jMin = j;
                    
                }
                
            }
            
            if ( dMin2 < 0.000225 ) {  // to squared  -->  dMin < 0.015
                
                idxD = jMin;
                txtIdxD.innerHTML = idxD;
                
            }
            
        }
        
    }
    
}

function onContainerDpointerMove( e ) {
    
    e.preventDefault( );
    
    if ( ready3D ) {
        
        reticleDm.visible = true; 
        
        getReticleD( e.clientY );
        
        const lr = key === 'nleft' ? -xD : xD; // left: basis cursor, right: deformation 
        
        reticleDm.position.set( lr, reticleY, 0 ); // reticle position only left or right on D
        
        coords.style.left = e.clientX + 15 + "px";
        coords.style.top = e.clientY - 10 + "px";
        
        coords.innerHTML = reticleY;
        
        const dn1 = vertMarkerCenabled[ apdIdx ][ vertIdx ] ? vertCoords[ apdIdx ][ vertIdx ].length - 1 : dnValue - 1; // edit : new
        
        // move left, basis deformation,  bottom 0  top 1
        if( key === 'nleft' && ( idxD === 0 || idxD === 1 ) && Math.abs( reticleY ) > 0.01) { 
            
            const valueY = Math.abs( reticleY );
            
            markerD0[ 0 ].position.set( lr, -valueY, 0 );
            markerD0[ 1 ].position.set( lr,  valueY, 0 );
            
            gBasisD.attributes.position.array[ 1 ] = -valueY;
            gBasisD.attributes.position.array[ 4 ] =  valueY;
            
            gBasisD.attributes.position.needsUpdate = true;
            
            for ( let i = 0; i <= dn1; i ++ ) { 
                
                const y = -valueY + valueY * 2 * i / dn1;
                
                gLinesD.attributes.position.array[ i * 6 + 1 ] = y;   //  + 1 left y
                
            }
            
            gLinesD.attributes.position.needsUpdate = true;
            
        }
        
        if( key === 'move' && idxD !== -1  ) { // move right, section deformation 
            
            if ( markerD[ idxD ] ) {
                
                markerD[ idxD ].position.set( lr, reticleY, 0 );
                
                gLinesD.attributes.position.array[ idxD * 6 + 4 ] = reticleY; // + 4 right y
                
                gLinesD.attributes.position.needsUpdate = true;
                
                txtIdxD.innerHTML = idxD;
                
            }
            
        }
        
    }
}

function onContainerDpointerUp( e ) {
    
    e.preventDefault( );
    
    if ( ready3D ) {
    
        idxD = -1; 
        key = '';
        txtIdxD.innerHTML = '';
        
    }
    
}

function onContainerDpointerLeave( e ) {
    
    if ( ready3D ) {
    
        reticleDm.visible = false;
        coords.innerHTML = '';
        
    }
    
}

// ... remove (reset), cancel, save ... container C and D , 
            
function onRemoveCDpointerUp( e ) {

    txtAngScale.innerHTML = '';
    
    if( ready3D && !vertEditing && !cutEditing ) {
        
        if( btmEditing ) {
            
            translateMarker.position.set( 0, 0, 0 );
            heightMarker.position.set( 0, -param[ apdIdx ].radius, 0 );
            openingMarker.position.set( 0, heightMarker.position.y, 0 );
            opngE.value = 0;
            
            capDataBtm[ apdIdx ] = [ 0, 0, 0, 0, 0, 0 ]
            
            btmIsPlane[ apdIdx ] = true; // first reset
            onBtm( );
            
            capC.checked = false;
            saveBtmTopC( );
            
            show3DSceneA( );
            btmIsPlane[ apdIdx ] = true; // second reset
            
        }
        
        if( topEditing ) {
            
            translateMarker.position.set( 0, 0, 0 );
            heightMarker.position.set( 0, param[ apdIdx ].radius, 0 );
            openingMarker.position.set( 0, heightMarker.position.y, 0 );
            opngE.value = 0;
            
            capDataTop[ apdIdx ] = [ 0, 0, 0, 0, 0, 0 ];
            
            topIsPlane[ apdIdx ] = true; // first reset          
            onTop( );
            
            capC.checked = false;
            saveBtmTopC( );
            
            show3DSceneA( );
            topIsPlane[ apdIdx ] = true; // second reset
            
        }
        
        if ( apdIdx > 0 ) visibilityAB( 'visible' ); // only appendices  delete
        
        
    } else if ( ready3D && cutEditing ) {
        
        if ( cutIdx !== 0 && cutIdx !== ( nCurvePtsB - 1 ) ) { // not bottom, top
            
            cutCoords[ apdIdx ][ cutIdx ] = [];
            cutMarkerLenabled[ apdIdx ][ cutIdx ] = false; 
            cutMarkerL[ cutIdx ].material.color.set( 0x00aa00 ); // reset color
            cutMarkerL[ cutIdx ].material.needsUpdate = true;
            
        } else { // remove impossible, set to slider values
            
            setCutToSliderValues( );
            
        }
        
        cutEditing = false;
        visibilityC( "hidden" );
        displaySomeAB( 'inline' );
        
        show3DSceneA( );
        
    } else if( ready3D && vertEditing ) {
        
        if ( vertIdx === 0 || ( vertIdx === nCurvePtsC / 2 ) ) {
            
            setVerticalReference( );  // remove impossible, set to slider values
            
 
        } else {
            
            vertCoords[ apdIdx ][ vertIdx ] = [];
            vertMarkerCenabled[ apdIdx ][ vertIdx ] = false; 
            vertMarkerC[ vertIdx ].material.color.set( 0x00aa00 ); // reset color
            vertMarkerC[ vertIdx ].material.needsUpdate = true;
            
            vertEditing = false;
            cutEditing = true;
            visibilityChangesCD( );
            
            show3DSceneA( );
            
        }
        
    }
    
}

function onCancelCDpointerUp( e ) {
    
    txtAngScale.innerHTML = '';
    
    if( ready3D && ( btmEditing || topEditing ) ) {
        
        if( btmEditing ) {
            
            btmCoords[ apdIdx ] = btmCoordsBak.slice( );
            btmEditing = false;
            
        }
        
        if( topEditing ) {
            
            topCoords[ apdIdx ] = topCoordsBak.slice( );
            topEditing = false;
            
        }
        
        visibilityC( "hidden" );
        displaySomeAB( 'inline' );
        
        if ( apdIdx > 0 ) visibilityAB( 'visible' ); // only appendices
        
        show3DSceneA( );
        
    } else if( ready3D && cutEditing && !onlyVert ) {
        
        if ( cutMarkerLenabled[ apdIdx ][ cutIdx ] ) {  // cancel edit cut 
            
            cutCoords[ apdIdx ][ cutIdx ] = cutCoordsBak.slice( );
            
        } else { // cancel new cut
            
            cutMarkerL[ cutIdx ].material.color.set( 0x00aa00 ); // reset color
            cutMarkerL[ cutIdx ].material.needsUpdate = true;
            
        }
        
        for ( let j = cnValue; j < cnmax; j ++ ) {
            
            markerC[ j ].visible = false;
            
        }
        
        cutEditing = false;
        visibilityC( "hidden" );
        displaySomeAB( 'inline' );
        
    } else if( ready3D && cutEditing && onlyVert ) {
    
        for ( let j = cnValue; j < cnmax; j ++ ) {
            
            markerC[ j ].visible = false;
            
        }
        
        cutEditing = false;
        visibilityC( "hidden" );
        displaySomeAB( 'inline' )    
        
        show3DSceneA( ); // only vertical:  EXIT like cancel
           
    } else if(  ready3D && vertEditing ) {
        
        if ( vertMarkerCenabled[ apdIdx ][ vertIdx ] ) {  // cancel edit vert 
            
            vertCoords[ apdIdx ][ vertIdx ] = vertCoordsBak.slice( );
            
            if( vertCoords[ apdIdx ][ vertIdx ].length === 0 ) { // after file load 
                
                 vertMarkerCenabled[ apdIdx ][ vertIdx ] = false;
                 vertMarkerC[ vertIdx ].material.color.set( 0x00aa00 ); // reset color   
                 vertMarkerC[ vertIdx ].material.needsUpdate = true;
                 
            }
            
        } else { // cancel new vert
            
            vertMarkerC[ vertIdx ].material.color.set( 0x00aa00 ); // reset color
            vertMarkerC[ vertIdx ].material.needsUpdate = true;
            
        }
        
        vertEditing = false;
        cutEditing = true;
        visibilityChangesCD( );
        
    }
    
}

function onSaveCDpointerUp( e ) {
            
    txtAngScale.innerHTML = '';
    
    if ( ready3D ) {
    
        if( btmEditing || topEditing ) saveBtmTopC( );
        if( cutEditing ) saveCutC( );
        if( vertEditing ) saveVertD( );
        
        if ( apdIdx === 0 ) {
            
            topCapMain.style.display = "inline";
            btmCapMain.style.display = "inline";
            
        }
        
        show3DSceneA( );
        
    }
    
}

function saveBtmTopC( ) {

    txtAngScale.innerHTML = '';
    
    const n = cnValue;
    
    let x, y, z;
    
    if ( btmEditing ) {
        
        btmCoords[ apdIdx ] = [];
        
        for ( let j = 0; j < n - 1; j ++ ) { //  -1 last equals first, closed
            
            btmCoords[ apdIdx ].push( markerC[ j ].position.x, markerC[ j ].position.y );
            
            x = cos( ( markerC[ j ].position.x  + 1 ) * pi );
            y = markerC[ j ].position.y;
            z = -sin( ( markerC[ j ].position.x  + 1 ) * pi );
            
            vPosC[ j ].set( x, y, z );
            
            ptsLineC.push( vPosC[ j ] );
            
        }
        
        btmIsPlane[ apdIdx ] = false;
        
        if( apdIdx === 0 ) {      
            
            capDataBtm[ 0 ][ 0 ] = capC.checked ? 1 : 0; // true: false
            
            if( capDataBtm[ 0 ][ 0 ] ) {
                
                capDataBtm[ 0 ][ 1 ] = -translateMarker.position.x,
                capDataBtm[ 0 ][ 2 ] = heightMarker.position.y,
                capDataBtm[ 0 ][ 3 ] = -translateMarker.position.y 
                capDataBtm[ 0 ][ 4 ] = openingMarker.position.x;
                capDataBtm[ 0 ][ 5 ] = parseInt( opngE.value );
                
            }
            
        }
        
    }
    
    if ( topEditing ) {
        
        topCoords[ apdIdx ] = [];
        
        for ( let j = 0; j < n - 1; j ++ ) { //  -1 last equals first, closed
            
            topCoords[ apdIdx ].push( markerC[ j ].position.x, markerC[ j ].position.y );
            
            x = cos( ( markerC[ j ].position.x  + 1 ) * pi );
            y = markerC[ j ].position.y;
            z = -sin( ( markerC[ j ].position.x  + 1 ) * pi );
            
            vPosC[ j ].set( x, y, z );
            
            ptsLineC.push( vPosC[ j ] );
            
        }
        
        topIsPlane[ apdIdx ] = false;
        
        capDataTop[ apdIdx ][ 0 ] = capC.checked ? 1 : 0; // true : false
        
        if ( capDataTop[ apdIdx ][ 0 ] ) {
            
            capDataTop[ apdIdx ][ 1 ] = -translateMarker.position.x;
            capDataTop[ apdIdx ][ 2 ] = heightMarker.position.y;
            capDataTop[ apdIdx ][ 3 ] = -translateMarker.position.y;
            capDataTop[ apdIdx ][ 4 ] = openingMarker.position.x ;
            capDataTop[ apdIdx ][ 5 ] = parseInt( opngE.value );
            
        }
        
    }
    
    romCurve= new CatmullRomCurve3( ptsLineC, true );
    
    div4 = n4( param[ apdIdx ].radius, triangleSide );
    detail = div4 * 4; // division of the circle 
    
    pointsC = romCurve.getSpacedPoints( detail * 2 );
    
    if ( btmEditing ) {
        
        let minValue = Infinity;
        
        for ( let j = 0; j < pointsC.length; j ++ ) {
            
            minValue = pointsC[ j ].y < minValue ? pointsC[ j ].y : minValue;
            
        }
        
        btmDiff[ apdIdx ] = []; // reset
        
        for ( let j = 0; j < pointsC.length; j ++ ) {
            
            btmDiff[ apdIdx ].push( minValue - pointsC[ j ].y );
            
        }
        
        btmEditing = false;
        
    }
    
    if ( topEditing ) {
        
        let maxValue = -Infinity;
        
        for ( let j = 0; j < pointsC.length; j ++ ) {
            
            maxValue = pointsC[ j ].y > maxValue ? pointsC[ j ].y : maxValue;
            
        }
        
        topDiff[ apdIdx ] = []; // reset
        
        for ( let j = 0; j < pointsC.length; j ++ ) {
            
            topDiff[ apdIdx ].push( pointsC[ j ].y - maxValue );
            
        }
        
        topEditing = false;
        
    }
    
    visibilityC( "hidden" );
    displaySomeAB( 'inline' );
    if ( apdIdx > 0 ) visibilityAB( 'visible' ); // only appendices
    
}

function saveCutC( ) {
    
    if ( cutMarkerLenabled[ apdIdx ][ cutIdx ] ) { // edited cut
        
        for ( let j = 0; j < cnValue; j ++ ) { // cutCoords:   [ x1,y1, x2,y2, .. ]
            
            cutCoords[ apdIdx ][ cutIdx ][ j * 2 ] = markerC[ j ].position.x;
            cutCoords[ apdIdx ][ cutIdx ][ j * 2 + 1 ] = markerC[ j ].position.y;
            
        }
          
    } else { // new cut 
        
        for ( let j = 0; j < cnValue; j ++ ) {
            
            cutCoords[ apdIdx ][ cutIdx ].push( markerC[ j ].position.x, markerC[ j ].position.y );
            
        }
        
        cutMarkerLenabled[ apdIdx ][ cutIdx ] = true;
                                    
        if ( cutIdx === 0 ) ccfb = false; //cut coordinates first bottom
        if ( cutIdx === nCurvePtsB - 1 ) ccft = false; //cut coordinates first top
        
    }
    
    for ( let j = cnValue; j < cnmax; j ++ ) {
        
        markerC[ j ].visible = false;
        
    }
    
    visibilityC( "hidden" );
    displaySomeAB( 'inline' );
    
    cutEditing = false;
    
}

function saveVertD( ) {
    
    const y0 = markerD0[ 0 ].position.y; // basis bottom
    const y1 = markerD0[ 1 ].position.y; // basis top
    const dy =  y1 - y0;
    vertBasis[ apdIdx ][ vertIdx ] = dy;
    
    if( vertMarkerCenabled[ apdIdx ][ vertIdx ] ) { // edit vertical
        
        for( let j = 0; j < vertCoords[ apdIdx ][ vertIdx ].length; j ++ ) {
            
            vertCoords[ apdIdx ][ vertIdx ][ j ] = ( markerD[ j ].position.y - y0 ) / dy;
            
        }
        
    } else { // new vertical
        
        for( let j = 0; j < dnValue; j ++ ) {
        
            vertCoords[ apdIdx ][ vertIdx ].push( ( markerD[ j ].position.y - y0 ) / dy );
            
        }
        
        vertMarkerCenabled[ apdIdx ][ vertIdx ] = true;
        
        if ( vertIdx === 0 ) vcf0 = false; // vertical coordinates first vertIdx 0
        if ( vertIdx === nCurvePtsC / 2 ) vcf1 = false; // vertical coordinates first vertIdx nCurvePtsC / 2
        
    }
    
    vertEditing = false;
    cutEditing = true;
    visibilityChangesCD( );
    
}

// ......... bottom, top edges...................................................

function onBtm( ) {

    if ( ready3D ) {
    
        txtoE.style.visibility = apdIdx === 0 ? 'visible' : 'hidden';
        opngE.style.visibility = apdIdx === 0 ? 'visible' : 'hidden';    
        capC.style.visibility = apdIdx === 0 ? 'visible' : 'hidden';
        txtCapC.style.visibility = apdIdx === 0 ? 'visible' : 'hidden';
        
        txtCapC.innerHTML = ( apdIdx === 0  ) ? 'with cap' : '';
        capC.checked = ( apdIdx === 0 ) && capDataBtm[ 0 ][ 0 ] ? true : false;
        
        btmCoordsBak = btmCoords[ apdIdx ].slice( );
        btmEditing = true;
        makeBtmTopCapEdges( btmCoords[ apdIdx ], btmIsPlane[ apdIdx ] );
        
        if( apdIdx === 0 ) { // only main apdIdx 0
            
            translateMarker.visible = true;
            heightMarker.visible = true;
            openingMarker.visible = true;
            
            if( capDataBtm[ 0 ][ 0 ] ) { 
                
                translateMarker.position.set( -capDataBtm[ 0 ][ 1 ], -capDataBtm[ 0 ][ 3 ], 0 );
                heightMarker.position.set( 0, capDataBtm[ 0 ][ 2 ], 0 );
                openingMarker.position.set( capDataBtm[ 0 ][ 4 ], heightMarker.position.y, 0 );
                opngE.value = capDataBtm[ 0 ][ 5 ];
                
            } else {
                
                translateMarker.position.set( 0, 0, 0 );
                heightMarker.position.set( 0, -param[ 0 ].radius, 0 );
                openingMarker.position.set( 0, heightMarker.position.y, 0 );
                opngE.value = 0;
                
            }
            
        } else {
            
            translateMarker.visible = false;
            heightMarker.visible = false;
            openingMarker.visible = false;
            
        }
    
    }
    
}

function onTop( ) { // main  apdIdx 0, appendices 1 ..

    if ( ready3D ) {
    
        txtoE.style.visibility = 'visible';
        opngE.style.visibility = 'visible'; 
        capC.style.visibility = 'visible';
        txtCapC.style.visibility = 'visible';
        
        txtCapC.innerHTML = 'with cap';
        capC.checked = capDataTop[ apdIdx ][ 0 ] ? true : false;    
        topCoordsBak = topCoords[ apdIdx ].slice( );
        topEditing = true;
        makeBtmTopCapEdges( topCoords[ apdIdx ], topIsPlane[ apdIdx ] );
        
        translateMarker.visible = true;
        heightMarker.visible = true;
        
        if( capDataTop[ apdIdx ][ 0 ] ) {
            
            translateMarker.position.set( -capDataTop[ apdIdx ][ 1 ], -capDataTop[ apdIdx ][ 3 ], 0 );
            heightMarker.position.set( 0, capDataTop[ apdIdx ][ 2 ], 0 );
            openingMarker.position.set( capDataTop[ apdIdx ][ 4 ], heightMarker.position.y, 0 );
            opngE.value = capDataTop[ apdIdx ][ 5 ];
            
        } else {
            
            translateMarker.position.set( 0, 0, 0 );
            heightMarker.position.set( 0, param[ apdIdx ].radius, 0 );
            openingMarker.position.set( 0, heightMarker.position.y, 0 );
            opngE.value = 0;
            
        }
        
    }
    
}

function makeBtmTopCapEdges( coords, isPlane ) {
    
    cutEditing = false;
    vertEditing = false;
    curveC.visible = true;
    curveLoopC.visible = false;
    
    visibilityC( "visible" );
    txtDirectionC.innerHTML = 'vertical';
    displaySomeAB( "none" );
    if ( apdIdx > 0 ) visibilityAB( 'hidden' ); // only appendices
    
    for ( let k = 0; k < nCurvePtsC; k ++ ) {
        
        vertMarkerC[ k ].visible = false;    
        
    }
     
    if( isPlane ) {
        
        cnValue = parseInt( cn.value ) + 1;  //  + 1: right marker identical left 
        
        for ( let k = 0; k < cnValue; k ++ ) {
            
            markerC[ k ].position.set( -1 + 2 * k / ( cnValue - 1 ), 0, 0 );
            markerC[ k ].visible = true;
            
        }
        
        for ( let k = cnValue ; k < cnmax; k ++ ) {
            
            markerC[ k ].visible = false;
            
        } 
        
    } else {
        
        cnValue = coords.length / 2 + 1; // right marker identical left
        
        for ( let k = 0; k < cnValue - 1; k ++ ) {
            
            markerC[ k ].position.set( coords[ k * 2 ], coords[ k * 2 + 1 ], 0 );
            markerC[ k ].visible = true;
        }
        
        markerC[ cnValue - 1 ].position.set( 1, coords[ 1 ], 0 ); //right equals left
        markerC[ cnValue - 1 ].visible = true;
        
        for ( let k = cnValue ; k < cnmax; k ++ ) {
            
            markerC[ k ].visible = false;
            
        }
        
    }
    
    updateCurveC( );
    
}

//........ import, export, output ...................................................

function onExportCDpointerUp( ) {
    
   if ( ready3D ) { 
        
        const ffd = Math.pow( 10, nDec.value );
        const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
        
        showOutput( );
        exportLines.value = '';
        
        out = '';
        
        if( btmEditing ) { // export bottom
            
            out += capC.checked ? 1 : 0  + ',';
            out += ( -translateMarker.position.x ) + ',' + heightMarker.position.y + ',' +  ( -translateMarker.position.y )+ ',';
            out += openingMarker.position.x + ',' + opngE.value + ','; 
            
            const n = btmIsPlane[ apdIdx ] ? cn.value : btmCoords[ apdIdx ].length / 2;
            
            for ( let j = 0; j < n; j ++ ) {
            
                out += round( markerC[ j ].position.x ) + ',' + round( markerC[ j ].position.y ) + ',';
                
            }
                
        } else if( topEditing ) { // export top
            
            out += capC.checked ? 1 : 0  + ',';
            out += ( -translateMarker.position.x ) + ',' + heightMarker.position.y + ',' +  ( -translateMarker.position.y )+ ',';
            out += openingMarker.position.x + ',' + opngE.value+ ',';
            
            const n = topIsPlane[ apdIdx ] ? cn.value : topCoords[ apdIdx ].length / 2;
            
            for ( let j = 0; j < n; j ++ ) {
                
                out += round( markerC[ j ].position.x ) + ',' + round( markerC[ j ].position.y ) + ',';
                
            }
            
        } else if( cutEditing ) { // export cutCoords, export shape C
            
            for ( let j = 0; j < cnValue; j ++ ) { // cutCoords:   x1,y1, x2,y2, ..  from markers C
                
                out += round( markerC[ j ].position.x ) + ',' + round( markerC[ j ].position.y ) + ',';
                
            }     
            
        } else if( vertEditing ) { // export vertCoords, export heights D
            
            const y0 = markerD0[ 0 ].position.y; // basis bottom
            const y1 = markerD0[ 1 ].position.y; // basis top
            const dy =  y1 - y0;        
            
            for ( let j = 0; j < dnValue; j ++ ) {
                
                out += round( ( markerD[ j ].position.y - y0 ) / dy ) + ','; // vertCoords  y1, y2, ..  from markers D
                
            }
    
            out += round( dy ); // basis exported after coordinates!
    
        }
        
        exportLines.value = out;
        
        exportLines.select( );
        
        if( toClpb.checked ) document.execCommand( "Copy" );
        
    }
    
}

function onImportCDpointerdownChange( ) { 
        
    if ( ready3D ) {
        
        const f = btmTopShapeHeightFileLoad.files[ 0 ];
        
        if ( f.type.match( /text.*/ ) ) {
            
            reader.readAsText( f );
            
            reader.onload =  e => {
                
                // separate by , values into array 
                
                if ( btmEditing ) {
                    
                    btmCoords[ apdIdx ] = e.target.result.match( /-?\d+(\.\d+)?/g ).map( Number );
                    capDataBtm[ apdIdx ] = btmCoords[ apdIdx ].splice( 0, 6 );
                    processLoadedBtmTopShapeHeight( btmEditing );
                    
                }
                
                if ( topEditing ) {
                    
                    topCoords[ apdIdx ] = e.target.result.match( /-?\d+(\.\d+)?/g ).map( Number );
                    capDataTop[ apdIdx ] =topCoords[ apdIdx ].splice( 0, 6 );
                    processLoadedBtmTopShapeHeight( topEditing );
                    
                }
                
                if ( cutEditing ) {
                    
                    cutCoords[ apdIdx ][ cutIdx ] = e.target.result.match( /-?\d+(\.\d+)?/g ).map( Number ); 
                    processLoadedBtmTopShapeHeight( cutEditing );
                    
                }
                
                if ( vertEditing ) {
                    
                    vertCoords[ apdIdx ][ vertIdx ] = e.target.result.match( /-?\d+(\.\d+)?/g ).map( Number );
                    processLoadedBtmTopShapeHeight( cutEditing );
                    
                }
                
            }
            
        } else {
            
            alert( "incorrect file type" );
            
        }
        
    }

}

function processLoadedBtmTopShapeHeight( ed ) {
    
    if( ed = btmEditing ) {
        
        capC.checked = capDataBtm[ apdIdx ][ 0 ] ? true : false; 
        
        if( capDataBtm[ apdIdx ][ 0 ] ) { 
            
            translateMarker.position.set( -capDataBtm[ apdIdx ][ 1 ], -capDataBtm[ apdIdx ][ 3 ], 0 );
            heightMarker.position.set( 0, capDataBtm[ apdIdx ][ 2 ], 0 );
            openingMarker.position.set( capDataBtm[ apdIdx ][ 4 ], heightMarker.position.y, 0 );
            opngE.value = capDataBtm[ apdIdx ][ 5 ];
            
        } else {
            
            translateMarker.position.set( 0, 0, 0 );
            heightMarker.position.set( 0, -param[ apdIdx ].radius, 0 );
            openingMarker.position.set( 0, heightMarker.position.y, 0 );
            opngE.value = 0;
            
        }
        
        cnValue = btmCoords[ apdIdx ].length / 2 + 1; // right marker identical left
        
        for ( let k = 0; k < cnValue - 1; k ++ ) {
            
            markerC[ k ].position.set( btmCoords[ apdIdx ][ k * 2 ], btmCoords[ apdIdx ][ k * 2 + 1 ], 0 );
            
        }
        
        markerC[ cnValue - 1 ].position.set( 1, btmCoords[ apdIdx ][ 1 ], 0 ); // right equals left
        
        for ( let k = 0; k < cnmax; k ++ ) {
            
             markerC[ k ].visible = k < cnValue ? true : false;
            
        }    
        
        updateCurveC( );
         
    }
    
    if( ed = topEditing ) {
        
        capC.checked = capDataTop[ apdIdx ][ 0 ] ? true : false; 
         
        if( capDataTop[ apdIdx ][ 0 ] ) { 
            
            translateMarker.position.set( -capDataTop[ apdIdx ][ 1 ], -capDataTop[ apdIdx ][ 3 ], 0 );
            heightMarker.position.set( 0, capDataTop[ apdIdx ][ 2 ], 0 );
            openingMarker.position.set( capDataTop[ apdIdx ][ 4 ], heightMarker.position.y, 0 );
            opngE.value = capDataTop[ apdIdx ][ 5 ];
            
        } else {
            
            translateMarker.position.set( 0, 0, 0 );
            heightMarker.position.set( 0, -param[ apdIdx ].radius, 0 );
            openingMarker.position.set( 0, heightMarker.position.y, 0 );
            opngE.value = 0;
            
        }
        
        cnValue = topCoords[ apdIdx ].length / 2 + 1; // right marker identical left
        
        for ( let k = 0; k < cnValue - 1; k ++ ) {
            
            markerC[ k ].position.set( topCoords[ apdIdx ][ k * 2 ], topCoords[ apdIdx ][ k * 2 + 1 ], 0 );
            
        }
        
        markerC[ cnValue - 1 ].position.set( 1, topCoords[ apdIdx ][ 1 ], 0 ); // right equals left
        
        for ( let k = 0; k < cnmax; k ++ ) {
            
             markerC[ k ].visible = k < cnValue ? true : false;
            
        }   
        
        updateCurveC( );
        
    }
    
    if( ed = cutEditing ) {
        
        processLoadedShape( );
        
    }
    
    if( ed = vertEditing ) {
        
        processLoadedHeight( );
        
    }
    
}

function key_s_loadShape( e ) {
    
    const f = shapeFileLoad.files[ 0 ];
    
    if ( f.type.match( /text.*/ ) ) {
        
        reader.readAsText( f );
        
        reader.onload =  e => { 
            
            // separate by , values into array
            cutCoords[ apdIdx ][ cutIdx ] = e.target.result.match( /-?\d+(\.\d+)?/g ).map( Number );
            
            processLoadedShape( );
            
        }
        
    } else {
        
        alert( "incorrect file type" );
        
    }
    
}

function processLoadedShape( ) {
    
    cutEditing = true;
    vertEditing = false;
    
    cnValue =  cutCoords[ apdIdx ][ cutIdx ].length / 2;
    
    for ( let k = 0; k < cnValue; k ++ ) {
    
        markerC[ k ].position.set( cutCoords[ apdIdx ][ cutIdx ][ k * 2 ], cutCoords[ apdIdx ][ cutIdx ][ k * 2  + 1 ], 0 );
        markerC[ k ].visible = true;
        
    }
    
    for ( let k = cnValue; k < cnmax; k ++ ) {
        
        markerC[ k ].visible = false;
        
    }
    
    cutMarkerLenabled[ apdIdx ][ cutIdx ] = true;
    isShape[ apdIdx ][ cutIdx ] = true;
    
    if( cutIdx !== 0 && cutIdx !== ( nCurvePtsB - 1 ) ) {
        
        cutMarkerL[ cutIdx ].material.color.set( 0xdd0000 );
        cutMarkerL[ cutIdx ].material.needsUpdate = true; 
        
    }
    
    cutCoordsBak = cutCoords[ apdIdx ][ cutIdx ].slice( );
    
    updateCurveC( );
    updateVerticalMarkersC( );
    
    visibilityD( "hidden" );
    
    visibilityC( "visible" );
    // change some, C
    directionC.style.visibility = "hidden";
    directionC.checked = false;
    txtDirectionC.style.visibility = "hidden";
    
    displaySomeAB( "none" );
    
}

function processLoadedHeight( ) {
    
    dbasValue = vertCoords[ apdIdx ][ vertIdx ].pop( );  // last value is basis 
    vertBasis[ apdIdx ][ vertIdx ] = dbasValue;
    
    dnValue = vertCoords[ apdIdx ][ vertIdx ].length;
    
    const db = dbasValue / 2; //  dbasValue  1 equals 100%
    
    let y = -db;
    
    for ( let k = 0; k < 2; k ++ ) { // bottom, top  left as basis
       
       markerD0[ k ].position.set( -xD, y, 0 );
       markerD0[ k ].visible = true;
       gBasisD.attributes.position.array[ k * 3 + 1 ] = y;
       
       y += 2 * db;
       
    }
    
    y = -db; // reset
    
    const dn1 = dnValue - 1;
    
    for ( let k = 0; k < dnValue; k ++ ) { // right, height values
        
        const y_ = y + vertCoords[ apdIdx ][ vertIdx ][ k ] * dbasValue;
        
        markerD[ k ].position.set( xD, y_, 0 );
        markerD[ k ].visible = true;
        
        const k6 = k * 6; 
        
        gLinesD.positions[ k6 + 1 ] = -db + 2 * db * k / dn1; // left
        gLinesD.positions[ k6 + 4 ] = y_;   // right     
        
    }
    
    for ( let k = dnValue; k < dnmax; k ++ ) {
        
        markerD[ k ].visible = false;
        
    }
    
    gLinesD.setDrawRange( 0, dnValue * 2 );
    
    gBasisD.attributes.position.needsUpdate = true;
    gLinesD.attributes.position.needsUpdate = true;
    
    vertMarkerCenabled[ apdIdx ][ vertIdx ] = true; 
    
    vertMarkerC[ vertIdx ].material.color.set( 0xdd0000 );
    vertMarkerC[ vertIdx ].material.needsUpdate = true;
    
    vertCoordsBak = vertCoords[ apdIdx ][ vertIdx ].slice( );
    
    cutEditing = false;
    vertEditing = true;
    visibilityD( "visible" );
    
}

function exportFigureBdata( ) {
    
    exportFigure( apdIdx );
    
}

function exportFigure( apdIdx ) {
    
    showOutput( );
    exportLines.value = '';
    
    out = '';
    
    collectBtmCap( apdIdx );
    out += ';'                  // separator 
    collectBtmCoords( apdIdx );
    out += ';'                  // separator
    collectTopCap( apdIdx );
    out += ';'                  // separator     
    collectTopCoords( apdIdx );
    out += ';'                  // separator
    collectCutCoords( apdIdx );
    out += ';'                  // separator to vertBasis and vertCoords
    collectVertCoords( apdIdx );   
    
    exportLines.value = out;
    
    exportLines.select( );
    
    if( toClpb.checked ) document.execCommand( "Copy" );
    
} 

function importFigureBdata( ) {
    
    importFigure( apdIdx );
    
}

function importFigure( apdIdx ) {
    
    const f = figureFileLoad.files[ 0 ];
    
    if ( f.type.match( /text.*/ ) ) {
        
        reader.readAsText( f );
        
        reader.onload = e => {
            
            const figParts = e.target.result.split( ';' ); // capDataBtm ; btmCoords ; capDataTop ; topCoords ; cutCoords ; vertCoords
            
            capDataBtm[ apdIdx ] = numbers( figParts[ 0 ].split( '|' ) )[ 0 ].slice( );
            btmCoords[ apdIdx ] = numbers( figParts[ 1 ].split( '|' ) )[ 0 ].slice( );
            capDataTop[ apdIdx ] = numbers( figParts[ 2 ].split( '|' ) )[ 0 ].slice( );
            topCoords[ apdIdx ] = numbers( figParts[ 3 ].split( '|' ) )[ 0 ].slice( );
            cutCoords[ apdIdx ] = numbers( figParts[ 4 ].split( '|' ) );
            vertCoords[ apdIdx ] = numbers( figParts[ 5 ].split( '|' ) );
            
            processCutVert( );
            
            btmIsPlane[ apdIdx ] = false;
            btmEditing = true;
            onBtm( );
            saveBtmTopC( );
            
            topIsPlane[ apdIdx ] = false;
            topEditing = true;
            onTop( );
            saveBtmTopC( );
            
            show3DSceneA( );
            
        }
       
    } else {
       
       alert( "incorrect file type" );
       
    }

}
           
function processCutVert( ) {
    
    for ( let i = 0; i < nCurvePtsB; i ++ ) {
        
        if ( cutCoords[ apdIdx ][ i ].length > 0 ) {
            
            cutMarkerLenabled[ apdIdx ][ i ] = true;
            isShape[ apdIdx ][ i ] = true;
            
        } else {
            
            cutMarkerLenabled[ apdIdx ][ i ] = false;
            isShape[ apdIdx ][ i ] = false;
            
        }
        
    }
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
    
        vertBasis[ apdIdx ][ j ] = undefined; // like initializeVertCoords(...
        
        vertMarkerCenabled[ apdIdx ][ j ] = vertCoords[ apdIdx ][ j ].length > 0 ? true : false;
 
    
        if( vertMarkerCenabled[ apdIdx ][ j ] ) {
            
            dbasValue = vertCoords[ apdIdx ][ j ].pop( ); // last value is basis 
            vertBasis[ apdIdx ][ j ] = dbasValue;
            
        }
        
    }
    
}

function collectBtmCap( apdIdx ) {
    
    if( apdIdx === 0 && capDataBtm[ 0 ][ 0 ] ) { //  with bottom cap, only main index 0
        
        out += 1 + ',';
        out += capDataBtm[ 0 ][ 1 ] + ',' + capDataBtm[ 0 ][ 2 ] + ',' + capDataBtm[ 0 ][ 3 ] + ',';
        out += capDataBtm[ 0 ][ 4 ] + ',' + capDataBtm[ 0 ][ 5 ] + ',';
            
    } else { 
            
        out += 0 + ',' + 0 + ',' + 0 + ',' + 0 + ',' + 0 + ',' + 0 + ','; // always 6 values ( also dummy for appendices )
          
    }
    
}

function collectBtmCoords( apdIdx ) {
    
    const ffd = Math.pow( 10, nDec.value );
    const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
    
    const n = btmIsPlane[ apdIdx ] ? cn.value : btmCoords[ apdIdx ].length / 2;
    
    for ( let j = 0; j < n; j ++ ) {
        
        out += round( btmCoords[ apdIdx ][ j * 2 ]  ) + ',' + round( btmCoords[ apdIdx ][ j * 2 + 1 ] ) + ',';
        
    }
    
}

function collectTopCap( apdIdx ) {
    
    if( capDataTop[ apdIdx ][ 0 ] ) { // with top cap, main and appendices 
        
        out += 1 + ',';
        out += capDataTop[ apdIdx ][ 1 ] + ',' + capDataTop[ apdIdx ][ 2 ] + ',' + capDataTop[ apdIdx ][ 3 ] + ',';
        out += capDataTop[ apdIdx ][ 4 ] + ',' + capDataTop[ apdIdx ][ 5 ] + ',';
            
    } else { 
            
        out += 0 + ',' + 0 + ',' + 0 + ',' + 0 + ',' + 0 + ',' + 0 + ','; // always 6 values
          
    }
    
}

function collectTopCoords( apdIdx ) {

    const ffd = Math.pow( 10, nDec.value );
    const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
    
    const n = topIsPlane[ apdIdx ] ? cn.value : topCoords[ apdIdx ].length / 2;
    
    for ( let j = 0; j < n; j ++ ) {
        
        out += round( topCoords[ apdIdx ][ j * 2 ]  ) + ',' + round( topCoords[ apdIdx ][ j * 2 + 1 ] ) + ',';
        
    }

}

function collectCutCoords( apdIdx ) {
    
    const ffd = Math.pow( 10, nDec.value );
    const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
    
    for ( let i = 0; i < nCurvePtsB; i ++ ) {
            
        if ( cutCoords[ apdIdx ][ i ].length > 0 ) {
            
            for ( let j = 0; j < cutCoords[ apdIdx ][ i ].length; j ++ ) {
                
                out += round( cutCoords[ apdIdx ][ i ][ j ] ) + ',';
                
            }
            
        } else {
            
            out += ',' // empty
            
        }
        
        if ( i < nCurvePtsB - 1 ) out += '|';
        
    }

}

function collectVertCoords( apdIdx ) {
    
    const ffd = Math.pow( 10, nDec.value );
    const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
    
    for ( let i = 0; i < nCurvePtsC; i ++ ) {
        
         if ( vertCoords[ apdIdx ][ i ].length > 0 ) {
            
            for ( let j = 0; j < vertCoords[ apdIdx ][ i ].length; j ++ ) {
                
                out += round( vertCoords[ apdIdx ][ i ][ j ] ) + ',';              
                
            }
            
            out += vertBasis[ apdIdx ][ i ];  // basis after coordinates
            
        } else {
            
            out += ',' // empty
            
        }
        
        if ( i < nCurvePtsC - 1 ) out += '|';
        
    }
    
}

function collectOut( ) {
    
    const ffd = Math.pow( 10, nDec.value );
    const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
    out = '';
    
    for ( let apdIdx = 0; apdIdx <= apdCount; apdIdx ++ ) { // appendix index:   main 0,  appendices 1 .. apdCount
        
        if ( apdIdx === 0 ) {
            
            out += 'D,';
            out += 'S,';
            out += ID.value !== '' ? ID.value + ',' : 0 + ',';
            out += scale + ',';
            out += triangleSide + ',';
            
        } else {
            
            out += param[ 0 ].holes[ apdIdx - 1 ][ 0 ] + ',';  // up%
            out += param[ 0 ].holes[ apdIdx - 1 ][ 1 ] + ',';  // φ°
            out += param[ 0 ].holes[ apdIdx - 1 ][ 2 ] + ',';  // r%
            out += param[ 0 ].holes[ apdIdx - 1 ][ 3 ] + ',';  // ⇕%
            out += param[ 0 ].holes[ apdIdx - 1 ][ 4 ] + ',';  // h%            
            
        }
        
        out += '|'                  // separator
        
        out += param[ apdIdx ].radius  + ',';
        out += param[ apdIdx ].height  + ',';
        out += nDraw[ apdIdx ] + ',';
        
        out += '+'                  // separator
        
        for ( let j = 0; j < nDraw[ apdIdx ] * 3; j += 3 ) {
            
          out += round( gLineA[ apdIdx ].positions[ j     ] ) + ',';
          out += round( gLineA[ apdIdx ].positions[ j + 1 ] ) + ',';
          out += round( gLineA[ apdIdx ].positions[ j + 2 ] ) + ',';
            
        }
        
        out += '+'                  // separator
        
        collectBtmCap( apdIdx );
        
        out += '+'                  // separator
        
        collectBtmCoords( apdIdx );
        
        out += '+'                  // separator         
        
        collectTopCap( apdIdx );
        
        out += '+'                  // separator
        
        collectTopCoords( apdIdx );
         
        out += '+'                  // separator
        
        collectCutCoords( apdIdx ); 
        
        out += '+'                  // separator
        
        collectVertCoords( apdIdx );
        
        if ( apdIdx < apdCount ) out += '[';  // separator
        
    }
    
} 
    
function exportFullDesign( ) {

    downloadGltf.style.display = 'none';
    
    showOutput( );
    exportLines.value = '';
    
    collectOut( );
   
    exportLines.value = out;
    
    exportLines.select( );
    
    if( toClpb.checked ) document.execCommand( "Copy" );
    
}

function importDesign( ) {
    
    let apd; // main 0 and appendices  1 ..
    let apdParts = [];
    
    onImportDesign = true;
    
    const f = fullDesignFileLoad.files[ 0 ];
    
    if ( f.type.match( /text.*/ ) ) {
        
        reader.readAsText( f );
        
        reader.onload = e => {
            
            apd = e.target.result.split( '[' );
            
            for ( let apdIdx = 0; apdIdx < apd.length; apdIdx ++ ) {
                
                apdParts.push( [] );
                
                apdParts[ apdIdx ] = apd[ apdIdx ].split( '+' );
                
            }
            
            if ( apdParts[ 0 ][ 0 ].substring( 0,4 ) === 'D,S,' ) {
                
	            processDesign( apdParts );
                
            } else {
                
                alert( ' No valid design file, please reload web page. ')
                
            }
            
       }
       
   } else {
       
       alert( ' Incorrect file type, please reload web page.' );
       
   } 
   
   
   
}

function processDesign( apdParts ) {
     
    let par = [];
    let glA = [];
    
    markerCountL = -1;
    markerCountR = -1;
    
    cutMarkerLenabled = [];
    isShape = [];
    vertMarkerCenabled = [];
    
    param[ 0 ].holes = [];
    
    apdCount = apdParts.length - 1;
    
    for ( let idx = 0; idx <= apdCount; idx ++ ) {
        
        // .......... reading in the values ..........
        
        par.push( [] ); 
        glA.push( [] );
        
        par[ idx ] = numbers( apdParts[ idx ][ 0 ].split( '|' ) );
        glA[ idx ] = numbers( apdParts[ idx ][ 1 ].split( '|' ) );
        capDataBtm[ idx ] = numbers( apdParts[ idx ][ 2 ].split( '|' ) )[ 0 ].slice( );
        btmCoords[ idx ] = numbers( apdParts[ idx ][ 3 ].split( '|' ) )[ 0 ].slice( );
        capDataTop[ idx ] = numbers( apdParts[ idx ][ 4 ].split( '|' ) )[ 0 ].slice( );
        topCoords[ idx ] = numbers( apdParts[ idx ][ 5 ].split( '|' ) )[ 0 ].slice( );
        cutCoords[ idx ] = numbers( apdParts[ idx ][ 6 ].split( '|' ) );
        vertCoords[ idx ] = numbers( apdParts[ idx ][ 7 ].split( '|' ) );
        
        // .......... process the values ..........
        
        cutMarkerLenabled.push( [] );
        isShape.push( [] );
        
        vertMarkerCenabled.push( [] );
        vertBasis.push( [] );
        
        apdIdx = idx; // set global appendix index for functions
        
        createLineAgeometry( );  // nDraw[ apdIdx ] is set to 0 ...
        
        if ( idx > 0 ) param.push( {} );
        
        param[ apdIdx ].radius = par[ apdIdx ][ 1 ][ 0 ];
        param[ apdIdx ].height = par[ apdIdx ][ 1 ][ 1 ];           
        
        nDraw[ apdIdx ] = par[ apdIdx ][ 1 ][ 2 ]; 
        
        initializePositionArrays( ); // to push [], values are overwritten
        
        initializeBtmTopDiff( ); 
        
        if ( apdIdx === 0 ) { // main
            
            ID.value = par[ apdIdx ][ 0 ][ 0 ];
            scale = par[ apdIdx ][ 0 ][ 1 ];
            triangleSide = par[ apdIdx ][ 0 ][ 2 ];
            
        } else { // appendices
            
            param[ 0 ].holes.push( [] );
            
            param[ 0 ].holes[ apdIdx - 1 ][ 0 ] = par[ apdIdx ][ 0 ][ 0 ]; // up%
            param[ 0 ].holes[ apdIdx - 1 ][ 1 ] = par[ apdIdx ][ 0 ][ 1 ]; // φ°
            param[ 0 ].holes[ apdIdx - 1 ][ 2 ] = par[ apdIdx ][ 0 ][ 2 ]; // r%
            param[ 0 ].holes[ apdIdx - 1 ][ 3 ] = par[ apdIdx ][ 0 ][ 3 ]; // ⇕%
            param[ 0 ].holes[ apdIdx - 1 ][ 4 ] = par[ apdIdx ][ 0 ][ 4 ]; // h%
            
            onlyHole.push( par[ apdIdx ][ 0 ][ 4 ] === 0 ? true : false );  // h% is 0
            
        }
        
        // for main 0 and appendices 1 .. 
        
        for ( let j = 0; j < nDraw[ apdIdx ]; j ++ ) {
            
            const j3 = j * 3;
            
            gLineA[ apdIdx ].positions[ j3     ] = glA[ apdIdx ][ 0 ][ j3     ];
            gLineA[ apdIdx ].positions[ j3 + 1 ] = glA[ apdIdx ][ 0 ][ j3 + 1 ];
            gLineA[ apdIdx ].positions[ j3 + 2 ] = glA[ apdIdx ][ 0 ][ j3 + 2 ];
            
        }
        
        gLineA[ apdIdx ].setDrawRange ( 0, nDraw[ apdIdx ] );
        
        gLineA[ apdIdx ].attributes.position.needsUpdate = true;
        
        processCutVert( );
        
        btmIsPlane[ apdIdx ] = false;
        btmEditing = true;
        onBtm( );
        saveBtmTopC( );
        
        topIsPlane[ apdIdx ] = false;
        topEditing = true;
        onTop( );
        saveBtmTopC( );
        
    }
    
    // ............ generation of main ............
    
    apdIdx = 0; // reset to main
    
    createLineAmain( ); // no line for appendices
    
    for ( let j = 0; j < nDraw[ apdIdx ]; j ++ ) {
        
        const j3 = j * 3;
        
        //  sync left
        gLineL.positions[ j3     ] = gLineA[ apdIdx ].positions[ j3 ] - 1;  // -1 left
        gLineL.positions[ j3 + 1 ] = gLineA[ apdIdx ].positions[ j3 + 1 ];
        gLineL.positions[ j3 + 2 ] = 0;
        
        gLineL.attributes.position.needsUpdate = true;
        
        markerCountL ++;
        markerBL[ j ] = new Sprite( matSpriteBlue );
        markerBL[ j ].position.x = gLineL.positions[ j3 ];
        markerBL[ j ].position.y = gLineL.positions[ j3 + 1 ];
        markerBL[ j ].scale.x = markerSize;
        markerBL[ j ].scale.y = markerSize;
        
        sceneB.add( markerBL[ j ] );
        
        // sync right
        gLineR.positions[ j3     ] = gLineA[ apdIdx ].positions[ j3 ] + 1 ;    // +1 right
        gLineR.positions[ j3 + 1 ] = -gLineA[ apdIdx ].positions[ j3 + 2 ];   
        gLineR.positions[ j3 + 2 ] = 0;
        
        gLineR.attributes.position.needsUpdate = true;
        
        markerCountR ++;
        markerBR[ j ] = new Sprite( matSpriteBlue );
        markerBR[ j ].position.x = gLineR.positions[ j3 ];
        markerBR[ j ].position.y = gLineR.positions[ j3 + 1 ];
        markerBR[ j ].scale.x = markerSize;
        markerBR[ j ].scale.y = markerSize;
        
        sceneB.add( markerBR[ j ] );       
        
    }
    
    gLineL.setDrawRange ( 0, nDraw[ apdIdx ] );
    gLineR.setDrawRange ( 0, nDraw[ apdIdx ] );
        
    for ( let j = 0; j < nCurvePtsB ; j ++ ) {
        
        cutMarkerL[ j ].position.set( gCurveL.positions[ j * 3 ] - 1, gCurveL.positions[ j * 3 + 1 ], 0 ); // -1 left
        
    }

    getSize( );
    
    initialMainRadius.value = Math.round( par[ apdIdx ][ 1 ][ 0 ] * 100000 ) / 1000;
    initialMainHeight.value = Math.round( par[ apdIdx ][ 1 ][ 1 ] * 100000 / 2 ) / 1000;
    
    updateCurveC( );  
        
    updateVerticalMarkersC( );
    
    help.innerHTML = "help";
    Hilfe.innerHTML = "Hilfe";
    
    displayMainRadiusHeight( );
    
    for ( let idx = apdCount; idx > -1; idx -- ) {
    
        apdIdx = idx;  
        nApd.value = apdIdx;
        useAppendix( ); //  to nApd.value
        
        updatePositionArrays( );
        
    }
    
    newApd.innerHTML = ' new appendix ' + ( apdCount + 1 );
    
    idxMoveL = -1;
    idxMoveR = -1;       
    idxHitL = -1;       
    idxHitR = -1;
    
    cutCoordsBak = [];
    
    onImportDesign = false;
    
    doubleEdges.checked = false;
    
    show3D( );
    
}

function exportJavaScript( ) {
    
    const ffd = Math.pow( 10, nDec.value );
    const round = ( x ) => ( Math.floor( x * ffd ) / ffd ); // round for output
    
    downloadGltf.style.display = 'inline';
    
    showOutput( );
    exportLines.value = "";
    
    const pc =  geometry.attributes.position.array.length;
    const ic =  geometry.index.array.length;
    
    const id = ID.value;
    
    let code;
    out = "";
    
    // --- generate JavaScript code ---
    
    out = "/*... indexed BufferGeometry  ID " + ID.value + " ... */ \n\n";
    
    out += "const geometry_" + ID.value + " = new BufferGeometry();\n";
    
    out += "geometry_" + ID.value + ".indices = new Uint32Array( [ ";
    
    for ( let i = 0; i < ic; i ++ ) {
        
        out += geometry.index.array[ i ];
        out += i < ic - 1  ? ", " : "";
        
        }
        
    out += " ] );\n";
    
    
    out += "geometry_" + ID.value + ".positions = new Float32Array( [ ";
    
    for ( let p = 0; p < pc ; p ++ ) {
        
        out += round( geometry.attributes.position.array[ p ] * exportFactor  );
        out += p < pc - 1  ? ", " : "";
        
    }
    
    out += " ] );\n";
    
    
    out += "geometry_" + ID.value + ".setIndex( new BufferAttribute( geometry_" + ID.value + ".indices, 1 ) );\ngeometry_" + ID.value + ".setAttribute( 'position', new BufferAttribute( geometry_" + ID.value + ".positions, 3 ) );\n";
    
    
    exportLines.value = out;
    
    exportLines.select( );
    
    if( toClpb.checked ) document.execCommand( "Copy" );
    
}

// ........... appendices .....................................................

function newAppendix( ) {
    
   if ( ready3D ) {
    
        apdApplied = false;
        
        displayApd( 'none' );
        
        btmTopCapDisplay( -1 ); // not displayed
        
        nApd.value = apdCount + 1 // param[ 0 ].holes.length + 1; // apends from 1 ..  ( main: index 0 )
        
        newApd.innerHTML = ' new appendix ' + ( apdCount + 2 ); // ' new appendix ' + ( parseInt( nApd.value ) + 1 ) ; 
    
        if( !cutEditing && ( parseInt( nApd.value ) === param[ 0 ].holes.length + 1 ) ) {
            
            apdTxt.innerHTML = ' ≫ appendix  ' + ( apdCount + 1 );
            apdInp.style.visibility = 'visible';
            
            cancelApd.style.display = 'inline';
            
            r.style.color = '#000000';
            h.style.color = '#000000';
            r.style.fontWeight = 'normal';
            h.style.fontWeight = 'normal';
            
            apdIdx = nApd.value;
            
            param[ 0 ].holes.push( [] );
            
            up.value = '';
            φ.value = '';
            r.value = ''; 
            str.value = '100';
            h.value = ''; // 0 only hole
            
            removeLinesMarkersLR( );
            resetLinesMarkersValues( );
            
            lineL.visible = false;
            lineR.visible = false;
            curveL.visible = false;
            curveR.visible = false;
            
            for ( let j = 0; j < nCurvePtsB; j ++ ) {
                
                cutMarkerL[ j ].visible = false;   
                
            }
            
        }
        
    }
    
}

function useAppendix( ) {
    
    const idx = parseInt( nApd.value );  // appendices from 1 ..  ( main: index 0 ) 
    
    if(  idx === 0 || param[ 0 ].holes[ idx - 1 ] ) {
            
        apdIdx = idx;
        
        if( idx === 0 ) {  // main 
            up.value = '';
            φ.value = '';   
            r.value = '';    
            str.value = '';   
            h.value = '';
            apdTxt.innerHTML = ' main ≫ ';
            apdInp.style.visibility = 'hidden';
                    
            setCutRadius( initialMainRadius.value );
            
            lineL.visible = true;
            lineR.visible = true;
            curveL.visible = true;
            curveR.visible = true;
            
            for ( let j = 0; j < nCurvePtsB; j ++ ) {
                
                cutMarkerL[ j ].visible = true;    
                
            }
            
        }
        
        if ( param[ 0 ].holes[ apdIdx - 1 ] ) {
            
            r.style.color = '#de0000';
            h.style.color = '#de0000';    
            r.style.fontWeight = 'bold';
            h.style.fontWeight = 'bold';
            
            up.value = Math.round( param[ 0 ].holes[ apdIdx - 1 ][ 0 ] * 100 ).toString( );
            
            φ.value = Math.round( param[ 0 ].holes[ apdIdx - 1 ][ 1 ] ).toString( );
            
            r.value = Math.round( param[ 0 ].holes[ apdIdx - 1 ][ 2 ] * 100 ).toString( );
            r_ = r.value; // to memorize;
            
            str.value = Math.round( param[ 0 ].holes[ apdIdx - 1 ][ 3 ] * 100 ).toString( );
            
            const hParam = Math.round( param[ 0 ].holes[ apdIdx - 1 ][ 4 ] * 100 / 2 ).toString( );
            h.value = onlyHole[ apdIdx - 1 ] ? 0 : hParam;
            h_ = h.value; // to memorize
            
            apdTxt.innerHTML = ' ≫ appendix ';
            apdInp.style.visibility = 'visible';
            
            setCutRadius( r.value );
            
            setLineCurveVisibility ( ); // to current appendix ( uses apdIdx - 1 )
            
        }
        
        removeLinesMarkersLR( );
        resetLinesMarkersValues( );
        
        // ... to global apdIdx ...
        
        restoreLinesMarkersLR( );
        updateCurvesLR( );
        updateCutMarkersL( );
        
        // ...........................
        
        cancelApd.style.display = 'none';
        deleteApd.style.display = idx !== 0  ?  'inline' : 'none';        
        btmTopCapDisplay( idx );
        
    } else {
            
        alert( idx + '  is an invalid appendix index - or the new appendix was not applied' );
        nApd.value = apdIdx;
        
    }
    
}

function applyAppendix( ) { 
    
    if ( ready3D ) {
    
        apdIdx= parseInt( nApd.value );  //  apends 1 ..   ( index main 0 => apply button is hidden ) 
        
        if( up.value === '' || φ.value === '' || r.value === '' || str.value === '' || h.value === '' ) {
        
        alert( ' a value is missing ' );
        apdApplied = false;
        
        } else if ( param[ 0 ].holes[ apdIdx - 1 ].length === 0 ) {  // new appendix
            
            // params for main geometry index 0
            param[ 0 ].holes[ apdIdx - 1 ].push( up.value / 100 );
            
            param[ 0 ].holes[ apdIdx - 1 ].push( φ.value * 1 );     //  * 1  string to float 
            
            param[ 0 ].holes[ apdIdx - 1 ].push( r.value / 100 );
            param[ 0 ].holes[ apdIdx - 1 ].push( str.value / 100 );
            
            const hParam = h.value / 100 * 2;
            
            param[ 0 ].holes[ apdIdx - 1 ].push( hParam  );
            
            onlyHole.push( hParam <= 0 ? true : false );
            
            r_ = r.value; // to memorize
            h_ = h.value; // to memorize
            
            apdCount ++;        // appendices from index 1 ..  ( 0 is main )
            
            // params for this apend
            
            param.push( {} );   
            
            param[ apdIdx ].radius = param[ 0 ].holes[ apdIdx - 1 ][ 2 ]; 
            param[ apdIdx ].height = param[ 0 ].holes[ apdIdx - 1 ][ 4 ]; 
            
            setCutRadius( r.value );
            renewFirstSettings( );
            
            btmIsPlane.push( true ); 
            topIsPlane.push( true );
            
            capDataBtm.push( [] );
            capDataTop.push( [] );
            
            btmCoords.push( [] );
            topCoords.push( [] );
            
            r.style.color = '#de0000';
            h.style.color = '#de0000';
            r.style.fontWeight = 'bold';
            h.style.fontWeight = 'bold';
            
            // ... to global apdIdx ... 
            
            createLineAgeometry( );
            // no line for appendices
            initializeLinesLRA( );
            updateCurvesLR( );
            
            initializeCutMarkersL( );
            initializeVerticalMarkersC( );
            
            initializeBtmTopDiff( );
            
            initializeBtmTopCoords( );
            
            initializeCutCoords( );
            initializeVertCoords( );
            
            initializePositionArrays( );
            
            // ...........................
            
            setLineCurveVisibility ( ); // to current appendix ( uses apdIdx - 1 ) 
            
            apdApplied = true;  
            cancelApd.style.display = 'none';
        
        } else { // edit appendix
            
            param[ 0 ].holes[ apdIdx - 1 ][ 0 ] = up.value/ 100;
            
            param[ 0 ].holes[ apdIdx - 1 ][ 1 ] = φ.value * 1;    //   * 1  string to float
            
            param[ 0 ].holes[ apdIdx - 1 ][ 2 ] = r.value / 100;
            param[ 0 ].holes[ apdIdx - 1 ][ 3 ] = str.value / 100;
            param[ 0 ].holes[ apdIdx - 1 ][ 4 ] = h.value / 100 * 2;
            
            setLineCurveVisibility ( ); // to current appendix ( uses apdIdx - 1 ) 
            
            apdApplied = true;
            cancelApd.style.display = 'none';
            
        }
        
        apdTxt.innerHTML = ' ≫ appendix  '; // reset 
        
        displayApd( 'inline');
        
        show3DSceneA( );
        
    }
    
}

function cancelAppendix( ) {
    
    if ( ready3D ) {
        
        newApd.innerHTML = ' new appendix ' + ( apdCount + 1 ); 
        nApd.value --;
        param[ 0 ].holes.pop( ); // push on newAppendix
        //onlyHole.pop( ); // not here, because push only with apply
        
        apdApplied = false;
        useAppendix( );
        
        displayApd( 'inline');
        
    }
    
}

function deleteAppendix( ) {
    
    if ( ready3D ) {
    
        const idx = parseInt( nApd.value );  // appendices from 1 ..  ( main: index 0 )
        deleteIdx = idx; // to prevent changes in the meantime
        
        visibilityAB( 'hidden' );
        show_3D.style.display = 'none';
        finishing.style.display = 'none';
        
        deleteMarkedAppendix.style.display = 'block'; // 'inline';
        
        meshDelete = new Mesh( geo[ idx ], materialDelete3D ); // geo: appendices from 1 ..  ( main: index 0 )
        sceneA.add( meshDelete );
        meshConDelete = new Mesh( geoCon[ idx ], materialConDelete3D ); // geoCon: appendices from 1 ..  ( index 0 dummy )
        sceneA.add( meshConDelete );
        
    }  
     
}

function noKeepAppendix( ) {
    
    sceneA.remove( meshDelete );
    sceneA.remove( meshConDelete );
    
    visibilityAB ( 'visible' );
    deleteMarkedAppendix.style.display = 'none';
    show_3D.style.display = 'block';
    finishing.style.display = 'inline';
    
}

function yesDeleteAppendix( ) {
    
    apdApplied = false;
    
    gLineA[ deleteIdx ].dispose( );
    gLineA.splice( deleteIdx, 1 );
    
    param[ 0 ].holes.splice( deleteIdx - 1, 1 );
    onlyHole.splice( deleteIdx - 1, 1 );
    nDraw.splice( deleteIdx - 1, 1 );
    
    param.splice( deleteIdx, 1 ); 
    cutCoords.splice( deleteIdx, 1 );
    vertCoords.splice( deleteIdx, 1 );
    vertBasis.splice( deleteIdx, 1 );
    
    xArr.splice( deleteIdx, 1 );
    yArr.splice( deleteIdx, 1 );
    zArr.splice( deleteIdx, 1 );
    
    apdCount --;
    
    newApd.innerHTML = ' new appendix ' + ( apdCount + 1 );
    
    visibilityAB ( 'visible' );
    deleteMarkedAppendix.style.display = 'none';
    show_3D.style.display = 'block';
    finishing.style.display = 'inline';
    
    nApd.value = 0;
    
    useAppendix( );
    
    sceneA.remove( meshDelete );
    sceneA.remove( meshConDelete );
    
    show3DSceneA( );
    
}
    
// ...... initialize .......................................................

function initializeBtmTopCoords( ) {
    
    for ( let k = 0; k <= cnDefault; k ++ ) {
        
        btmCoords[ apdIdx ].push( -1 + 2 * k / cnDefault, 0 );
        topCoords[ apdIdx ].push( -1 + 2 * k / cnDefault, 0 );
    }
    
} 

function initializeBtmTopDiff( ) {
    
    btmDiff.push( [] );
    topDiff.push( [] );
    
    for ( let k = 0; k < 1000; k ++ ) { // not too short for a start
        
        btmDiff[ apdIdx ].push( 0 );
        topDiff[ apdIdx ].push( 0 );
        
    }
    
}

function initializeCutCoords( ) {
    
    let x, y;
        
    let α = pi;
    
    cn.value = cnDefault;
    oncnChange( );
    
    cutCoords.push( [] );
    
    for ( let j = 0; j < nCurvePtsB; j ++ ) {
        
        cutCoords[ apdIdx ].push( [] );
        
    }
    
    // cutCoords:   [ x1,y1, x2,y2, .. ]  always needed for first and last index,  bottom and top
    
    for ( let k = 0; k < cnDefault; k ++ ) {  // set radius default for default number of markers
        
        if ( apdIdx === 0 ) { // main
            
            x = initialMainRadius.value / 100 * cos( α );
            y = initialMainRadius.value / 100 * sin( α );
            
        } else {
            
            x = parseFloat( r.value ) / 100 * cos( α );
            y = parseFloat( r.value ) / 100 * sin( α );
            
        }
        
        cutCoords[ apdIdx ][ 0 ].push( x, y );              // bottom 
        cutCoords[ apdIdx ][ nCurvePtsB - 1 ].push( x, y ); // top
        
        α += 2 * pi / cnDefault;
        
    }
    
}

function initializeVertCoords( ) {
    
    // vertCoords:   [ y1, y2, .. ] 
    vertCoords.push( [] );
    vertBasis.push( [] );
    
    for ( let k = 0; k < nCurvePtsC; k ++ ) {
        
        vertCoords[ apdIdx ].push( [] );
        vertBasis[ apdIdx ][ k ] = undefined; // only one value !
        
    }
    
    // first ( last is first,  curve is closed  )
    vertCoords[ apdIdx ][ 0 ].push( 0, 1 );
    vertBasis[ apdIdx ][ 0 ] = 1;
    
    vertCoords[ apdIdx ][ nCurvePtsC / 2 ].push( 0, 1 );
    vertBasis[ apdIdx ][  nCurvePtsC / 2 ] = 1;
    
}

function initializeLinesLRA( ) {  // initial main lines with 3 points 
    
    // initialMainHeight.value 100% ==> height is 2 ( radius 100% ==> diameter is2 )
    
    let lineYmin, lineYmax;
    
    if ( apdIdx === 0 ) { // main
        
        lineYmin = -initialMainHeight.value / 100; // height 100% equals 2 
        lineYmax =  initialMainHeight.value / 100;
        
    } else { // appendices 
        
        lineYmin = -h.value / 100;  // height 100% equals 2 
        lineYmax =  h.value / 100;
        
    }
    
    // ... left  ( sceneB, side view )
    markerCountL++;
    createMarkerL( markerCountL, -1, lineYmin );
    positionLineL( markerCountL, -1, lineYmin );
    
    markerCountL ++;
    createMarkerL( markerCountL, -1,  0 ); //   -1:  0, 0 is center of orthographic sceneB
    positionLineL( markerCountL, -1,  0 ); //   -1:  0, 0 is center of orthographic sceneB
    
    markerCountL ++;   
    createMarkerL( markerCountL, -1, lineYmax );
    positionLineL( markerCountL, -1, lineYmax );
    
    gLineL.setDrawRange( 0, markerCountL + 1 );
    
    // ... right ( sceneB, top view )
    
    markerCountR ++;    
    createMarkerR( markerCountR, 1, 0 ); //   1:  0, 0 is center of orthographic sceneB
    positionLineR( markerCountR, 1, 0 ); //   1:  0, 0 is center of orthographic sceneB
    
    markerCountR ++;
    createMarkerR( markerCountR, 1, 0 ); 
    positionLineR( markerCountR, 1, 0 );
    
    markerCountR ++;
    createMarkerR( markerCountR, 1, 0 );
    positionLineR( markerCountR, 1, 0 );
    
    gLineR.setDrawRange( 0, markerCountR + 1 );
    
    // ... perspective  ( sceneA )
    
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 ] = 0;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 + 1 ] = lineYmin;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 + 2 ] = 0;
    nDraw[ apdIdx ] ++;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 ] = 0;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 + 1 ] = 0;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 + 2 ] = 0;
    nDraw[ apdIdx ] ++;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 ] = 0;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 + 1 ] = lineYmax;
    gLineA[ apdIdx ].positions[ nDraw[ apdIdx ] * 3 + 2 ] = 0;
    nDraw[ apdIdx ] ++;
    gLineA[ apdIdx ].setDrawRange ( 0, nDraw[ apdIdx ] );
    
}

function initializeCutMarkersL( ) {
    
    cutMarkerLenabled.push( [] ); // new array for appendix
    isShape.push( [] ); // new array for appendix
    
    for ( let j = 0; j < nCurvePtsB ; j ++ ) {
        
        cutMarkerLenabled[ apdIdx ].push( false );
        isShape[ apdIdx ].push( false );
        cutMarkerL[ j ].position.set( gCurveL.positions[ j * 3 ] - 1, gCurveL.positions[ j * 3 + 1 ], 0 ); // -1 left
        
    }   
    
}

function initializeVerticalMarkersC( ) {
    
    vertMarkerCenabled.push( [] ); // new array for appendix
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
        vertMarkerCenabled[ apdIdx ].push( false );
        vertMarkerC[ j ].position.set( gCurveC.positions[ j * 3 ], gCurveC.positions[ j * 3 + 1 ], 0 );
        vertMarkerC[ j ].visible = true;
        
    }
    
}

function initializePositionArrays( ){
    
    xArr.push( [] );
    yArr.push( [] );
    zArr.push( [] );
    
    const r0 = apdIdx === 0 ? initialMainRadius.value / 100 : parseFloat( r.value ) / 100;
    const h0 = apdIdx === 0 ? initialMainHeight.value / 100 : parseFloat( h.value ) / 100;
        
    for ( let k = 0; k < nCurvePtsB; k ++  ) {
        
        xArr[ apdIdx ].push( [] ); // new row
        yArr[ apdIdx ].push( [] ); // new row
        zArr[ apdIdx ].push( [] ); // new row
        
        const y = k / ( nCurvePtsB - 1 ) * h0;
        
        for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
            const α = 2 * pi * j / nCurvePtsC; 
            const x = r0 * cos( α );
            const z = r0 * sin( α );
            
            xArr[ apdIdx ][ k ].push( -x );     // starts at  -x 
            yArr[ apdIdx ][ k ].push(  y );
            zArr[ apdIdx ][ k ].push( -z );     // starts at  z = 0
            
        }
        
        xArr[ apdIdx ][ k ][ nCurvePtsC ] = xArr[ apdIdx ][ k ][ 0 ]; // closed
        yArr[ apdIdx ][ k ][ nCurvePtsC ] = yArr[ apdIdx ][ k ][ 0 ]; // closed
        zArr[ apdIdx ][ k ][ nCurvePtsC ] = zArr[ apdIdx ][ k ][ 0 ]; // closed
        
    }
    
}

// ......... update  .......................................................

function updateCurvesLR( ) {
    
    ptsLineA = [];
    
    curvePointsA = [];
    
    for ( let j = 0; j < nDraw[ apdIdx ] * 3; j += 3 ) {
        
        ptsLineA.push( new Vector3( gLineA[ apdIdx ].positions[ j ], gLineA[ apdIdx ].positions[ j + 1 ], gLineA[ apdIdx ].positions[ j + 2 ] ) );
        
    }
    
    romCurve= new CatmullRomCurve3( ptsLineA, false );
    
    curvePointsA = romCurve.getSpacedPoints( nCurvePtsB - 1 ); // nCurvePtsB:  number of points and sprites     
      
    for ( let j = 0; j < nCurvePtsB; j ++ ) {
        
        gCurveL.positions[ j * 3     ] = curvePointsA[ j ].x;
        gCurveL.positions[ j * 3 + 1 ] = curvePointsA[ j ].y;
        gCurveL.positions[ j * 3 + 2 ] = 0;
        
        gCurveR.positions[ j * 3     ] =  curvePointsA[ j ].x;
        gCurveR.positions[ j * 3 + 1 ] = -curvePointsA[ j ].z;
        gCurveR.positions[ j * 3 + 2 ] = 0;
        
    }

    gCurveL.attributes.position.needsUpdate = true;
    gCurveR.attributes.position.needsUpdate = true;
    
} 

function updateCurveC( ) {
    
    ptsLineC = [];
    let n;
   
    if( btmEditing || topEditing ) {
        
        n = cnValue;
        let x, y, z, α;
        
        for ( let j = 0; j < n - 1; j ++ ) { //  -1 last equals first, closed
            
            x = cos( ( markerC[ j ].position.x  + 1 ) * pi );
            y = markerC[ j ].position.y;
            z = -sin( ( markerC[ j ].position.x  + 1 ) * pi );
            
            vPosC[ j ].set( x, y, z );
            
            ptsLineC.push( vPosC[ j ] );
            
        }
        
        romCurve= new CatmullRomCurve3( ptsLineC, true );
        
        pointsC = romCurve.getSpacedPoints( nCurvePtsC );
        
        for ( let j = 0; j < pointsC.length; j ++ ) { //
        
            x = ( 1 - atan2Pi( pointsC[ j ].x, pointsC[ j ].z ) / pi / 2 ) * 2 - 1;
             
            x = j === 0 ? -1 : x;
            
            gCurveC.positions[ j * 3     ] = x;
            gCurveC.positions[ j * 3 + 1 ] = pointsC[ j ].y;
            gCurveC.positions[ j * 3 + 2 ] = 0;
            
        }
        
        // last is first
         
        gCurveC.positions[ pointsC.length * 3     ] = 1;
        gCurveC.positions[ pointsC.length * 3 + 1 ] = pointsC[ 0 ].y;
        gCurveC.positions[ pointsC.length * 3 + 2 ] = 0;
         
        gCurveC.attributes.position.needsUpdate = true;
        
    } else if( cutEditing ) {
        
        if ( cutMarkerLenabled[ apdIdx ][ cutIdx ]  ) {
            
            n = cutCoords[ apdIdx ][ cutIdx ].length / 2;
            
        } else {
            
            n = cnValue;
            
        }
        
        for ( let j = 0; j < n; j ++ ) {
            
            vPosC[ j ].set( markerC[ j ].position.x, markerC[ j ].position.y, 0 );
            
            ptsLineC.push( vPosC[ j ] );
            
        }
        
        
        romCurve = new CatmullRomCurve3( ptsLineC, true );
        
        pointsC = romCurve.getSpacedPoints( nCurvePtsC );  // nCurvePtsC divisions and points 
        
        for ( let j = 0; j < nCurvePtsC; j ++ ) {
            
            gCurveC.positions[ j * 3     ] = pointsC[ j ].x;
            gCurveC.positions[ j * 3 + 1 ] = pointsC[ j ].y;
            gCurveC.positions[ j * 3 + 2 ] = 0;
            
        }
        
        gCurveC.attributes.position.needsUpdate = true;
        
    }
 
}

function updateCutMarkersL( ) {
     
    for ( let j = 0; j < nCurvePtsB; j ++ ) {
        
        if( !cutMarkerLenabled[ apdIdx ][ j ] || j === 0 || j === nCurvePtsB - 1 ) {
        
            cutMarkerL[ j ].material.color.set( 0x00aa00 );
            
        } else {
            
            cutMarkerL[ j ].material.color.set( 0xdd0000 );
            
        }
        
        cutMarkerL[ j ].material.needsUpdate = true;
        
        cutMarkerL[ j ].position.set( gCurveL.positions[ j * 3 ] - 1, gCurveL.positions[ j * 3 + 1 ], 0 ); // -1 left
        
    }
    
}

function updateVerticalMarkersC( ) {
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
        if( !vertMarkerCenabled[ apdIdx ][ j ] ) { //  ! is used    see updateCutMarkersL
            
            vertMarkerC[ j ].material.color.set( 0x00aa00 );
            
        } else {
            
            vertMarkerC[ j ].material.color.set( 0xdd0000 );
            
        }
        
        vertMarkerC[ j ].material.needsUpdate = true;
        
        vertMarkerC[ j ].position.set( gCurveC.positions[ j * 3 ], gCurveC.positions[ j * 3 + 1 ], 0 );
        
    }
    
}

function updatePositionArrays( ) {
    
    let x, y, z, a, r, h, q;
    let p = [];             // array of points, for CatmullRomCurve3
    
    let px = [];
    let pz = [];
    let ph = [];
    
    let pCxz = []; // array of cutCoords[ apdIdx ].length  arrays of nCurvePtsC cut points
    let pVy  = []; // array of vertCoords[ apdIdx ].length  arrays of nCurvePtsB heights y
    
    let px1 = []; // array of arrays of vertical x coordinates  
    let pz1 = []; // array of arrays of vertical z coordinates     
    let ph1 = []; // array of arrays of vertical heights 
    
    for ( let k = 0; k < nCurvePtsB; k ++ ) {
        
        pCxz.push( [] );
        
        if ( cutCoords[ apdIdx ][ k ].length > 0 ) {
            
            p = [];
            
            // cutCoords:   [ x1,z1, x2,z2, .. ]
            
            for ( let j = 0; j < cutCoords[ apdIdx ][ k ].length / 2; j ++ ) {
                
                x = cutCoords[ apdIdx ][ k ][ j * 2 ];
                z = cutCoords[ apdIdx ][ k ][ j * 2 + 1 ];
                
                p.push( new Vector3( x, 0, z ) );
                
            }
            
            pCxz[ k ] = new CatmullRomCurve3( p, true ).getSpacedPoints( nCurvePtsC );
            
        }
        
    }
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
        pVy.push( [] );
        
        const vclen = vertCoords[ apdIdx ][ j ].length;
        
        if( vclen > 0 ) {
            
            p = [];
            
            for( let k = 0; k < vclen; k ++ ) {
                
                q = k / (  vclen - 1 ); // q is normalized:  0 .. 1
                y = vertCoords[ apdIdx ][ j ][ k ];
                
                p.push( new Vector3( q, y, 0) );
                
            }
            
            pVy[ j ] = new CatmullRomCurve3( p, false ).getSpacedPoints( nCurvePtsB - 1 );
            
        }
        
    }
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
        px1.push( [] );
        pz1.push( [] );
        px = [];
        pz = [];
        
        for ( let k = 0; k < nCurvePtsB; k ++ ) {
            
            if( pCxz[ k ].length > 0 ) {
            
                q = k / (  nCurvePtsB - 1 ); // q is normalized:  0 .. 1
                
                x = pCxz[ k ][ j ].x;
                z = pCxz[ k ][ j ].z; 
                 
                a = atan2Pi( -x, -z ); // a = atan2Pi( z, x );  // three.js orthogonal camera 2D areas :  -x like x,  -z like y
                a = a > pi * 2 - 0.001 ? 0 : a; 
                r = sqrt( x * x + z * z );
                
                px.push( new Vector3( q, x, 0 ) );
                pz.push( new Vector3( q, z, 0 ) );
                
            }
            
        }
        
        px1[ j ] = new CatmullRomCurve3( px, false ).getSpacedPoints( nCurvePtsB - 1 );
        pz1[ j ] = new CatmullRomCurve3( pz, false ).getSpacedPoints( nCurvePtsB - 1 );
        
    }
    
    for ( let k = 0; k < nCurvePtsB; k ++ ) {
        
        ph1.push( [] );
        ph = [];
        
        for ( let j = 0; j < nCurvePtsC; j ++ ) {
            
            if( vertCoords[ apdIdx ][ j ].length > 0 ) {
                
                ph.push( new Vector3( px1[ j ][ k ].y, pVy[ j ][ k ].y, pz1[ j ][ k ].y ) ); 
                
            }
        }
        
        ph1[ k ] = new CatmullRomCurve3( ph, true ).getSpacedPoints( nCurvePtsC ); 
        
    }
    
    for ( let k = 0; k < nCurvePtsB; k ++ ) {
        
        for ( let j = 0; j < nCurvePtsC; j ++ ) {
            
            xArr[ apdIdx ][ k ][ j ] = -px1[ j ][ k ].y;   // starts at  -x 
            yArr[ apdIdx ][ k ][ j ] = ph1[ k ][ j ].y;            
            zArr[ apdIdx ][ k ][ j ] = -pz1[ j ][ k ].y;   // starts at  z = 0 
            
        }
        
        // copy border:  last angle 2*pi  <==    identical first 0 ( closed ) 
        xArr[ apdIdx ][ k ][ nCurvePtsC ] = xArr[ apdIdx ][ k ][ 0 ];
        yArr[ apdIdx ][ k ][ nCurvePtsC ] = yArr[ apdIdx ][ k ][ 0 ];
        zArr[ apdIdx ][ k ][ nCurvePtsC ] = zArr[ apdIdx ][ k ][ 0 ];
        
    }
  
}

// ........... remove, reset, restore...............................................

function removeLinesMarkersLR( ) { 
    
    //removeLineMarkersL
    for ( let i = 0; i < gLineL.positions.length / 3; i ++ ) {
        
        if( markerBL[ i ] ) {
            
            sceneB.remove( markerBL[ i ] );
            markerBL[ i ].geometry.dispose( );
            
        }
        
    }
    
    markerBL = [];  // clear array of line markers left 
    
    //removeLineMarkersR
    for ( let i = 0; i < gLineR.positions.length / 3; i ++ ) {
        
        if( markerBR[ i ] ) {
            
            sceneB.remove( markerBR[ i ] );
            markerBR[ i ].geometry.dispose( );
            
        }
        
    }
    
    markerBR = [];   // clear array of line markers right  
    
}

function resetLinesMarkersValues( ) {
    
    markerCountL = -1;
    markerCountR = -1;
    
    idxMoveL = -1;
    idxMoveR = -1;
    idxHitL = -1;
    idxHitR = -1;
    
    gLineL.setDrawRange( 0, 0 );
    gLineL.attributes.position.needsUpdate = true;
    gLineR.setDrawRange( 0, 0 );
    gLineR.attributes.position.needsUpdate = true;
    
}

function restoreLinesMarkersLR( ) {
    
    for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
        
        gLineL.positions[ i * 3     ] = gLineA[ apdIdx ].positions[ i * 3     ] - 1;  // -1 left
        gLineL.positions[ i * 3 + 1 ] = gLineA[ apdIdx ].positions[ i * 3 + 1 ]
        gLineL.positions[ i * 3 + 2 ] = 0;
        
        gLineR.positions[ i * 3     ] =  gLineA[ apdIdx ].positions[ i * 3     ] + 1;  // +1 right
        gLineR.positions[ i * 3 + 1 ] = -gLineA[ apdIdx ].positions[ i * 3 + 2 ]
        gLineR.positions[ i * 3 + 2 ] = 0;
        
    }
    
    gLineL.setDrawRange( 0, nDraw[ apdIdx ] );
    gLineL.attributes.position.needsUpdate = true;
    
    gLineR.setDrawRange( 0, nDraw[ apdIdx ] );
    gLineR.attributes.position.needsUpdate = true;

    for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
        
        createMarkerL( i, gLineL.positions[ i * 3 ], gLineL.positions[ i * 3 + 1 ] );
        
    }
    
    for( let i = 0; i < nDraw[ apdIdx ]; i ++ ) {
        
        createMarkerR( i, gLineR.positions[ i * 3 ], gLineR.positions[ i * 3 + 1 ] );
        
    }
    
    // -1 as start values
    
    idxMoveL = -1;
    idxMoveR = -1;
    idxHitL = -1;
    idxHitR = -1;
    markerCountL = nDraw[ apdIdx ] - 1;
    markerCountR = nDraw[ apdIdx ] - 1;
    
}



// ........... finishing ............................................................

function finishGeometry( ) {
   
    if ( ready3D ) {
        
        finish = true; 
        
        if ( doubleEdges.checked ) edgeInfo.style.display = 'block';
        
        askFinishing.style.display = 'none';
        finishing.style.display = 'none';
        No.style.display = 'none';
        nnnSave.style.display = 'none';
        exportDesign.style.display = 'none';
        
        visibilityAB( 'hidden' );
        displaySomeAB( 'none' );
        
        show_3D.style.display = 'none';
        useWorker.style.display = 'none';
        txtUseWorker.style.display = 'none';
        useWireframe.style.display = 'none';
        txtUseWireframe.style.display = 'none';
        doubleEdges.style.display = 'none';
        txtDoubleEdges.style.display = 'none';
        
        cutRadiusArea.style.display = 'none';
        cutCountArea.style.display = 'none';
        vertBasisArea.style.display = 'none';
        vertCountArea.style.display = 'none';
        
        dbas.style.display = 'none';
        dn.style.display = 'none';
        dbasShow.style.display = 'none';
        dnShow.style.display = 'none';
        
        singly.style.display = 'inline';
        txtSingly.style.display = 'inline';
        // undo.style.display = 'inline'; // if array length > 0
        detailClick.style.display = 'inline';
        txtDetailClick.style.display = 'inline';
        forth.style.display = 'inline';
        txtForth.style.display = 'inline';
        back.style.display = 'inline';
        txtBack.style.display = 'inline';
        detailFct.style.display = 'inline';
        txtDtlRadius.style.display = 'inline';
        dtlRadius.style.display = 'inline';
        txtDtlDepth.style.display = 'inline';
        dtlDepth.style.display = 'inline';
        
        //show3D( ); // two colors
        wire3D = false;  // always two colors
        show3DSceneA( );
        
        tubeGeo = new CustomTubeGeometry( 16, 400, true, true );  // call later: tubeGeo.morph( points, radius )
        tube = new Mesh( tubeGeo, matTube );
        
        sceneA.add( tube ); 
        fnsPts = [];
        
        detailFct.selectedIndex = '0'; // index 0:   linear
        dtlRadius.value = 1;
        dtlDepth.value = 1;
        
    }
    
}
 
function removeTubePoint( ) {
    
    sceneA.remove( p1Mesh ); 
    
    if ( fnsPts.length > 0 ) fnsPts.pop( );
     
    if ( fnsPts.length > 1 ) { 
        
        centerCurve = new CatmullRomCurve3( fnsPts, false );
        
        centerLen = centerCurve.getLength( );
        cPcount = Math.ceil( 4 * centerLen / ( dtl.radius / 100 ) );
        centerPoints = centerCurve.getSpacedPoints( cPcount );
        
        tubeGeo.morph( centerPoints, ( dtl.radius / 100 ) );        
        
    } else {
        
        const v0 = new Vector3( );
        tubeGeo.morph( [ v0, v0 ], 0 );
        
        fnsPts = [];
         
        tubeReady = true;
        
        singly.style.display = 'inline';
        txtSingly.style.display = 'inline';
        
    }
    
}

function endTubeCreation( ) { // change geometry positions
    
    if ( fnsPts.length > 1 ) { 
        
        const va = new Vector3( );
        const vb = new Vector3( );
        const vc = new Vector3( );
        
        const dir = new Vector3( );
        
        let x, fx;
        
        const attrPos = geometry.attributes.position;
        
        sceneA.remove( p1Mesh );
        
        stp = dtlStp.length;
        dtlStp.push( [] );
        let dMin2;
        
        for ( let i = 0; i < attrPos.count; i ++ ) {
            
            v.fromBufferAttribute( attrPos, i );
            dMin2 = Infinity;
            
            for ( let j = 0; j <= cPcount; j ++ ) {
                
                const dist2 = centerPoints[ j ].distanceToSquared( v );
                
                if ( dist2 < dMin2 ) dMin2 = dist2;
                
            }
            
            if ( dMin2 <= distance2 ) {
                
                dtlStp[ stp ].push( i, v.x, v.y, v.z ); // memorize => undo
                
                dir.fromBufferAttribute( geometry.attributes.normal, i ); // like singly.checked
                
                if ( back.checked ) dir.negate( );
                
                x = 1 - dMin2 / distance2 // 1 ... 0
                
                fx = getDetailFunction( selectDetailFct.value, dtl.depth / 100, x );
                
                dir.multiplyScalar( fx );
                
                attrPos.setXYZ( i, v.x + dir.x, v.y + dir.y, v.z + dir.z );
                
            }
            
        }
        
        ////// HELPER //////////////////////////////////////////////////////////////////////////
        // const helperTube = new vertexFaceNumbersHelper( cameraA, tube, 1, 0.004, 0xaa0000 );  // from THREEn.js
        ////// HELPER //////////////////////////////////////////////////////////////////////////
        
        const v0 = new Vector3( );
        tubeGeo.morph( [ v0, v0 ], 0 );
        
        fnsPts = [];
        
        attrPos.needsUpdate = true;
        
        undo.style.display = dtlStp.length > 0 ? 'inline' : 'none ';
        
        tubeReady = true;
        
        singly.style.display = 'inline';
        txtSingly.style.display = 'inline';
        
    }
    
}

function onUndoPointerUp ( ) {

    const attrPos = geometry.attributes.position;
    
    const step = dtlStp.pop( );
     
    for ( let i = 0; i < step.length / 4; i ++ ) {
        
        attrPos.setXYZ( step[ i * 4 ], step[ i * 4 + 1 ], step[ i * 4 + 2 ], step[ i * 4 + 3 ] );
        
    }
    
    attrPos.needsUpdate = true;
    
    undo.style.display = dtlStp.length > 0 ? 'inline' : 'none ';
    
}

function getDetailFunction( f, d, x ) {
    
    let fx;
    
    switch ( f ) {
        
        case '*':
            fx = d * x;
        break;
        
        case 'sqrt':
            fx = d * sqrt( x );
        break;
        
        case 'sin1':
            fx = d * sin( p2i * x );
        break;
        
        case 'sin2':
            fx = d * sin( pi * x );
        break;
        
        case 'sin3':
            fx = d * sin( 3 * p2i * x );
        break;
        
        case 'sin4':
            fx = d * sin( 2 * pi * x );
        break;
        
        case 'pow2':
            fx = d * Math.pow( x, 2 );
        break;
        
        case 'pow4':
            fx = d * Math.pow( x, 4 );
        break;
        
        case 'pow6':
            fx = d * Math.pow( x, 6 );
        break;
        
        case 'line2':
            fx = d * ( x < 0.5 ? 1.5 * x : 0.5 * x + 0.5 );
        break;
        
    }
    
    return fx;
    
}

// ........... key ...................................................................

function onWindowKeyDown( e ) {
    
    if ( e.keyCode === 32 )  key = 'saveDsgn';  // space   save design (backup)
    
    if ( e.keyCode === 68 )  key = 'delete';    // d  delete point: B
    if ( e.keyCode === 73 )  key = 'insert';    // i  insert point: B 
    if ( e.keyCode === 77 )  key = 'move';      // m  move point: B, C,  D right
    if ( e.keyCode === 78 )  key = 'nleft';     // n  move basis point:  D left n = 0,1
    
    if ( e.keyCode === 67 )  key = 'cutline';   // c  cutline:  B, new or edit
    if ( e.keyCode === 83 )  key = 'shape';     // s  load shape for cut: B , scale shape: C
    if ( e.keyCode === 82 )  key = 'remove';    // r  remove cut: B or vertical C
    
    if ( e.keyCode === 86 )  key = 'vertical';  // v  vertical distortion: B, C
    
    if ( e.keyCode === 84 )  key = 'translate'; // t  translate x,z of cap center:  C
    if ( e.keyCode === 72 )  key = 'height';    // h  height(y) of cap center:  C
    if ( e.keyCode === 79 )  key = 'opening';   // o  opening(y) radius of cap:  C
    
    if ( e.keyCode === 66 )  key = 'back';      // b  finishing, points back: A
    if ( e.keyCode === 70 )  key = 'forth';     // f  finishing, points forth: A 
    
    if ( e.keyCode === 80 )  key = 'point';     // p  finishing, set point: A
    if ( e.keyCode === 69 )  key = 'end';       // e  finishing, end tube creation: A
    
    if( !finish && key === 'saveDsgn' && ready3D ) {
    
        collectOut( );
        
        if ( firstDsgnSave ) {
            
            designBackupNumber = ( nnnSave.value[ 0 ] + nnnSave.value[ 1 ] + nnnSave.value[ 2 ] ) - 1;  // - 1  note parameter below
            
            No.style.display = 'none';
            nnnSave.style.display = 'none'; 
            firstDsgnSave = false;
            
        }
        
        saveDesign( out, ++ designBackupNumber );
        
    }
    
    if( finish && key === 'end' && !tubeReady ) endTubeCreation( );
    if( finish && key === 'remove' && !tubeReady ) removeTubePoint( );
    
}

function onWindowKeyUp( e ) {
    
    key = ''; // reset keyCode
    
}

// ...........get reticle, hit marker ..................................................

function getReticleB( ecX, ecY ) {  // ec   e.client
    
    reticleX = round( 100 * ( ecX/ widthB * 4 - 2 ) ) / 100;
    reticleY = round( 100 * ( -ecY / heightB * 2 + 1 ) ) / 100;

}

function getReticleC( ecX, ecY ) {     // ec   e.client
    
    reticleX = round( 100 * ( ( ecX - leftC ) / widthC * 2 - 1 ) ) / 100;
    reticleY = round( 100 * ( -ecY / heightC * 2 + 1 ) ) / 100;
    
}

function getReticleD( ecY ) {  // ec   e.client
    
    reticleY = round( 100 * ( -ecY / heightD * 2 + 1 ) ) / 100;
    
}

function hitMarkerL( idx ) {
    
    let hitL = false;
    
    let j = markerCountL * 3 + 3;
    
    while ( !hitL &&  j > 2  ) {
        
        j -= 3;
        
        if ( j !== idx ) {
            
            hitL = checkHitL( j );
            
        }
        
    }
    
    return hitL && ( j !== idx ) ? j : -1; // idxHitL
    
}

function hitMarkerR( idx ) {
    
    let hitR = false;
    
    let j = markerCountR * 3 + 3;
    
    while ( !hitR &&  j > 2  ) {
        
        j -= 3;
        
        if ( j !== idx ) {
            
            hitR = checkHitR( j );
            
        }
        
    }
    
    return hitR && ( j !== idx ) ? j : -1; // idxHitR 
    
}

function checkHitL( j ) {
    
    const epsilon = 0.005;
    let hitL;
    
    let    x0 = gLineL.positions[ j ] - epsilon;
    let    x1 = gLineL.positions[ j ] + epsilon;
    let    y0 = gLineL.positions[ j + 1 ] - epsilon;
    let    y1 = gLineL.positions[ j + 1 ] + epsilon;
    
    return hitL = ( reticleX > x0 ) && ( reticleX < x1 ) && ( reticleY > y0 ) && ( reticleY < y1 );
    
}

function checkHitR( j ) {
    
    const epsilon = 0.005;
    let hitR;
    
    let    x0 = gLineR.positions[ j ] - epsilon;
    let    x1 = gLineR.positions[ j ] + epsilon;
    let    y0 = gLineR.positions[ j + 1 ] - epsilon;
    let    y1 = gLineR.positions[ j + 1 ] + epsilon;
    
    return hitR = ( reticleX > x0 ) && ( reticleX < x1 ) && ( reticleY > y0 ) && ( reticleY < y1 );
    
}

// ............ create ............................................................

function createLineAgeometry( ) {
    
    nDraw[ apdIdx ] = 0;
    
    gLineA[ apdIdx ] = new BufferGeometry( );
    gLineA[ apdIdx ].positions = new Float32Array( maxPointsLines * 3 );
    gLineA[ apdIdx ].setAttribute( 'position', new BufferAttribute( gLineA[ apdIdx ].positions, 3 ).setUsage( DynamicDrawUsage ) );
    
}

function createLineAmain( ) {
      
    lineA[ 0 ] = new Line( gLineA[ 0 ], matLine );
    sceneA.add( lineA[ 0 ] ); 
       
}

function createDesignAreaB( ) {
    
    const gB2 = new BufferGeometry( );
    
    pos = [];
    
    for ( let i = 0; i < 10; i ++ ) {
        
        let j = ( i + 0.5 ) / 10;
        rasterPosPush( j );
        
    }
    
    gB2.lineCount = 60;
    
    gB2.positions = new Float32Array( gB2.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gB2.positions[ i ] = pos[ i ];
    
    gB2.setAttribute( 'position', new BufferAttribute( gB2.positions, 3 ) );
    
    const matB2 = new LineBasicMaterial( { color: 0xdddddd } );
    const gridB2 = new LineSegments( gB2, matB2 );
    sceneB.add( gridB2 );
    
    //.....
    const gB1 = new BufferGeometry( );
    
    pos = [];
    for ( let i = 1; i < 10; i ++ ) {
        
        let j = i / 10;
        rasterPosPush( j );
        
    }
    
    gB1.lineCount = 54;
    
    gB1.positions = new Float32Array( gB1.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gB1.positions[ i ] = pos[ i ];
    
    gB1.setAttribute( 'position', new BufferAttribute( gB1.positions, 3 ) );
    
    const matB1 = new LineBasicMaterial( { color: 0xcccccc } );
    const gridB1 = new LineSegments( gB1, matB1 );
    sceneB.add( gridB1 );
    
    //.....
    const gB0 = new BufferGeometry( );
    pos = [];
    pos.push( -2,   0, -0.1, -0.02, 0, -0.1 );    // horizontal
    pos.push( 0.02, 0, -0.1,  2,    0, -0.1 );
    pos.push( -1,  -1, -0.1, -1,    1, -0.1 );    // vertical
    pos.push(  1,  -1, -0.1,  1,    1, -0.1 );    
    
    gB0.lineCount = 4;
    
    gB0.positions = new Float32Array( gB0.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gB0.positions[ i ] = pos[ i ];
    
    gB0.setAttribute( 'position', new BufferAttribute( gB0.positions, 3 ) );
    
    const matB0 = new LineBasicMaterial( { color: 0x888888 } );
    const gridB0 = new LineSegments( gB0, matB0 );
    sceneB.add( gridB0 );
    
    //.....
    const gBsplit = new BufferGeometry( );
    gBsplit.positions = new Float32Array( 6 );
    gBsplit.positions[ 0 ] = gBsplit.positions[ 2 ] = gBsplit.positions[ 3 ] = gBsplit.positions[ 5 ] = 0;
    gBsplit.positions[ 1 ] = -1;
    gBsplit.positions[ 4 ] = 1;
    gBsplit.setAttribute( 'position', new BufferAttribute( gBsplit.positions, 3 ) );
    
    const matBsplit = new LineBasicMaterial( { color: 0xffffff } );
    const gridBsplit = new LineSegments( gBsplit, matBsplit );
    sceneB.add( gridBsplit );
    
    
    // detail function
    function rasterPosPush( j ){
        
        pos.push( -2, j, -0.1,  2, j, -0.1 );    // horizontal
        pos.push( -2, -j, -0.1,  2, -j, -0.1 );
        pos.push( -2+j, -1, -0.1,  -2+j, 1, -0.1 ); // vertical
        pos.push( -1+j, -1, -0.1,  -1+j, 1, -0.1 );
        pos.push(  1-j, -1, -0.1,   1-j, 1, -0.1 );
        pos.push(  2-j, -1, -0.1,   2-j, 1, -0.1 );
    }
    
}

function createMarkerL( count, reticleX, reticleY ) {
    
    if( !onlyHole[ apdIdx - 1 ] ) {
        
        markerBL[ count ] = new Sprite( matSpriteBlue );
        
        markerBL[ count ].position.x = reticleX;
        markerBL[ count ].position.y = reticleY;
        
        markerBL[ count ].scale.x = markerSize;
        markerBL[ count ].scale.y = markerSize;
        
        sceneB.add( markerBL[ count ] );
        
    }
    
}

function createMarkerR( count, reticleX, reticleY ) {
    
    if( !onlyHole[ apdIdx - 1 ] ) {
        
        markerBR[ count ] = new Sprite( matSpriteBlue );
        
        markerBR[ count ].position.x = reticleX;
        markerBR[ count ].position.y = reticleY;
        
        markerBR[ count ].scale.x = markerSize;
        markerBR[ count ].scale.y = markerSize;
        
        sceneB.add( markerBR[ count ] );
        
    }
    
}
 
function createLinesCurvesLR( ) {
    
    gLineL = new BufferGeometry( );
    gLineL.positions = new Float32Array( maxPointsLines * 3 );
    gLineL.setAttribute( 'position', new BufferAttribute( gLineL.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
    lineL = new Line( gLineL, matLine );
    sceneB.add( lineL );
    
    gLineR = new BufferGeometry( );
    gLineR.positions = new Float32Array( maxPointsLines * 3 );
    gLineR.setAttribute( 'position', new BufferAttribute( gLineR.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
    lineR = new Line( gLineR, matLine );
    sceneB.add( lineR );
    
    gCurveL = new BufferGeometry( );
    gCurveL.positions = new Float32Array( nCurvePtsB * 3 );
    gCurveL.setAttribute( 'position', new BufferAttribute( gCurveL.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
    curveL = new Line( gCurveL, matCurve );
    sceneB.add( curveL );
    
    gCurveR = new BufferGeometry( );
    gCurveR.positions = new Float32Array( nCurvePtsB * 3 );
    gCurveR.setAttribute( 'position', new BufferAttribute( gCurveR.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
    curveR = new Line( gCurveR, matCurve );
    sceneB.add( curveR )
    
    curveL.position.x = -1;
    curveR.position.x =  1;
    
}

function createCutMarkersL( ) {
    
    for ( let j = 0; j < nCurvePtsB; j ++ ) {
        
        cutMarkerL[ j ] = new Sprite( matSpriteGreen.clone( ) ); // Note: color change!
        
        cutMarkerL[ j ].scale.x = 0.012;
        cutMarkerL[ j ].scale.y = 0.012;
        
        sceneB.add( cutMarkerL[ j ] );
        
    }
    
}

function createCurveC( ) {
    
    gCurveC = new BufferGeometry( );
    gCurveC.positions = new Float32Array( nCurvePtsC * 3 );
    gCurveC.setAttribute( 'position', new BufferAttribute( gCurveC.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
    curveLoopC = new LineLoop( gCurveC, matCurve );   //  for cut
    curveC = new Line( gCurveC, matCurve );           //  for cap
    
    sceneC.add( curveLoopC );
    sceneC.add( curveC );
    
}

function createDesignAreaC( ) {
    
    const gC2 = new BufferGeometry( );
    
    pos = [];
    
    for ( let i = 0; i < 10; i ++ ) {
        
        let j = ( i + 0.5 ) / 10;
        rasterPosPush( j );
        
    }
    
    gC2.lineCount = 40;
    
    gC2.positions = new Float32Array( gC2.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gC2.positions[ i ] = pos[ i ];
    
    gC2.setAttribute( 'position', new BufferAttribute( gC2.positions, 3 ) );
    
    const matC2 = new LineBasicMaterial( { color: 0xdddddd} );
    const gridC2 = new LineSegments( gC2, matC2 );
    sceneC.add( gridC2 );
    
    //.....    
    const gC1 = new BufferGeometry( );
    
    pos = [];
    for ( let i = 0; i <= 10; i ++ ) {
        
        let j = i / 10;
        rasterPosPush( j );
        
    }
    
    gC1.lineCount = 40;
    
    gC1.positions = new Float32Array( gC1.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gC1.positions[ i ] = pos[ i ];
    
    gC1.setAttribute( 'position', new BufferAttribute( gC1.positions, 3 ) );
    
    const matC1 = new LineBasicMaterial( { color: 0xbbbbbb } );
    const gridC1 = new LineSegments( gC1, matC1 );
    sceneC.add( gridC1 );    
    
        //.....
    const gCaxes = new BufferGeometry( );
    gCaxes.positions = new Float32Array( 12 );
    gCaxes.positions[ 0 ] = gCaxes.positions[ 2 ] = gCaxes.positions[ 3 ] = gCaxes.positions[ 5 ] = 0;
    gCaxes.positions[ 7 ] = gCaxes.positions[ 8 ] = gCaxes.positions[ 10 ] = gCaxes.positions[ 11 ] = 0;
    gCaxes.positions[ 1 ] = gCaxes.positions[ 6 ] = -1;
    gCaxes.positions[ 4 ] = gCaxes.positions[ 9 ] = 1;
    
    gCaxes.setAttribute( 'position', new BufferAttribute( gCaxes.positions, 3 ) );
    
    const matCaxes = new LineBasicMaterial( { color: 0x666666 } );
    const gridCaxes = new LineSegments( gCaxes, matCaxes );
    sceneC.add( gridCaxes );
    
    
      // detail function
    function rasterPosPush( j ){
    
        pos.push( -1,    j, -0.1,   1,   j, -0.1 );    // horizontal
        pos.push( -1,   -j, -0.1,   1,  -j, -0.1 );
        pos.push( -1+j, -1, -0.1,  -1+j, 1, -0.1 ); // vertical
        pos.push(  1-j, -1, -0.1,   1-j, 1, -0.1 );
        
    }
    
}

function createMarkersC( ) {
    
    for ( let i = 0; i < cnmax; i ++ ) { // max markers C
        
        markerC.push( new Sprite( matSpriteBlue ) );
        markerC[ i ].scale.x = 0.012;
        markerC[ i ].scale.y = 0.012;
        markerC[ i ].visible = false;
        sceneC.add( markerC[ i ] );        
         
    }
    
}

function createVerticalMarkersC( ) {
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
        vertMarkerC[ j ] = new Sprite( matSpriteGreen.clone( ) ); // Note: color change!
        vertMarkerC[ j ].scale.x = 0.012;
        vertMarkerC[ j ].scale.y = 0.012;
        sceneC.add( vertMarkerC[ j ] );
        
    }
    
}

function createCapCenterMarkersC( ) {
    
    translateMarker = new Sprite( matSpriteRed );
    translateMarker.scale.x = 0.017;
    translateMarker.scale.y = 0.017;
    translateMarker.position.set( 0, 0, 0 );
    sceneC.add( translateMarker );
    
    openingMarker = new Sprite( matSpriteGreen );
    openingMarker.scale.x = 0.025;
    openingMarker.scale.y = 0.025;
    openingMarker.position.set( 0, 0, 0 );
    sceneC.add( openingMarker );
    
    // lies over others
    heightMarker = new Sprite( matSpriteMagenta );
    heightMarker.scale.x = 0.017;
    heightMarker.scale.y = 0.017;
    heightMarker.position.set( 0, 0, 0 );
    sceneC.add( heightMarker );
    
}

function createDesignAreaD( ) {
    
    const gD2 = new BufferGeometry( );
    
    pos = [];
    
    for ( let i = 0; i < 10; i ++ ) {
        
        let j = ( i + 0.5 ) / 10;
        rasterPosPush( j );
        
    }
    
    gD2.lineCount = 40;
    
    gD2.positions = new Float32Array( gD2.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gD2.positions[ i ] = pos[ i ];
    
    gD2.setAttribute( 'position', new BufferAttribute( gD2.positions, 3 ) );
    
    const matD2 = new LineBasicMaterial( { color: 0xdddddd} );
    const gridD2 = new LineSegments( gD2, matD2 );
    sceneD.add( gridD2 );
    
    //.....
    
    const gD1 = new BufferGeometry( );
    
    pos = [];
    for ( let i = 0; i <= 10; i ++ ) {
        
        let j = i / 10;
        rasterPosPush( j );
        
    }
    
    gD1.lineCount = 40;
    
    gD1.positions = new Float32Array( gD1.lineCount * 6 );
    
    for ( let i = 0; i < pos.length; i ++ )    gD1.positions[ i ] = pos[ i ];
    
    gD1.setAttribute( 'position', new BufferAttribute( gD1.positions, 3 ) );
    
    const matD1 = new LineBasicMaterial( { color: 0xbbbbbb } );
    const gridD1 = new LineSegments( gD1, matD1 );
    sceneD.add( gridD1 );
    
    // ...
    
    const points = [ new Vector3( -0.1, 0, -0.1 ), new Vector3( 0.1, 0, -0.1 ) ];
    const mat0 = new LineBasicMaterial( { color: 0x555555 } );
    const line0 = new Line( new BufferGeometry().setFromPoints( points ), mat0 );
    sceneD.add( line0 );
    
    
    // detail function
    function rasterPosPush( j ){
        
        pos.push( -0.09,  j, -0.1, 0.09,  j, -0.1 );    // horizontal
        pos.push( -0.09, -j, -0.1, 0.09, -j, -0.1 );
        
    }
 
}

function createMarkersD( ) {
    
    for ( let i = 0; i < 2; i ++ ) { // bottom, top  left as basis
        
        markerD0.push( new Sprite( matSpriteBlue ) ); 
        markerD0[ i ].scale.x = 0.022;
        markerD0[ i ].scale.y = 0.014;
        markerD0[ i ].visible = false;
        sceneD.add( markerD0[ i ] );  
        
    }
    
    for ( let i = 0; i < dnmax; i ++ ) { // max markers D, right 
        
        markerD.push( new Sprite( matSpriteBlue ) );
        markerD[ i ].scale.x = 0.012;
        markerD[ i ].scale.y = 0.012;
        markerD[ i ].visible = false;
        sceneD.add( markerD[ i ] );      
        
    }
    
}

function createBasisLineD( ) {
    
    gBasisD = new BufferGeometry( );
    gBasisD.positions = new Float32Array( 6 );
    gBasisD.setAttribute( 'position', new BufferAttribute( gBasisD.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
     // left, vertical
    gBasisD.positions[ 0 ] = -xD;
    gBasisD.positions[ 1 ] = -dbasDefault / 100; // bottom
    gBasisD.positions[ 2 ] =  0;
    
    gBasisD.positions[ 3 ] = -xD;
    gBasisD.positions[ 4 ] =  dbasDefault / 100; // top
    gBasisD.positions[ 5 ] =  0;
    
    const basisLine = new Line( gBasisD, matLine );
    sceneD.add( basisLine );
    
}

function createLinesD( ) {   
     
    gLinesD = new BufferGeometry( );
    gLinesD.positions = new Float32Array( dnmax * 6 );
    gLinesD.setAttribute( 'position', new BufferAttribute( gLinesD.positions, 3 ).setUsage( DynamicDrawUsage ) );
    
    for ( let i = 0; i < dnmax; i ++ ) {
     
        const i6 = i * 6;
        
        gLinesD.positions[ i6     ] = -xD; 
        gLinesD.positions[ i6 + 1 ] = 0;    // pre-assignment with height y = 0
        gLinesD.positions[ i6 + 2 ] = 0;   
        
        gLinesD.positions[ i6 + 3 ] = xD; 
        gLinesD.positions[ i6 + 4 ] = 0;    // pre-assignment with height y = 0 
        gLinesD.positions[ i6 + 5 ] = 0 ;
        
    }
    
    linesD = new LineSegments( gLinesD, matCurve );               
    sceneD.add( linesD );
    
}

function createReticles( ) {
    
    gReticle = new BufferGeometry( );
    gReticle.positions = new Float32Array( 4 * 3 );
    
    gReticle.positions[  0 ] = 0;
    gReticle.positions[  1 ] = -0.02;
    gReticle.positions[  2 ] = 0;
    
    gReticle.positions[  3 ] = 0;
    gReticle.positions[  4 ] = 0.02;
    gReticle.positions[  5 ] = 0;
    
    gReticle.positions[  6 ] = -0.02;
    gReticle.positions[  7 ] = 0;
    gReticle.positions[  8 ] = 0;
    
    gReticle.positions[  9 ] = 0.02;
    gReticle.positions[ 10 ] = 0;
    gReticle.positions[ 11 ] = 0;
    
    gReticle.setAttribute( 'position', new BufferAttribute( gReticle.positions, 3 ) );
    
    const matReticle = new LineBasicMaterial( { color: 0xff0000 } ); // red
    reticleBh = new LineSegments( gReticle, matReticle );    // B hit
    reticleBh.scale.set( 2, 2, 0)
    sceneB.add( reticleBh );
    reticleBh.visible = false;
    
    const matReticleBm = new LineBasicMaterial( { color: 0x444444 } );
    reticleBm = new LineSegments( gReticle, matReticleBm );  // B move
    sceneB.add( reticleBm );
    reticleBm.visible = true;
    
    const matReticleCm = new LineBasicMaterial( { color: 0x666666 } );
    reticleCm = new LineSegments( gReticle, matReticleCm );  // C move
    sceneC.add( reticleCm );
    
    const matReticleDm = new LineBasicMaterial( { color: 0x333333 } );
    reticleDm = new LineSegments( gReticle, matReticleDm );  // D move
    sceneD.add( reticleDm );
    
}

// ......... style ... display, visibility ................................................................. 

function displayApd( ni ) {
    
    show_3D.style.display = ni;
    nApd.style.display = ni;
    expand.style.display = ni;
    expansion.style.display = ni;
    importFigureB.style.display = ni;
    exportFigureB.style.display = ni;
    btmCapApd.style.display = ni;
    topCapApd.style.display = ni;
    deleteApd.style.display = ni;

} 

function btmTopCapDisplay( idx ) {
    
    if(  idx === 0 ) {
        
        btmCapMain.style.display = 'inline';
        topCapMain.style.display = 'inline';
        
    } else {
        
        btmCapMain.style.display = 'none'; 
        topCapMain.style.display = 'none'; 
        
    }
    
}

function visibilityAB( vh ) {
    
    partsB.style.visibility = vh;
    apdInp.style.visibility = vh;
    deleteApd.style.visibility = vh;
    areaB.style.visibility = vh;
    areaAB.style.visibility = vh;
    
}

function displaySomeAB( ni ) {
    
    show_3D.style.display = ni;
    
    expand.style.display = ni;
    expansion.style.display = ni;
    importFigureB.style.display = ni;
    exportFigureB.style.display = ni;
    newApd.style.display = ni;
    cr.style.display = ni;
    cn.style.display = ni;
    crShow.style.display = ni;
    cnShow.style.display = ni;
    nApd.style.display = ni;
    
    if ( apdIdx === 0 ) { // main
        
        topCapMain.style.display = ni;
        btmCapMain.style.display = ni;
        
    } else { 
        
        topCapMain.style.display = 'none'; // hide for appendices 
        btmCapMain.style.display = 'none';   
        
        apdInp.style.display = ni;
        
    }
    
}

function visibilityC( vh ) {
    
    containerC.style.visibility = vh;
    partsC.style.visibility = vh;
    
    sliderC.style.visibility = vh;
    directionC.style.visibility = vh;
    txtDirectionC.style.visibility = vh;
    
    importCD.style.visibility = vh;
    exportCD.style.visibility = vh;
    removeCD.style.visibility = vh;
    cancelCD.style.visibility = vh;
    saveCD.style.visibility = vh;
    
    if( ( vh === "visible" ) && cutEditing ) {
        
        txtImport.innerHTML = 'import ▦';
        txtExport.innerHTML = 'export ▦';
        txtRemove.innerHTML = 'remove ▦';
        txtCancel.innerHTML = 'cancel ▦';
        txtSave.innerHTML   = 'save  ▦';
        
    }
    
    if( ( vh === "visible" ) && btmEditing  ) {
        
        txtImport.innerHTML = 'import  ◡';
        txtExport.innerHTML = 'export  ◡';
        txtRemove.innerHTML = 'reset  ◡';  // instead of remove
        txtCancel.innerHTML = 'cancel  ◡';
        txtSave.innerHTML   = 'save  ◡';
        
    }
    
    if( ( vh === "visible" ) && topEditing ) { 
        
        txtImport.innerHTML = 'import  ◠';
        txtExport.innerHTML = 'export  ◠';
        txtRemove.innerHTML = 'reset  ◠'; // instead of remove
        txtCancel.innerHTML = 'cancel  ◠';
        txtSave.innerHTML   = 'save  ◠';
        
    }
    
    if( vh === "hidden" ) {
        
        txtoE.style.visibility = vh;
        opngE.style.visibility = vh;
        capC.style.visibility = vh;
        txtCapC.style.visibility = vh;        
        
    }
    
    if( vh === "visible" && ( btmEditing || topEditing ) ) {
        
        translateMarker.visible = true;
        heightMarker.visible = true;
        openingMarker.visible = true;
        
    } else {
        
        translateMarker.visible = false;
        heightMarker.visible = false;
        openingMarker.visible = false;
        
    }
    
}

function visibilityD( vh ) {
    
    containerD.style.visibility = vh;
    
    importCD.style.visibility = vh;
    exportCD.style.visibility = vh;
    removeCD.style.visibility = vh;
    cancelCD.style.visibility = vh;
    saveCD.style.visibility = vh;
    
    if( vh === "visible" ) {
        
        directionC.style.visibility = "hidden";
        txtDirectionC.style.visibility = "hidden";
        
        txtImport.innerHTML = 'import  ǁ';
        txtExport.innerHTML = 'export  ǁ';
        txtRemove.innerHTML = 'remove  ǁ';
        txtCancel.innerHTML = 'cancel  ǁ';
        txtSave.innerHTML   = 'save  ǁ';
        
    }
    
}

function visibilityChangesCD( ) {
    
    visibilityD( "hidden" );
    visibilityC( "visible" );
    
    if ( onlyVert ){
        
        importCD.style.visibility = "hidden";
        exportCD.style.visibility = "hidden";
        directionC.style.visibility = "hidden";
        txtDirectionC.style.visibility = "hidden";
        removeCD.style.visibility = "hidden";
        saveCD.style.visibility = "hidden";
        txtCancel.innerHTML = 'EXIT  ▦'; // ... like cancel 
        
    } else {
        
        if ( isShape[ apdIdx ][ cutIdx ] ) {
                        
            directionC.style.visibility = "hidden";
            directionC.checked = false;
            txtDirectionC.style.visibility = "hidden";
            
        } else {
            
            directionC.checked = true; // after shape
            
        }
        
    }
    
    vertEditing = false;
    cutEditing = true;
    
}

function setLineCurveVisibility( ) {
    
    if( onlyHole[ apdIdx - 1 ] ) {
        
        lineL.visible = false;
        lineR.visible = false;
        curveL.visible = false;
        curveR.visible = false;
        
        for ( let j = 0; j < nCurvePtsB; j ++ ) {
            
            cutMarkerL[ j ].visible = false;   
            
        }
        
    } else {
        
        lineL.visible = true;
        lineR.visible = true;
        curveL.visible = true;
        curveR.visible = true;
        
        for ( let j = 0; j < nCurvePtsB; j ++ ) {
            
            cutMarkerL[ j ].visible = true;    
            
        }
        
    }
    
}

function showOutput( ) {
    
    output.style.display = 'inline';
        
}

function hideOutput( ) {
    
    exportLines.value = '';
    downloadGltf.style.display = 'none';
    output.style.display = "none";
    
}

// --- drag functions ---

function get_pointer_pos( e ) {
    
    let posx = 0, posy = 0;
    
    if( e.clientX ) {
    
        posx = e.clientX;
        posy = e.clientY;
        
    }
    
    return { x: posx, y: posy };
    
}

function handle_down( e ) {
    
    const pos = get_pointer_pos( e );
    down( e, pos );
    
}

function handle_move( e ) {
    
    const pos = get_pointer_pos( e );
    moveDIV( e, pos );
}

function handle_up( e ) {
    
    upDIV( e );
    
}

function down( e, pos ) {
    
    const target = parent( e.target, drag_class );
    
    if( target ) {
        
        document.body.style.touchAction = "none";
        e.preventDefault( );
        dragele = target;
        posStart = { x: dragele.offsetLeft, y: dragele.offsetTop} ;
        pointerPosDown = pos;
        //dragele.style.zIndex = ++zmax; // only if more then one DIV
        dragele.focus( );
        
    }
    
}

function moveDIV( e, pos ) {
    
    if( dragele ) {
        
        e.preventDefault( );
        dragele.style.left = ( posStart.x + pos.x - pointerPosDown.x ) + "px";
        dragele.style.top =  ( posStart.y + pos.y - pointerPosDown.y ) + "px";
        
    }
}

function upDIV(e) { // end of action
    
    if(dragele) {
        
        dragele = null;
        document.body.style.touchAction = "auto";
        
    }
    
}

function parent( child, classname ) {
    
    if( child && "closest" in child ) return child.closest( "." + classname );
    let ele = child;
    
    while( ele ) { 
        if( ele.classList && ele.classList.contains( classname ) ) return ele;
        else ele = ele.parentElement;
    }
    
    return null;
    
}

// ......... others ................................................................. 

function animate( ) {

    requestAnimationFrame( animate );
    
    rendererA.render( sceneA, cameraA );
    rendererB.render( sceneB, cameraB );
    rendererC.render( sceneC, cameraC );
    rendererD.render( sceneD, cameraD );
 
}

function link( geoms ) {
    
    const g = new BufferGeometry( );
    
    g.faceCounts = [];
    g.positionCounts = [];
    
    let faceCount = 0; 
    let positionCount = 0;
    
    for ( let i = 0; i < geoms.length; i ++ ) {
        
        g.faceCounts[ i ] = geoms[ i ].index.array.length / 3;
        faceCount += g.faceCounts[ i ];
        
        g.positionCounts[ i ] = geoms[ i ].attributes.position.count;
        
        positionCount += g.positionCounts[ i ];
    
    }
     
    nTriang.innerHTML = faceCount + ' triangles';
    
    const indices = new Uint32Array( faceCount * 3 );
    const positions = new Float32Array( positionCount * 3 );
    
    g.setIndex( new BufferAttribute( indices, 1 ) );
    g.setAttribute( 'position', new BufferAttribute( positions, 3 ) );
     
    let indOffs = 0;
    let indVal  = 0;
    let posOffs = 0;
    
    for ( let i = 0; i < geoms.length; i ++ ) {
        
        for ( let j = 0; j <= geoms[ i ].index.array.length; j ++ ) {
            
           indices[ j + indOffs ] = indVal + geoms[ i ].index.array[ j ] ;
            
        }
        
        for ( let j = 0; j < geoms[ i ].attributes.position.count * 3; j ++ ) {
            
            positions[ j + posOffs ] = geoms[ i ].attributes.position.array[ j ];
            
        }
        
        indOffs += g.faceCounts[ i ] * 3;
        indVal  += g.positionCounts[ i ];
        posOffs += g.positionCounts[ i ] * 3;
        
    }
    
    for ( let i = 0; i < geoms.length; i ++ ) {
        
        geoms[ i ].dispose( );  // Only if the individual geometries are not required.
        
    }
    
    return g;
    
}

function unite( geoms ) {
    
    const g = new BufferGeometry( );
    const indices = [];
    const positions = [];
    
    let nPos;       // counts the positions
    let ig = 0;     // index geoms 
    let apd;        // appendix ( main 0, appendices 1 .. )
    let reducedConCount;  //  = nCon - divCon,  calculation for mandatory following cylinder
    let offs;
    
    let idxHole = geoms[ 0 ].detail * 2; // starts after btm, top
    
    for ( let i = 0; i < geoType.length; i ++ ) {
        
        apd = Math.floor( i / 3 );
           
        if( geoType[ i ] !== '' ) {
            
            switch ( geoType[ i ] ) {
                
                case 'mainCyl': // ig: 0, copy values
                
                     for ( let j = 0; j < geoms[ 0 ].attributes.position.count * 3; j ++ ) {
                        
                        positions.push( geoms[ 0 ].attributes.position.array[ j ] );
                    }
                    
                    for ( let j = 0; j < geoms[ 0 ].index.array.length; j ++ ) {
                        
                        indices.push( geoms[ 0 ].index.array[ j ] );
                        
                    }
                    
                    nPos = geoms[ 0 ].attributes.position.count;
                    
                break;
                    
                case 'mainBtmCap':
                case 'mainTopCap':
                case 'apdTopCap':
                    
                    if( geoType[ i ] === 'mainBtmCap' ) offs = 0;
                    if( geoType[ i ] === 'mainTopCap' ) offs = geoms[ ig ].parameters.rs;
                    if( geoType[ i ] === 'apdTopCap' ) offs = nPos - geoms[ ig - 1 ].attributes.position.count + geoms[ ig ].parameters.rs;
                    
                    const nCap = geoms[ ig ].attributes.position.count; 
                    const nwc = nCap - ( geoms[ ig ].parameters.hole ? 0 : 1 );  // without center point
                    
                    let j = 0;
                    
                    while ( j < nwc ) {
                        
                        if ( j % geoms[ ig ].parameters.hs !== 0 ) { // without edge position
                        
                            positions.push( geoms[ ig ].attributes.position.array[ j * 3 ] );
                            positions.push( geoms[ ig ].attributes.position.array[ j * 3 + 1 ] );
                            positions.push( geoms[ ig ].attributes.position.array[ j * 3 + 2 ] );
                            
                        }
                        
                        j ++;
                        
                    }
                    
                    if ( !geoms[ ig ].parameters.hole ) {
                        
                        positions.push( geoms[ ig ].attributes.position.array[ nwc * 3 ] );
                        positions.push( geoms[ ig ].attributes.position.array[ nwc * 3 + 1 ] );
                        positions.push( geoms[ ig ].attributes.position.array[ nwc * 3 + 2 ] );
                        
                    }
                    
                    const reduceIdxBtmTop = ( n, d ) =>  n - Math.floor( n / d ) - 1;
                    
                    const centerIndices = geoms[ ig ].parameters.hole ? 0 : geoms[ ig ].parameters.rs * 3;
                    const idxLen = geoms[ ig ].index.array.length - centerIndices;
                    
                    for ( let j = 0; j < idxLen; j ++ ) {
                        
                        const edge = geoms[ ig ].index.array[ j ] % geoms[ ig ].parameters.hs === 0;
                        
                        if ( edge ) {
                            
                            indices.push(  offs + geoms[ ig ].index.array[ j ] / geoms[ ig ].parameters.hs );
                            
                            
                        } else {
                            
                            indices.push( nPos + reduceIdxBtmTop( geoms[ ig ].index.array[ j ], geoms[ ig ].parameters.hs ) );
                            
                        }
                        
                    }
                    
                    if ( !geoms[ ig ].parameters.hole ) {
                        
                        for ( let j = idxLen; j < idxLen + geoms[ ig ].parameters.rs * 3; j ++ ) { 
                            
                            if( j % 3 === 0 ) {  //  ( index center point, edge point, edge point )
                                
                              indices.push( nPos + reduceIdxBtmTop( geoms[ ig ].index.array[ j ], geoms[ ig ].parameters.hs ) + 1 ); // max
                                
                            } else {
                                
                               indices.push( nPos + reduceIdxBtmTop( geoms[ ig ].index.array[ j ], geoms[ ig ].parameters.hs ) );
                                
                            }
                            
                        }
                        
                    }
                    
                    nPos += ( nCap - geoms[ ig ].parameters.rs ); //   - => without edge positions
                    
                break;
                
                case 'Con':
                    
                    const nCon = geoms[ ig ].attributes.position.count;
                    const divCon = 4 * geoms[ 0 ].adapt[ apd - 1 ][ 4 ];
                    
                    reducedConCount = nCon - divCon; // calculation also for the following cylinder
                    
                    for ( let j = 0; j < nCon - divCon; j ++ ) { // without edge positions ( to main hole )
                        
                        positions.push( geoms[ ig ].attributes.position.array[ j * 3 ] );
                        positions.push( geoms[ ig ].attributes.position.array[ j * 3 + 1 ] );
                        positions.push( geoms[ ig ].attributes.position.array[ j * 3 + 2 ] );
                        
                    }
                    
                    for ( let j = 0; j < geoms[ ig ].index.array.length; j ++ ) {
                        
                        const edgeMain = ( geoms[ ig ].index.array[ j ] >= reducedConCount );
                        
                        if( edgeMain ) {
                            
                            indices.push( idxHole + geoms[ ig ].index.array[ j ] - reducedConCount );
                            
                        } else {
                            
                            indices.push( nPos + geoms[ ig ].index.array[ j ] );
                            
                        }
                        
                    }
                    
                    idxHole += divCon; // next hole start index
                    
                    nPos += reducedConCount;
                    
                break;
                    
                case 'Cyl':
                    
                    const nCyl = geoms[ ig ].attributes.position.count;
                    const divCyl = 4 * geoms[ 0 ].adapt[ apd - 1 ][ 4 ];
                    
                    for ( let j = divCyl; j < nCyl; j ++ ) { // without bottom edge positions ( to conect geometry 'Con' )
                        
                        positions.push( geoms[ ig ].attributes.position.array[ j * 3 ] );
                        positions.push( geoms[ ig ].attributes.position.array[ j * 3 + 1 ] );
                        positions.push( geoms[ ig ].attributes.position.array[ j * 3 + 2 ] );                        
                        
                    }
                    
                    for ( let j = 0; j < geoms[ ig ].index.array.length; j ++ ) {
                        
                        if ( geoms[ ig ].index.array[ j ] < divCyl ) { // edge
                            
                            const d0 = geoms[ ig ].index.array[ j ] === 0 ? 0 : divCyl; // counter-rotating from starting position
                            indices.push( nPos - reducedConCount - geoms[ ig ].index.array[ j ] + d0 );
                            
                        } else {
                            
                            indices.push( nPos + geoms[ ig ].index.array[ j ] - divCyl );
                            
                        }
                        
                    }
                    
                    nPos += nCyl - divCyl;
                     
                break;
                
                case 'Hole':
                    
                    const divHole = 4 * geoms[ 0 ].adapt[ apd - 1 ][ 4 ];
                    idxHole += divHole;
                
                    ig --; // see ig ++;  below
                
                break;
                
                
            }
            
            ig ++;
            
        }
             
    }
    
    nTriang.innerHTML = indices.length / 3 + ' triangles';
    
    g.setIndex( new BufferAttribute( new Uint32Array( indices ), 1 ) );
    g.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3 ) );
    
    for ( let ig = 0; ig < geoms.length; ig ++ ) {
        
        geoms[ ig ].dispose( );  // Only if the individual geometries are not required.
        
    }
    
    return g;

}

function downloadMeshGltf( ) {
    
    exporter.parse( finalMeshWire, ( gltf ) => { out = JSON.stringify( gltf, null, 2 );
        saveString( out, 'mesh.gltf' );
        } 
    );
    
}

function expandForm( ) {
    
    for ( let i = 0; i < nCurvePtsB; i ++ ) {
    
        for ( let k = 0; k < cutCoords[ apdIdx ][ i ].length / 2; k ++ ) {
        
            cutCoords[ apdIdx ][ i ][ k * 2 ] *= expansion.value;
            cutCoords[ apdIdx ][ i ][ k * 2 + 1 ] *= expansion.value;
                
        }
        
    }                
    
    ccfb = false; //cut coordinates first bottom
    cutMarkerLenabled[ apdIdx ][ 0 ] = true;
    
    ccft = false; //cut coordinates first top
    cutMarkerLenabled[ apdIdx ][ nCurvePtsB - 1 ] = true;
    
    show3D( );
    
}

function saveString( text, filename ) {
    
    save( new Blob([text], { type: 'text/plain'  } ), filename );
    
}

function save( blob, filename ) {
    
    linkElem.href = URL.createObjectURL( blob );
    linkElem.download = filename;
     linkElem.click( );
    
     URL.revokeObjectURL( url ); // CHROME error 
    
}

function saveDesign( text, n ) {
    
    const nnn = n < 10 ? '00' + n : ( n < 100 ? '0' + n : '' + n );
    
    save( new Blob([text], { type: 'text/plain'  } ), nnn + '-dsgn.txt' ); 
    
}

function numbers( lines ) {
    
    return lines.map( line => {
        
        const numbers = line.match(/-?\d+(\.\d+)?/g);
        return numbers ? numbers.map( Number ) : [];
        
    } );
    
}

function positionLineL( count, reticleX, reticleY ) {
    
    gLineL.positions[ count * 3 ] = reticleX;
    gLineL.positions[ count * 3 + 1 ] = reticleY;
    gLineL.positions[ count * 3 + 2 ] = 0;
    
}

function positionLineR( count, reticleX, reticleY ) {
    
    gLineR.positions[ count * 3 ] = reticleX;
    gLineR.positions[ count * 3 + 1 ] = reticleY;
    gLineR.positions[ count * 3 + 2 ] = 0;
    
}

function makeBasis( t, n, b ) { // tangent,  normal, binormal
    
    n.crossVectors( b, t );
    b.crossVectors( t, n );
    b.x = 0; // to prevent torsion
    b.normalize( );
    n.crossVectors( b, t );
    n.normalize( );
    
}

function interpolateValue( arr, _α, _t ) { //   _α radiant
    
    let  α, t;
    
    α = _α <= 0 ? 0 : _α;
    α = _α >= pi * 2 ? pi * 2 - 0.0000001 : _α; 
    
    const a = α / ( pi * 2 ); // normalized angle
     
    t = _t <= 0 ? 0 : _t;
    //t = _t >= 1 ? 0.999999999999 : _t;
    t = _t >= 1 ? 0.9999999 : _t;
    //t = _t >= 1 ? 1 : _t; // error
    
    const iMax = arr.length - 1; 
    const jMax = arr[ 0 ].length - 1; //  0: identical row length
    const da = 1 / jMax ;
    const dt = 1 / iMax ;
    
    // get surrounding points 
    
    let i0, i1, j0, j1, q0, q1; 
    
    for ( let i = 0; i < iMax; i ++ ) {
        
        if ( t >= i / iMax && t < ( i + 1 ) / iMax ) { 
            
            i0 = i;
            i1 = i + 1;
            
        }
        
        for( let j = 0; j < jMax; j ++ ) {
            
            if ( a >= j / jMax && a < ( j + 1 ) / jMax ) {
                
                j0 = j;
                j1 = j + 1;
                
            }
            
        }
        
    } 
  
    // bilinear interpolation
    
    q0 = ( a - j0 / jMax ) / da;
    q1 = ( j1 / jMax - a ) / da;
    
    //                      leftBtm                rightBtm    
    const vbtm = q1 * arr[ i0 ][ j0 ] + q0 * arr[ i0 ][ j1 ];
    //                      leftTop                rightTop
    const vtop = q1 * arr[ i1 ][ j0 ] + q0 * arr[ i1 ][ j1 ];   
    
    q0 = ( t - i0 / iMax ) / dt;
    q1 = ( i1 / iMax - t ) / dt;
    
    return  q1 * vbtm + q0 * vtop; // interpolated value;      
    
}

function oncrChange( ) {
    
    crValue =  parseInt( cr.value );
    crShow.innerHTML = crValue + '%';
    
}

function oncnChange( ) {
    
    cnValue = parseInt( cn.value );
    cnShow.innerHTML = cnValue + ' marker';
    
}

function ondnChange( ) {
    
    dnValue = parseInt( dn.value );
    dnShow.innerHTML = dnValue + ' marker';
    
}

function ondbasChange( ) {
    
    dbasValue = parseInt( dbas.value );
    dbasShow.innerHTML = dbasValue + '%';
    
}

function renewFirstSettings( ) {
    
    ccfb = true; // cut coordinates first bottom,   true => false
    ccft = true; // cut coordinates first top,   true => false
    vcf0 = true; // vertical coordinates first vertIdx 0,    true => false
    vcf1 = true; // vertical coordinates first vertIdx nCurvePtsC ,    true => false
    
}

function setCutRadius( value ) {
    
    cr.value = value;
    crShow.innerHTML = value + '%';
    const e = new Event("input", { bubbles: true } );
    cr.dispatchEvent( e );                 
    
}

function setCutToSliderValues( ) {
     
    alert ( 'Impossible for bottom and top- slider values are used.' );
         
    let α = pi;
    
    crValue = parseInt( cr.value );
    cnValue = parseInt( cn.value );
                
    cutCoords[ apdIdx ][ cutIdx ] = [];
    
    for ( let k = 0; k < cnValue; k ++ ) {
        
        x = crValue / 100 * cos( α );
        y = crValue / 100 * sin( α );
        
        cutCoords[ apdIdx ][ cutIdx ].push( x, y ); 
        
        α += 2 * pi / cnValue;
        
    }
    
    isShape[ apdIdx ][ cutIdx ] = false;
    
}

function getCutIdx( ) {
    
    retPos.set( reticleX + 1, reticleY ); //  + 1  left compensation 
    let dist2, jMin;
    let dMin2 = Infinity; 
    
    cutIdx = -1;
    
    for ( let j = 0; j < nCurvePtsB; j ++ ) { 
        
        const dx = gCurveL.positions[ j * 3     ] - retPos.x;
        const dy = gCurveL.positions[ j * 3 + 1 ] - retPos.y;
        dist2 = dx * dx + dy * dy;  //distance to squared 
        
        if ( dist2 < dMin2 ) {
            
            dMin2 = dist2;
            jMin = j;
            
        }
        
    }
    
    return  dMin2 < 0.000225 ? jMin : -1;     // to squared  -->  dMin < 0.015

}

function setVerticalReference( ) {
    
    alert ( 'Impossible for the vertical reference arrangements - slider values are used.' );
    
    if ( vertIdx === 0 ) {
            
        vertCoords[ apdIdx ][ 0 ] = []; // reset at index 0
        
    }
    
    if ( vertIdx === nCurvePtsC / 2 ) {
        
        vertCoords[ apdIdx ][ nCurvePtsC / 2 ] = []; // reset at index nCurvePtsC / 2
        
    }
    
    dnValue = parseInt( dn.value );
    dbasValue = parseInt( dbas.value );
    
    const dn1 = dnValue - 1;
    const db = dbasValue / 100;  // x% / 100
    
    const d = 2 * db / dn1;
    let y = -db;
    
    for ( let k = 0; k < 2; k ++ ) { // bottom, top  left as basis
        
        markerD0[ k ].position.set( -xD, y, 0 );
        markerD0[ k ].visible = true;
        gBasisD.attributes.position.array[ k * 3 + 1 ] = y;
        
        y += 2 * db;
        
    }
    
    y = -db; // reset
    
    for ( let k = 0; k <= dn1; k ++ ) { // right, height values
        
        markerD[ k ].position.set( xD, y, 0 );
        markerD[ k ].visible = true;
        y += d;
        
    }
    
    for ( let k = dn1 + 1; k < dnmax; k ++ ) {
        
        markerD[ k ].visible = false;
        
    }
    
    for ( let i = 0; i <= dn1; i ++ ) {
            
            const y = -db + 2 * db * i / dn1;
            const i6 = i  * 6;
            
            // pre-assignment with y = 0 :   -xD, y, 0,    xD, y, 0 
            
            gLinesD.positions[ i6 + 1 ] = gLinesD.positions[ i6 + 4 ] = y;
            
    }
    
    gLinesD.setDrawRange( 0, dnValue * 2 );
    
    const y0 = markerD0[ 0 ].position.y; // basis bottom
    const y1 = markerD0[ 1 ].position.y; // basis top
    const dy =  y1 - y0;
    
    gBasisD.attributes.position.needsUpdate = true;
    gLinesD.attributes.position.needsUpdate = true;
    
}

function getVertIdx( ) {
    
    let dist2, jMin;
    let dMin2 = Infinity; 
    
    for ( let j = 0; j < nCurvePtsC; j ++ ) {
        
        markerPos.set( vertMarkerC[ j ].position.x, vertMarkerC[ j ].position.y );
        
        dist2 = markerPos.distanceToSquared( retPos );
        
        if ( dist2 < dMin2 ) {
            
            dMin2 = dist2;
            jMin = j;
            
        }
        
    }
    
    return  dMin2 < 0.000225 ? jMin : -1;     // to squared  -->  dMin < 0.015
    
}

function getSize( ) {
    
    sizeFactor = scale / 200;
    exportFactor = scale / 2;
    
}

function useRadius( ) {
    
    r.value = ( r_ !== r.value && apdApplied ) ? r_ : r.value; 
    
}

function useHeight( ) {
     
    h.value = ( h_ !== h.value && apdApplied ) ? h_ : h.value; 
    
}

function getTriangleSide( ) {
    
    // unit: relative to height 2,  approximate side length of the triangles
    
    triangleSide = 0.001 * triangleside.value + 0.007;   //  0.008 .. 0.107
    
    // triangleSide = 0.001 * triangleside.value + 0.01; //  0.011 .. 0.11 
    // triangleSide = 0.001 * triangleside.value + 0.02; //  0.021 .. 0.12
    
}

function displayMainRadiusHeight( ){

    main_r.innerHTML = initialMainRadius.value;
    main_h.innerHTML = initialMainHeight.value;
    
}

function initComparisons( ) {
    
    containerB.style.width = ( 1.0 * containerB.offsetWidth ) + 'px';
    containerB.style.height = ( 1.0 * containerB.offsetHeight ) + 'px';
    
    let pX = containerB.offsetWidth;
    let pY = containerB.offsetHeight;
    
    if ( pX > widthB ) {
        
        sliderAB.style.left = widthB - 15 + "px";
        partsB.style.left = widthB - 1360 + "px";
        
    } else {
        
        sliderAB.style.left = pX - 15 + "px";
        partsB.style.left = pX - 1360 + "px";
        
    }
    
    if ( pY > heightB ) {
        
        sliderAB.style.top = heightB - 15 + "px";
        partsB.style.top = heightB + 3 + "px";
        
    } else {
        
        sliderAB.style.top = pY - 15 + "px";
        partsB.style.top = pY + 3 + "px";
        
    }
    
    let clicked = 0;
    
    // only controlsA
    const slideReady = () => {
        clicked = 1;
        controlsA.enabled = false;
    };
    
    const slideFinish = () => { 
        clicked = 0;
        controlsA.enabled = true;
    };
    
    const slideMove = ( e ) => {
        
        if ( clicked === 0 ) return false;
        
        let posX = getCursorPosX( e );
        let posY = getCursorPosY( e );
        
        //prevent the slider from being positioned outside the canvas
        if ( posX < 0 ) posX = 0;  
        if ( posX > widthB ) posX = widthB;
        slideX( posX );
        
        if ( posY < 0 ) posY = 0;   
        if ( posY > heightB ) posY = heightB; 
        slideY( posY );
        
    }
    
    sliderAB.addEventListener( 'pointerdown', slideReady );
    window.addEventListener( 'pointerup', slideFinish );
    window.addEventListener( 'pointermove', slideMove );
    
    containerC.style.left = leftC + "px";
    containerC.style.top = topC + "px";
    containerC.style.width = widthC + "px";
    containerC.style.height = heightC + "px";
    
    containerD.style.left = leftD + "px";
    containerD.style.top = topD + "px";
    containerD.style.width = widthD + "px";
    containerD.style.height = heightD + "px";
    
    sliderC.style.left = leftC + widthC - 8 + "px";
    sliderC.style.top  = topC + heightC - 8 + "px";
    
    partsC.style.left = leftC + widthC - 808 + "px";
    partsC.style.top  = topC + heightC + 2 + "px"; 
    
    const slideContainerC = ( e ) => {
        
        let posX = getCursorPosX( e );
        leftC = posX  - 20 - widthC;
        
        containerC.style.left = leftC + "px";
        sliderC.style.left = posX -  28 + "px";
        
        partsC.style.left = posX - 828 + "px";
        
        containerD.style.left = posX + 12 + "px";
        
    }
    
    sliderC.addEventListener( 'pointermove', slideContainerC );
    
    // detail functions
    
    function getCursorPosX( e ) {
        
        let getCur = ( e.pageX - containerB.offsetLeft ) - window.pageXOffset;
        return getCur; 
        
    }
    
    function getCursorPosY( e ) {
        
        let getCur = ( e.pageY - containerB.offsetTop ) - window.pageYOffset;
        return getCur; 
        
    }
    
    function slideX(x) {
        
        containerB.style.width = x + "px";
        //position the slider
        sliderAB.style.left = containerB.offsetWidth - ( 0.5 * sliderAB.offsetWidth - 15 ) + "px";
        partsB.style.left = containerB.offsetWidth - ( 0.5 * partsB.offsetWidth + 688 ) + "px";
        
    }
    
    function slideY(y) {
        
        containerB.style.height = y + "px";
        //position the slider
        sliderAB.style.top = containerB.offsetHeight - ( 0.5 * sliderAB.offsetHeight  - 15 ) + "px";
        partsB.style.top = containerB.offsetHeight - ( 0.5 * partsB.offsetHeight  - 15 ) + "px";
        
    }
    
}

function getTangent( curve, t, optionalTarget ) {
    
    const delta = 0.0001;
    
    let t1 = t - delta;
    let t2 = t + delta;
    
    // Capping in case of danger
    
    if ( t1 < 0 ) {
        
        t1 = 0;
        t2 = delta;
        
    }
    
    if ( t2 > 1 ) {
        
        t2 = 1;  
        t1 = 1 - delta;
        
    }
    
    const pt1 = curve.getPoint( t1 );
    const pt2 = curve.getPoint( t2 );
    
    const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2( ) : new Vector3( ) );
    
    tangent.copy( pt2 ).sub( pt1 ).normalize( );
    
    return tangent;
    
}

function quickCoSort( sort, A, left, right ) { // sort: for sorting;  A : array for co-sorting
    
    let index;
    
    if ( sort.length > 1 ) {
        
        index = partition( sort, A, left, right ); //index returned from partition
        
        if ( left < index - 1 ) { //more elements on the left side of the pivot
            
            quickCoSort( sort, A, left, index - 1 );
            
        }
        
        if ( index < right ) { //more elements on the right side of the pivot
            
            quickCoSort( sort, A, index, right );
            
        }
        
    }
    
    return sort;
    
    // ..... .....
    
    function partition( sort, A, left, right ) {
        
        const pivot = sort[ Math.floor( ( right + left ) / 2 ) ]; // middle element
        
        let i = left;  // left  pointer
        let j = right; // right pointer
        
        while ( i <= j ) {
            
            while ( sort[ i ] < pivot ) {
                
                i ++;
                
            }
            
            while ( sort[ j ] > pivot ) {
                
                j --;
                
            }
            
            if ( i <= j ) {
            
                swap( sort, A, i, j ); // sawpping two elements
                
                i ++;
                j --;
                
            }
            
        }
        
        return i;
        
    }
    
    function swap( sort, A, leftIndex, rightIndex ) {
        
        const temp = sort[ leftIndex ];
        sort[leftIndex] = sort[rightIndex];
        sort[rightIndex] = temp;
        
        const tempA = A[ leftIndex ];
        A[leftIndex] = A[rightIndex];
        A[rightIndex] = tempA;
               
    }
    
}

// .... geometry classes ........................................................

class DeformableCylinderWithHoles extends BufferGeometry {

// Algorithmus nach / Algorithm based on
// de: https://www2.mathematik.tu-darmstadt.de/~ehartmann/cdg0/cdg0n.pdf
// en: https://www2.mathematik.tu-darmstadt.de/~ehartmann/cdgen0104.pdf

constructor( p ) { 
    
    super( );
    this.type = 'Cyl';
    this.parameters = { p: p };
      
    const g = this;
    
    g.d = p.triangleSide;
    
    g.btmDiff = p.btmDiff;
    g.topDiff = p.topDiff;
    
    g.div4 = n4( p.radius, g.d );
    
    g.height = p.height;
    
    g.btm = -p.height / 2;
    g.radiusBottom = p.radiusBottom !== undefined ? g.d * n4( p.radiusBottom, g.d ) * 2 / pi : Number.MAX_SAFE_INTEGER;
    g.div4Btm =  p.radiusBottom !== undefined ? n4( p.radiusBottom, g.d ) : Number.MAX_SAFE_INTEGER;  
    g.phiBtm = p.phiBtm !== undefined ? p.phiBtm : 0;
    
    g.top = p.height / 2;
    g.radiusTop =  p.radiusTop !== undefined ? g.d * n4( p.radiusTop, g.d ) * 2 / pi : Number.MAX_SAFE_INTEGER;
    g.div4Top = p.radiusTop !== undefined ? n4( p.radiusTop, g.d ) : Number.MAX_SAFE_INTEGER ;
    g.phiTop = p.phiTop !== undefined ? p.phiTop : 0;
    
    g.holes = p.holes !== undefined ? p.holes : [];
    
    g.detail = g.div4 * 4; // division of the circle
    
    g.radius = g.d / sin( pi / g.detail ) / 2; // cylinder radius, for external use as well
    
    const rAdpTop = g.d / sin( pi / g.div4Top / 4 ) / 2; // adaptation radius top
    g.adjTop = rAdpTop - sqrt( rAdpTop * rAdpTop - g.radius * g.radius );   //adjustment top
    
    g.cylTop = g.top + g.adjTop; // top with adjustment
    
    const rAdpBtm = g.d / sin( pi / g.div4Btm / 4 ) / 2; // adaptation radius bottom
    g.adjBtm = rAdpBtm - sqrt( rAdpBtm * rAdpBtm - g.radius * g.radius ); // adjustment bottom
    
    g.cylBtm = g.btm - g.adjBtm; // bottom with adjustment
    
    g.fullHeight = g.cylTop - g.cylBtm; // cylinder height with adjustment parts top, bottom , - for external use as well
    
    g.t  = [];   // relative height
    g.ang = [];  // angle
    g.vi = [];   // vertex index   
    
    const dd = g.d * g.d;
    
    const squareLength = ( x,y,z ) => ( x*x + y*y + z*z );
    const length = ( x, y, z ) => ( sqrt( x * x + y * y + z * z ) );
    const lenXZ = ( x, z ) => ( sqrt( x * x + z * z ) );
    const prevFront = ( i ) => ( i !== 0 ? i - 1 : front.length - 1 );
    const nextFront  = ( i ) => ( i !== front.length - 1 ? i + 1 : 0 );
    const detYc0 = ( xa,ya,za, xb,yb,zb, xc,zc ) => ( xa*yb*zc + ya*zb*xc - za*yb*xc - ya*xb*zc ); // determinant yc = 0;
    
    let m; // index of the current front point
    let n; // number of new points
    let nT; // number of new triangles
    let nIns; // number of new points (after union or split)
    let dAng; // partial angle
    let len, d1, d2, d12; // lengths
    let iSplit, jSplit; // split front indices  
    let iUnite, jUnite, fUnite; // unite front indices, front number (to unite) 
    
    // points and vectors:
    let x, y, z, xp, yp, zp; // coordinates point and actual point p
    let x1, y1, z1, x2, y2, z2; // previous and next point to p in front
    let xn, zn; // normal, gradient  (cylinder: yn = 0)
    let xt1, yt1, zt1, xt2, yt2, zt2; // tangents
    let xs1, ys1, xs2, ys2; // p in tangential system (only x, y required)
    let xc, yc, zc; // actual point as center point for new points
    
    //  preparation
    
    g.indices = [];
    g.positions = [];
    
    let posIdx = 0;
    let indIdx = 0;
    let frontPosIdx, unionIdxA, unionIdxB, splitIdx;
    
    let front = []; // active front // front[ i ]: object { idx: 0, ang: 0 }
    let partFront = []; // separated part of the active front (to split)
    let insertFront = []; // new front points to insert into active front
    let fronts = []; // all fronts
    let partBounds = []; // bounding box of partFront [ xmin, xmax, ymin, ymax, zmin, zmax ]
    let boundings = []; // fronts bounding boxes
    let smallAngles = []; // new angles < 1.5
    
    let frontNo, frontStock;
    let unite = false;
    let split = false;
    
    // define fronts for cylinder boundaries y-axis
    
    frontNo = 0; // active front number
    frontStock = 0; // number of fronts still to be processed
    makeBoundaryFront( g.btm, g.div4Btm, -g.phiBtm,  1 ); // ... , sign
    makeBoundaryFront( g.top, g.div4Top, -g.phiTop, -1 ); // ... , sign
    
    g.adapt = []; // array of arrays [ x0, y0, z0, rHole, div4, idx ], cylinder hole values for external use // new:  added start idx
    g.holeIdx = []; // arrays of indices ( left and right hole positions ) // new  !!!!
    g.hole_t = [];  // array of hole .t values  
     
    // define holes fronts
    
    for ( let i = 0; i < g.holes.length; i ++ ) {
        
        if ( g.holes[ i ].length === 5 ) {  // new!  with stretch y ,  appendix height  h    5 parameters 
            
            makeCircularHole( i );  // [ y, phi, r, stretch y, h ] 
            
        } else {
            
             // makePointsHole( i ); // points: [ y, phi, ... ]  //  even parameter count
            
        }
    
    }
    
    // makeBoundaryFront( g.top, g.div4Top, -g.phiTop, -1 ); // ... , sign  //  in some older versions here
    
    frontNo = 0;
    front = fronts[ frontNo ];
    
    //////////////////  DEBUG triangles //////////////////////////////////
    //  let stp = 0;
    //////////////////////////////////////////////////////////////////////
    
    // ------ triangulation cycle -------------
    
    while ( frontStock > 0 ) {
        
        if (  !unite && !split ) { // triangulation on the front
            
            smallAngles = [];
            
            for ( let i = 0; i < front.length; i ++ ) {
                
                if( front[ i ].ang === 0 ) calculateFrontAngle( i ); // is to be recalculated (angle was set to zero)
                    
            }
            
            m = getMinimalAngleIndex( ); // front angle
            makeNewTriangles( m );
                
            if ( front.length > 9 && smallAngles.length === 0 ) {
                
                checkDistancesToUnite( m );
                checkDistancesToSplit( m );
                
            }
            
            if ( front.length === 3 ) {
                
                makeLastTriangle( ); // last triangle closes the front
                chooseNextFront( );  // if aviable
                
            }
            
        } else { // unite the active front to another front or split the active front
            
            if ( unite ) {
                
                uniteFront(  m, iUnite, fUnite, jUnite );
                trianglesAtUnionPoints( );
                unite = false; 
                                
            } else if ( split ) {
                
                splitFront( iSplit, jSplit );
                trianglesAtSplitPoints( );
                split = false;
                
            }
            
        }
        
    }
    
    g.setIndex( new BufferAttribute( new Uint32Array( g.indices ), 1 ) );
    g.setAttribute( 'position', new BufferAttribute( new Float32Array( g.positions ), 3 ) );
    
    // .....  detail functions .....
    
    function makeBoundaryFront( bd, divAdp, phiAdp, sign ) {
        
        // bd boundary, divAdp adaptation, phiAdp rotation of adaptive-deformed circle, rotation sign
        
        const rAdp = g.d / sin( pi / divAdp / 4 ) / 2 ;
        
        let xmin, ymin, zmin, xmax, ymax, zmax;
        let x0, z0;
        
        fronts[ frontNo ] = [];
        boundings[ frontNo ] = []
        
        xmin = zmin = Infinity;
        ymin = ymax = bd;
        xmax = zmax = -Infinity;
        
        for ( let i = 0, phi = 0; i < g.detail; i ++, phi += pi * 2 / g.detail ) {
                    
            // (adaptive-deformed) circle
            
            x = g.radius * cos( phi );        
            y = bd + sign * ( -rAdp +  sqrt( rAdp * rAdp - g.radius * g.radius * cos( phi ) * cos( phi ) ) );
            
            const iCoo = ( i + g.detail / 2 ) % g.detail;  // angular displacement
            
            if( sign ===  1 ) y -= g.btmDiff[ ( g.detail - 1 ) - iCoo ]; // mirroring 
            if( sign === -1 ) y += g.topDiff[ iCoo ]; 
            
            z = g.radius * sin( sign * phi );
            
            if ( phiAdp !== 0 ) {
                
                x0 = x;
                z0 = z;
                
                // rotate around y axis 
                x = x0 * cos( phiAdp ) - z0 * sin( phiAdp ); 
                z = x0 * sin( phiAdp ) + z0 * cos( phiAdp );
            }
            
            g.t.push( ( y - g.cylBtm ) / g.fullHeight ); // relative height ////////////////////////// new //////////////////////
            g.ang.push( atan2Pi( z, x ) );               // angle           ////////////////////////// new //////////////////////
            g.vi.push( posIdx / 3 );                     // vertex index    ////////////////////////// new //////////////////////
            
            g.positions[ posIdx     ] = x;
            g.positions[ posIdx + 1 ] = y;
            g.positions[ posIdx + 2 ] = z;
            
            fronts[ frontNo ].push( { idx: posIdx / 3, ang: 0 } );
            
            xmin = x < xmin ? x : xmin;
            ymin = y < ymin ? y : ymin;
            zmin = z < zmin ? z : zmin;
            
            xmax = x > xmax ? x : xmax;
            ymax = y > ymax ? y : ymax;
            zmax = z > zmax ? z : zmax;
            
            posIdx += 3;
            
        }
        
        boundings[ frontNo ].push( xmin, xmax, ymin, ymax, zmin, zmax );
        
        frontNo ++;
        frontStock ++;
        
    }
    
    function makePointsHole( i ) {
        
        let  phi, count, xmin, ymin, zmin, xmax, ymax, zmax, xv2, yv2, zv2;
        
        xmin = ymin = zmin = Infinity;
        xmax = ymax = zmax = -Infinity;
        
        fronts[ frontNo ] = [];
        boundings[ frontNo ] = [];
        
        
        // ORIENTATION   AND  ° to rad ////////////////
        //phi = rad ( g.holes[ i ][ 1 ] ) - p2i;
         phi = rad ( g.holes[ i ][ 1 ] ); 
        
        x1 = g.radius * cos( phi );
        y1 = g.holes[ i ][ 0 ];
        z1 = -g.radius * sin( phi );
        
        for ( let j = 1; j < g.holes[ i ].length / 2 + 1; j ++ ) {
        
            g.positions[ posIdx     ] = x1;
            g.positions[ posIdx + 1 ] = y1;
            g.positions[ posIdx + 2 ] = z1;
            
            fronts[ frontNo ].push( { idx: posIdx / 3, ang: 0 } );
            
            xmin = x1 < xmin ? x1 : xmin;
            ymin = y1 < ymin ? y1 : ymin;
            zmin = z1 < zmin ? z1 : zmin;
            
            xmax = x1 > xmax ? x1 : xmax;
            ymax = y1 > ymax ? y1 : ymax;
            zmax = z1 > zmax ? z1 : zmax;
            
            posIdx += 3;            
            
            phi = g.holes[ i ][ j < g.holes[ i ].length / 2 ? j * 2 + 1 : 1 ]; // 1 => connect to start
            
            x2 = g.radius * cos( phi );
            y2 = g.holes[ i ][ j < g.holes[ i ].length / 2 ? j * 2 : 0 ]; // 0 => connect to start
            z2 = -g.radius * sin( phi );
            
            xv2 = x2 - x1;
            yv2 = y2 - y1;
            zv2 = z2 - z1;
            
            len = length( xv2, yv2, zv2 );
            
            if ( len > g.d ) {
                
                count = Math.ceil( len / g.d );
                
                for ( let k = 1; k < count; k ++ ) {
                    
                    x = x1 + k * xv2 / count;
                    y = y1 + k * yv2 / count;
                    z = z1 + k * zv2 / count;
                    
                    len = lenXZ( x, z );   // to bring the point to the surface (radius * ..)
                    
                    x = g.radius * x / len;
                    z = g.radius * z / len;
                    
                    g.t.push( ( y - g.cylBtm ) / g.fullHeight ); // relative height ////////////////////////// new //////////////////////
                    g.ang.push( atan2Pi( z, x ) );               // angle           ////////////////////////// new //////////////////////
                    g.vi.push( posIdx / 3 );                     // vertex index    ////////////////////////// new //////////////////////
                    
                    g.positions[ posIdx     ] = x;
                    g.positions[ posIdx + 1 ] = y;
                    g.positions[ posIdx + 2 ] = z;
                        
                    fronts[ frontNo ].push( { idx: posIdx / 3, ang: 0 } );
                    
                    xmin = x < xmin ? x : xmin;
                    ymin = y < ymin ? y : ymin;
                    zmin = z < zmin ? z : zmin;
                    
                    xmax = x > xmax ? x : xmax;
                    ymax = y > ymax ? y : ymax;
                    zmax = z > zmax ? z : zmax;
                    
                    posIdx += 3;
                    
                }
                
            }
            
            x1 = x2;
            y1 = y2;
            z1 = z2;
            
        }
        
        boundings[ frontNo ].push( xmin, xmax, ymin, ymax, zmin, zmax );
        
        frontNo ++;
        frontStock ++;
        
    }
    
    function makeCircularHole( i ) {
        
        const stretchHoleY = g.holes[ i ][ 3 ] * 1.2; // new:  stretch  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        
        let x0, z0;
        
        const y0 = -g.height / 2 + g.height * g.holes[ i ][ 0 ];  // new up,  based on bottom of main geometry
        
        // ORIENTATION   AND  ° to rad ////////////////
        //const phi = rad( g.holes[ i ][ 1 ] ) - p2i;
        const phi = rad( g.holes[ i ][ 1 ] );
        
        const div4 =  n4( g.holes[ i ][ 2 ], g.d );
        
        const countH = div4 * 4;
        
        let xmin, ymin, zmin, xmax, ymax, zmax;
        
        xmin = ymin = zmin = Infinity;
        xmax = ymax = zmax = -Infinity;
        
        const rHole =  1.12 * g.d / sin( pi / countH ) / 2; // radius (x-deformed) cutting circle // => 1.12 to connect !!!
        
        // ORIENTATION ////////////////
        x0 = rHole * sin( phi + p2i );   
        z0 = rHole * cos( phi + p2i ); 
        
        // cylinder hole values for external use
        g.adapt.push( [ x0, y0, z0, rHole, div4, posIdx / 3 ] ); // new: added start idx = posIdx / 3 !!!!!!!!!!!!!!!!!!!!!!!!!
        
        fronts[ frontNo ] = [];
        boundings[ frontNo ] = [];
        
        for ( let j = countH - 1, alpha = 0 ; j > -1; j --, alpha += 2 * pi / countH ) {
            
            // (deformed) cutting circle in x-axis direction
            
            x0 = sqrt( g.radius * g.radius - rHole * rHole * cos( alpha ) * cos( alpha ) );
            y = y0 + rHole * stretchHoleY * sin( alpha );  // with stretch height
            z0 = rHole * cos( alpha );
             
            // rotate around y axis 
            x = x0 * cos( phi ) - z0 * sin( phi ); 
            z = -x0 * sin( phi ) - z0 * cos( phi );
            
            g.t.push( ( y - g.cylBtm ) / g.fullHeight ); // relative height ////////////////////////// new //////////////////////
            g.ang.push( atan2Pi( z, x ) );               // angle           ////////////////////////// new //////////////////////
            g.vi.push( posIdx / 3 );                     // vertex index    ////////////////////////// new //////////////////////
            
            
            // !!! new: indices of left and right hole positions !!!
            
            if ( j === countH - 1 ) { 
                
                g.holeIdx.push( posIdx / 3 );
                g.hole_t.push( ( y - g.cylBtm ) / g.fullHeight ); // hole center relative height 
                
            }
            
            if ( j === countH / 2 - 1 ) {
                
                g.holeIdx.push( posIdx / 3 );
                
            }
            
            g.positions[ posIdx     ] = x;
            g.positions[ posIdx + 1 ] = y;
            g.positions[ posIdx + 2 ] = z;
            
            fronts[ frontNo ].push( { idx: posIdx / 3, ang: 0 } );
            
            xmin = x < xmin ? x : xmin;
            ymin = y < ymin ? y : ymin;
            zmin = z < zmin ? z : zmin;
            
            xmax = x > xmax ? x : xmax;
            ymax = y > ymax ? y : ymax;
            zmax = z > zmax ? z : zmax;
            
            posIdx += 3;
            
        }
        
        boundings[ frontNo ].push( xmin, xmax, ymin, ymax, zmin, zmax );
        
        frontNo ++;
        frontStock ++;
        
    }
     
    function checkDistancesToUnite( m ) { // for new active front points
        
        let idxJ, xChk, yChk, zChk, ddUnite;
        let ddUniteMin = Infinity;
        unite = false;
        
        for ( let i = 0; i < insertFront.length; i ++ ) {
            
            getPoint( m + i );
            
            for ( let f = 0; f < fronts.length; f ++ ) { 
                
                if ( f !== frontNo ) {
                    
                    xChk = ( xp > boundings[ f ][ 0 ] - g.d ) && ( xp < boundings[ f ][ 3 ] + g.d );
                    yChk = ( yp > boundings[ f ][ 1 ] - g.d ) && ( yp < boundings[ f ][ 4 ] + g.d );
                    zChk = ( zp > boundings[ f ][ 2 ] - g.d ) && ( zp < boundings[ f ][ 5 ] + g.d );
                    
                    if (  xChk || yChk || zChk ) {
                        
                        for ( let j = 0; j < fronts[ f ].length; j ++ ) {
                            
                            idxJ = fronts[ f ][ j ].idx * 3;
                            
                            // Hint: here (2) is exceptionally point in other front!
                            x2 = g.positions[ idxJ ]; 
                            y2 = g.positions[ idxJ + 1 ];
                            z2 = g.positions[ idxJ + 2 ];
                            
                            ddUnite = squareLength ( x2 - xp, y2 - yp, z2 - zp );
                                
                            if ( ddUnite < dd && ddUnite < ddUniteMin ) {
                                
                                ddUniteMin = ddUnite; 
                                iUnite = i;
                                jUnite = j;
                                fUnite = f;
                                unite = true;
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
    }
    
    function uniteFront( m, i, f, j ) {
        
        let tmp = [];
        
        tmp[ 0 ] = front.slice( 0, m + i + 1 );    
        tmp[ 1 ] = fronts[ f ].slice( j , fronts[ f ].length );
        tmp[ 2 ] = fronts[ f ].slice( 0 , j + 1 );
        tmp[ 3 ] = front.slice( m + i, front.length );
        
        unionIdxA = m + i;
        unionIdxB = m + i + 1 + fronts[ f ].length
        
        front = [];
        
        for ( let t = 0; t < 4; t ++ ) {
            
            for ( let k = 0; k < tmp[ t ].length ; k ++ ) {
                
                front.push( tmp[ t ][ k ] );
                
            }
            
        }
        
        fronts[ f ] = []; // empty united front
        
        frontStock -= 1; // front is eliminated
        
    }
     
    function trianglesAtUnionPoints( ) {
        
        nIns = 0; // count inserted points
        
        calculateFrontAngle( unionIdxA );
        calculateFrontAngle( unionIdxA + 1 );
        
        if ( front[ unionIdxA ].ang < front[ unionIdxA + 1 ].ang ) {
            
            makeNewTriangles( unionIdxA );
            nIns += n - 1;
            calculateFrontAngle( unionIdxA + 1 + nIns );
            makeNewTriangles( unionIdxA + 1 + nIns );
            nIns += n - 1;
            
        } else {
            
            makeNewTriangles( unionIdxA + 1 );
            nIns += n - 1;
            calculateFrontAngle( unionIdxA );
            makeNewTriangles( unionIdxA );
            nIns += n - 1;
        }
        
        calculateFrontAngle( unionIdxB + nIns );
        calculateFrontAngle( unionIdxB + 1 + nIns );
        
        if ( front[ unionIdxB + nIns ].ang < front[ unionIdxB + 1 + nIns ].ang ) {
            
            makeNewTriangles( unionIdxB + nIns );
            nIns += n - 1;
            calculateFrontAngle( unionIdxB + 1 + nIns );
            makeNewTriangles( unionIdxB + 1 + nIns );
            
        } else {
            
            makeNewTriangles( unionIdxB + 1 + nIns );
            calculateFrontAngle( unionIdxB + nIns );
            makeNewTriangles( unionIdxB + nIns );
            
        }
        
    }    
    
    function checkDistancesToSplit( m ) { // for new active front points
        
        let mj, mjIdx, ddSplit;
        let ddSplitMin = Infinity;
        split = false;
            
        for ( let i = 0; i < front.length ; i ++ ) {
            
            for ( let j = 0; j < n; j ++ ) { // check n new points (insertFront)
            
                mj = m + j;
                
                // except new points themselves and neighbor points
                if ( Math.abs( i - mj ) > 3 && Math.abs( i - mj ) < front.length - 3 ) {
                    
                    mjIdx = front[ mj ].idx * 3;
                    
                    // Hint: here (1) is exceptionally new point in the front!
                    x1 = g.positions[ mjIdx ]; 
                    y1 = g.positions[ mjIdx + 1 ];
                    z1 = g.positions[ mjIdx + 2 ];
                    
                    getPoint( i );
                    
                    ddSplit = squareLength ( x1 - xp, y1 - yp, z1 - zp );
                    
                    if ( ddSplit < dd && ddSplit < ddSplitMin ) {
                        
                        ddSplitMin = ddSplit;
                        iSplit = i;
                        jSplit = mj;
                        split = true; 
                        
                    }
                    
                }
                
            }
            
        }
        
    }
        
    function splitFront( iSplit, jSplit ) {
        
        let k;
        
        front[ iSplit ].ang = 0;
        front[ jSplit ].ang = 0;
        
        if ( iSplit > jSplit )  { // swap
            
            k = jSplit;
            jSplit = iSplit;
            iSplit = k;
            
        } 
        
        splitIdx = iSplit;    // lower index
        
        partFront = [];
        
        // to duplicate
        let frontI = front[ iSplit ];
        let frontJ = front[ jSplit ];
        
        partFront = front.splice( iSplit + 1, jSplit - iSplit - 1 );
        partFront.unshift( frontI );
        partFront.push( frontJ );
        
        fronts.push( partFront );
        
        partFrontBounds( );
        
        frontStock += 1; // new front created
        
    }
    
    function trianglesAtSplitPoints( ) {
        
        nIns = 0; // count inserted points
        
        let idx0 = splitIdx; // splitIdx is the lower index 
        let idx1 = splitIdx + 1;
        
        calculateFrontAngle( idx0 );
        calculateFrontAngle( idx1 );
        
        if ( front[ idx1 ].ang < front[ idx0 ].ang ){
            
            makeNewTriangles( idx1 );
            nIns += n - 1;
            calculateFrontAngle( idx0 );
            makeNewTriangles( idx0 );
            
        } else {
            
            makeNewTriangles( idx0 );
            nIns += n - 1;
            calculateFrontAngle( idx1 + nIns );
            makeNewTriangles( idx1 + nIns );
            
        }
        
    }
    
    function getMinimalAngleIndex( ) {
        
        let angle = Infinity;
        let m;
        
        for ( let i = 0; i < front.length; i ++ ) {
            
            if( front[ i ].ang < angle  ) {
                
                angle = front[ i ].ang ;
                m = i;
                    
            }
            
        }
        
        return m;
        
    }
    
    function makeNewTriangles( m ) {
        
        //    m:  minimal angle (index)
        
        insertFront = []; // new front points
        
        nT = Math.floor( 3 * front[ m ].ang / pi ) + 1; // number of new triangles
        
        dAng = front[ m ].ang / nT;
        
        getSystemAtPoint( m );
        getNextPoint( m );
        
        d1 = length( x1 - xp, y1 - yp, z1 - zp );
        d2 = length( x2 - xp, y2 - yp, z2 - zp );
        d12 = length( x2 - x1, y2 - y1, z2 - z1 );
        
        // correction of dAng, nT in extreme cases
        
        if ( dAng < 0.8 && nT > 1 ) {
            
            nT --;
            dAng = front[ m ].ang / nT;
            
        }
        
        if ( dAng > 0.8 && nT === 1 && d12 > 1.25 * g.d ) {
            
            nT = 2; 
            dAng = front[ m ].ang / nT;
            
        }
        
        if ( d1 * d1 < 0.2 * dd ||  d2 * d2 < 0.2 * dd  ) {
            
            nT = 1;
            
        }
        
        n = nT - 1;  // n number of new points
            
        if ( n === 0 ) { // one triangle
            
            g.indices[ indIdx     ] = front[ m ].idx;
            g.indices[ indIdx + 1 ] = front[ prevFront( m ) ].idx; 
            g.indices[ indIdx + 2 ] = front[ nextFront( m ) ].idx;
            
            indIdx += 3;
            
            ///////////////  DEBUG triangles  //////////////////////
             // stp ++;
            ////////////////////////////////////////////////////////
            
            front[ prevFront( m ) ].ang = 0;
            front[ nextFront( m ) ].ang = 0;
            
            front.splice( m, 1 ); // delete point with index m from the front
            
        } else { // more then one triangle
            
            xc = xp;
            yc = yp;
            zc = zp;
            
            for ( let i = 0,  phi = dAng; i < n; i ++, phi += dAng ) {
                
                xp = xc + cos( phi ) * g.d * xt1 + sin( phi ) * g.d * xt2; 
                yp = yc + cos( phi ) * g.d * yt1 + sin( phi ) * g.d * yt2;
                zp = zc + cos( phi ) * g.d * zt1 + sin( phi ) * g.d * zt2;            
                
                len = lenXZ( xp, zp );   // to bring the point to the surface (radius * ..)
                
                x = g.radius * xp / len; ////////////////////////// new //////////////////////
                y = yp;                  ////////////////////////// new //////////////////////
                z = g.radius * zp / len; ////////////////////////// new //////////////////////
                
                g.t.push( ( y - g.cylBtm ) / g.fullHeight ); // relative height  ////////////////////////// new //////////////////////
                g.ang.push( atan2Pi( z, x ) );               // angle            ////////////////////////// new //////////////////////
                g.vi.push( posIdx / 3 );                     // vertex index     ////////////////////////// new //////////////////////
                
                g.positions[ posIdx     ] = x;
                g.positions[ posIdx + 1 ] = y;
                g.positions[ posIdx + 2 ] = z;
                
                insertFront.push( { idx: posIdx / 3, ang: 0 } );
                
                posIdx += 3;
                        
            }    
            
            g.indices[ indIdx     ] = front[ m ].idx;
            g.indices[ indIdx + 1 ] = front[ prevFront( m ) ].idx 
            g.indices[ indIdx + 2 ] = insertFront[ 0 ].idx;
            
            indIdx += 3;
            
            ///////////////  DEBUG  triangles  /////////////////////
             // stp ++;
            ////////////////////////////////////////////////////////
            
            front[ prevFront( m ) ].ang = 0;
            
            for ( let i = 0; i < n - 1; i ++ ) {
                
                g.indices[ indIdx     ] = front[ m ].idx;
                g.indices[ indIdx + 1 ] = insertFront[ i ].idx;
                g.indices[ indIdx + 2 ] = insertFront[ i + 1 ].idx;
                
                indIdx += 3;
                
                ///////////////  DEBUG triangles  //////////////////////
                // stp ++;
                ////////////////////////////////////////////////////////
                
            }
            
            g.indices[ indIdx     ] = front[ m ].idx;
            g.indices[ indIdx + 1 ] = insertFront[ n - 1 ].idx;
            g.indices[ indIdx + 2 ] = front[ nextFront( m ) ].idx;
            
            front[ nextFront( m ) ].ang = 0;
            
            indIdx += 3;
            
            ///////////////  DEBUG triangles  //////////////////////
             // stp ++;
            ////////////////////////////////////////////////////////
            
            replaceFront( m, insertFront ); // replaces front[ m ] with new points
            
        }
         
    }
    
    function makeLastTriangle( ) {
        
        g.indices[ indIdx     ] = front[ 2 ].idx;
        g.indices[ indIdx + 1 ] = front[ 1 ].idx 
        g.indices[ indIdx + 2 ] = front[ 0 ].idx;
        
        indIdx += 3;
        
        ///////////////  DEBUG triangles  //////////////////////
         // stp ++;
        ////////////////////////////////////////////////////////
        
        front = [];
        
        fronts[ frontNo ] = [];
        
        frontStock -= 1; // close front
        
    }
    
    function chooseNextFront( ) {
        
        if ( frontStock > 0 ) {
            
            for ( let i = 0; i < fronts.length; i ++ ) {
            
                if ( fronts[ i ].length > 0 ) {
                    
                    frontNo = i;
                    break;
                    
                }
                
            }
            
            front = fronts[ frontNo ];
            
            smallAngles = [];
            
            for ( let i = 0; i < front.length; i ++ ) {
                
                calculateFrontAngle( i ); // recalculate angles of next front
                
            }
            
        }
        
    }
    
    function atan2PI( x, y ) {
        
        let phi = Math.atan2( y, x );
        
        if ( phi < 0 ) phi = phi + pi * 2;
        
        return phi;
            
    }
    
    function coordTangentialSystem( ) {
        
        let det = detYc0( xt1, yt1, zt1, xt2, yt2, zt2, xn, zn ); // cylinder:  yn=yc=0
        
        xs1 = detYc0( x1 - xp, y1 - yp, z1 - zp, xt2, yt2, zt2, xn, zn ) / det;
        ys1 = detYc0( xt1, yt1, zt1, x1 - xp, y1 - yp, z1 - zp, xn, zn ) / det;
        //zs1  not needed
        
        xs2 = detYc0( x2 - xp, y2 - yp, z2 - zp, xt2, yt2, zt2, xn, zn ) / det;
        ys2 = detYc0( xt1, yt1, zt1, x2 - xp, y2 - yp, z2 - zp, xn, zn ) / det;
        //zs2 not needed
        
    }
    
    function calculateFrontAngle( i ) {
            
        let ang1, ang2;
        
        getSystemAtPoint( i );
        getNextPoint( i );
        
        coordTangentialSystem( );
        
        ang1 = atan2PI( xs1, ys1 );
        ang2 = atan2PI( xs2, ys2 );
        
        if ( ang2 < ang1 )  ang2 += pi * 2;
        
        front[ i ].ang  = ang2 - ang1;
        
        if ( front[ i ].ang < 1.5 ) smallAngles.push( i );
        
    }
    
    function partFrontBounds( ) {
        
        let idx, xmin, ymin, zmin, xmax, ymax, zmax;
        
        partBounds = [];
        
        xmin = ymin = zmin = Infinity;
        xmax = ymax = zmax = -Infinity;
        
        for( let i = 0; i < partFront.length; i ++ ) {
            
            idx = partFront[ i ].idx * 3;
            
            x = g.positions[ idx ]; 
            y = g.positions[ idx + 1 ];
            z = g.positions[ idx + 2 ];
            
            xmin = x < xmin ? x : xmin; 
            ymin = y < ymin ? y : ymin;
            zmin = z < zmin ? z : zmin;
            
            xmax = x > xmax ? x : xmax;
            ymax = y > ymax ? y : ymax;
            zmax = z > zmax ? z : zmax;
            
        }
        
        partBounds.push( xmin, ymin, zmin, xmax, ymax, zmax );
        
        boundings.push( partBounds );
        
    }
    
    function replaceFront( m, fNew ) {
        
        let rear = front.splice( m, front.length - m );
        
        for ( let i = 0; i < fNew.length; i ++ ) {
            
            front.push( fNew[ i ] ); // new front points
            
        }
        
        for ( let i = 1; i < rear.length; i ++ ) { // i = 1: without old front point m 
            
            front.push( rear[ i ] );
            
        }
        
    }
    
    function getSystemAtPoint( i ) {
        
        getPrevPoint( i );
        getPoint( i );
        
        len = lenXZ( xp, zp );
        xn = xp / len;
        zn = zp / len;
        
        // cross,  cylinder:  yn=0  
        
        xt2 = -zn * ( y1 - yp );
        yt2 = zn * ( x1 - xp ) - xn * ( z1 - zp );
        zt2 = xn * ( y1 - yp );
        
        len = length( xt2, yt2, zt2 ); // to normalize
        
        xt2 = xt2 / len;
        yt2 = yt2 / len;
        zt2 = zt2 / len;     
        
        // cross
        xt1 = yt2 * zn;
        yt1 = zt2 * xn - xt2 * zn;
        zt1 = -yt2 * xn;
        
    }
             
    function getPrevPoint( i ) {
        
        frontPosIdx = front[ prevFront( i ) ].idx * 3;
        
        x1 = g.positions[ frontPosIdx ]; 
        y1 = g.positions[ frontPosIdx + 1 ];
        z1 = g.positions[ frontPosIdx + 2 ];
        
    }
    
    function getPoint( i ) {
        
        frontPosIdx = front[ i ].idx * 3;
        
        xp = g.positions[ frontPosIdx ]; 
        yp = g.positions[ frontPosIdx + 1 ];
        zp = g.positions[ frontPosIdx + 2 ];
        
    }
    
    function getNextPoint( i ) {
        
        frontPosIdx = front[ nextFront( i ) ].idx * 3;
        
        x2 = g.positions[ frontPosIdx ];
        y2 = g.positions[ frontPosIdx + 1 ];
        z2 = g.positions[ frontPosIdx + 2 ];
        
    }
    
} // constructor 

} // class DeformableCylinderWithHoles

class ConnectGeometry extends BufferGeometry {

constructor( rs = 40, hs = 6 ) {  // default   radialSegments, heightSegments 
    
    super( );
    this.type = 'Con';
    this.parameters = { rs: rs, hs: hs };
    
    const indCount = rs * hs * 2 * 3;  // faces: rs * hs * 2 
    const posCount =  rs * ( hs + 1 ) * 3; // no double positions: rs * ( hs + 1 ) connected last to first
    
    this.indices = new Uint32Array( indCount );
    this.positions = new Float32Array( posCount );
    
    this.setIndex( new BufferAttribute( this.indices, 1 ) );
    //this.setAttribute( 'position', new BufferAttribute( this.positions, 3 ).setUsage( DynamicDrawUsage ) );
    this.setAttribute( 'position', new BufferAttribute( this.positions, 3 ) );
    
    let a, b1, b2, c1, c2;
    let idx = 0;
    
    for ( let i = 0; i < hs; i ++ ) {
    
        for ( let j = 0; j < rs; j ++ ) {
            
            // 2 faces / segment,  3 vertex indices
            a =  rs * i + j;
            b1 = rs * ( i + 1 ) + j;
            c1 = b1 + 1;
        // b2 = b1 + 1;
            c2 = a + 1;
            
            if (  j === rs - 1 ) { // connect to first
                
                this.indices[ idx     ] = a;
                this.indices[ idx + 1 ] = rs * ( i + 1 ) + j;
                this.indices[ idx + 2 ] = rs * ( i + 1 );
                
                this.indices[ idx + 3 ] = a;
                this.indices[ idx + 4 ] = rs * ( i + 1 );
                this.indices[ idx + 5 ] = rs * i;
                
            } else {
                
                this.indices[ idx     ] = a;
                this.indices[ idx + 1 ] = b1; //c1;
                this.indices[ idx + 2 ] = c1; //b1; 
                
                this.indices[ idx + 3 ] = a;
                this.indices[ idx + 4 ] = c1; // c2;
                this.indices[ idx + 5 ] = c2; //c1;  //  = b2
                
            }
             
            idx += 6;
            
        }
          
    }
    
} // constructor

} // class ConnectGeometry

class CapGeometry extends BufferGeometry {

constructor( rs = 40, hs = 20, hole = false ) {  // default   radialSegments, heightSegments, hole 
    
    super( );
    this.type = 'Cap';
    this.parameters = { rs: rs, hs: hs, hole: hole };
    
    this.indices = new Uint32Array( ( rs * ( hs - 1 ) * 2  + rs ) * 3 ); // + rs => to center point 
    this.positions = new Float32Array(rs * hs * 3 + ( hole ? 0 : 3 ) );  // no double pos , connected last to first ( + 3 center point )
    
    this.setIndex( new BufferAttribute( this.indices, 1 ) );
    this.setAttribute( 'position', new BufferAttribute( this.positions, 3 ) );
    
    let a, b1, b2, c1, c2;
    let idx = 0;
    
    for ( let j = 0; j < rs; j ++ ) {
    
        for ( let i = 0; i < hs - 1; i ++ ) {
            
            // 2 faces / segment,  3 vertex indices
            a  = hs * j + i;
            b1 = hs * ( j + 1 ) + i;
            c1 = b1 + 1;
         // b2 = c1;
            c2 = a + 1;
            
            if (  j === rs - 1 ) { // connect to first
                
                this.indices[ idx     ] = a;
                this.indices[ idx + 1 ] = i;
                this.indices[ idx + 2 ] = i + 1;
                
                this.indices[ idx + 3 ] = a;
                this.indices[ idx + 4 ] = i + 1;
                this.indices[ idx + 5 ] = c2;
                
            } else {
                
                this.indices[ idx     ] = a;
                this.indices[ idx + 1 ] = b1; 
                this.indices[ idx + 2 ] = c1;  
                
                this.indices[ idx + 3 ] = a;
                this.indices[ idx + 4 ] = c1; 
                this.indices[ idx + 5 ] = c2; 
                
            }
            
            idx += 6;
            
        }
    }
    
    if( !hole ) {
        
        a  =  hs * rs; // center point
        
        for ( let j = 0; j < rs; j ++ ) {
            
            b1 =  hs * ( j + 1 ) - 1;
            c1 =  b1 + hs;
            
            this.indices[ idx     ] = a;
            this.indices[ idx + 1 ] = b1;
            this.indices[ idx + 2 ] = j === rs - 1 ? hs -1 : c1; // connect to first
            
            idx += 3;
            
        }
        
    }
    
} // constructor

} // class CapGeometry

class CustomTubeGeometry extends BufferGeometry {

constructor( radialSegments, heightSegments, withTop, withBottom  ) { 
    
    super( );
    this.type = 'Tube';
    this.parameters = { radialSegments: radialSegments, heightSegments: heightSegments, withTop: withTop, withBottom: withBottom };
    
    const g = this;
    
    g.heightSegments = heightSegments;
    g.radialSegments = radialSegments;
    
    let indices = [];
    
    let index = 0;
    let indexArray = []; 
    
    for ( let y = 0; y <= heightSegments; y ++ ) {
        
        let indexRow = [];
        
        let v = y / heightSegments;
        
        for ( let x = 0; x <= radialSegments; x ++ ) {
            
            indexRow.push( index ++ );
            
        }
        
        indexArray.push( indexRow );
        
    }
    
    let a, b, c, d;
    
    for ( let i = 0; i < radialSegments; i ++ ) {
        
        for ( let j = 0; j < heightSegments; j ++ ) {
            
            a = indexArray[ j ][ i ];
            b = indexArray[ j + 1 ] [ i ];
            c = indexArray[ j + 1 ][ i + 1 ];
            d = indexArray[ j ] [ i + 1 ];
            
            indices.push( a, b, d );
            indices.push( b, c, d );
            
        }
        
    }
    
    let verticesCount = ( radialSegments + 1 ) * ( heightSegments + 1 )
    
    let centerIndexTop, centerIndexBottom;
    
    if ( withTop ) {
        
        centerIndexTop = index;
        const c = centerIndexTop;
        
        for ( let x = 1; x <= radialSegments; x ++ ) {
            
            const i = centerIndexTop + x;
            
            indices.push( i, i + 1, c );
            
            index ++;
            
        }
        
        verticesCount += radialSegments + 2; // with center
        
        index ++; // for center top
        
    }
       
    if ( withBottom ) {
        
        centerIndexBottom = ++ index; 
        
        const c = centerIndexBottom;
        
        for ( let x = 1; x <= radialSegments; x ++ ) {
            
            const i = centerIndexBottom + x;
            
            indices.push( i + 1, i, c );
            
           index ++;
           
        }
        
        verticesCount += radialSegments + 2; // with center
        
    } 
    
    g.setIndex( new BufferAttribute( new Uint32Array( indices ), 1 ) );
    g.setAttribute( 'position', new BufferAttribute( new Float32Array( verticesCount * 3 ), 3 ) );
    
    g.morph = function( points, radius ) { // sets the coordinate of all vertices
        
        g.pts = new CatmullRomCurve3( points , false ).getSpacedPoints( g.heightSegments ); // new center points
             
        // tangent( direction),  normal, binormal, shape in space
        
        let v3a = new Vector3( ); 
        let v3b = new Vector3( );
        
        let tangent = new Vector3( );    
        let normal = new Vector3( 0, 0, -1 ); // first normal to after ... 
        let binormal = new Vector3( );
        
        let idx = 0;
        
        for( let i = 0; i <= g.heightSegments; i ++ ) {
            
            if ( i === 0 ) tangent.subVectors( g.pts[ 1 ], g.pts[ 0 ] );
            if ( i > 0 && i < g.heightSegments ) tangent.subVectors( g.pts[ i + 1 ], g.pts[ i - 1 ] );
            if ( i === g.heightSegments ) tangent.subVectors( g.pts[ i ], g.pts[ i - 1 ] );
            
            binormal.crossVectors( normal, tangent );
            normal.crossVectors( tangent, binormal );
            
            binormal.normalize( );
            normal.normalize( );
                
            for( let j = 0; j <= g.radialSegments; j ++ ) {
            
                // circle in space
                v3a.addVectors( binormal.clone( ).multiplyScalar( Math.sin( Math.PI * 2 * j / g.radialSegments ) ), normal.clone( ).multiplyScalar(  Math.cos( Math.PI * 2 * j / g.radialSegments ) ) );
                
                v3a.multiplyScalar( radius );
                
                v3b.addVectors( g.pts[ i ], v3a );
                
                g.attributes.position.setXYZ( idx ++, v3b.x, v3b.y, v3b.z );
                
            }
            
        }
        
        idx --; // idx = ( g.radialSegments + 1 ) * ( g.heightSegments + 1 ) - 1; // last index torso
        
        const lastIndexTorso = idx;
        
        if( withTop ) {
            
            let x, y, z;
            
            g.attributes.position.setXYZ( ++ idx, g.pts[ 0 ].x, g.pts[ 0 ].y, g.pts[ 0 ].z ); // center top
            
            for( let j = 0; j <= g.radialSegments ; j ++ ) {
                
                x = g.attributes.position.getX( j );
                y = g.attributes.position.getY( j );
                z = g.attributes.position.getZ( j );
                
                g.attributes.position.setXYZ( ++ idx, x, y, z );
                
            }
            
        }
        
        if( withBottom ) {
            
            let x, y, z;
            
            g.attributes.position.setXYZ( ++ idx, g.pts[ g.heightSegments ].x, g.pts[ g.heightSegments ].y, g.pts[ g.heightSegments ].z ); // center bottom
            
            centerIndexBottom = idx;
            
            const idxBtm = lastIndexTorso - g.radialSegments;
            
            for( let j = 0; j <= g.radialSegments ; j ++ ) {
                
                x = g.attributes.position.getX( idxBtm + j );
                y = g.attributes.position.getY( idxBtm + j );
                z = g.attributes.position.getZ( idxBtm + j );
                 
                g.attributes.position.setXYZ( ++ idx, x, y, z );
                
            }
            
        }
        
        g.attributes.position.needsUpdate = true;
        g.computeVertexNormals( );
    
    }
    
}  // constructor  
    
}  // class CustomTubeGeometry

</script>
</html>